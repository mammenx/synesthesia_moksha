
ledos_main.elf:     file format elf32-littlenios2
ledos_main.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x001801c4

Program Header:
    LOAD off    0x00001000 vaddr 0x00180000 paddr 0x00180000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00180020 paddr 0x00180020 align 2**12
         filesz 0x00008f0c memsz 0x00008f0c flags r-x
    LOAD off    0x00009f2c vaddr 0x00188f2c paddr 0x0018aa38 align 2**12
         filesz 0x00001b0c memsz 0x00001b0c flags rw-
    LOAD off    0x0000c544 vaddr 0x0018c544 paddr 0x0018c544 align 2**12
         filesz 0x00000000 memsz 0x00000550 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00180000  00180000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   000001a4  00180020  00180020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00008cac  001801c4  001801c4  000011c4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000000bc  00188e70  00188e70  00009e70  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001b0c  00188f2c  0018aa38  00009f2c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000550  0018c544  0018c544  0000c544  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000023  00000000  00000000  0000ba38  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00000c70  00000000  00000000  0000ba60  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   0001f9ef  00000000  00000000  0000c6d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00007fac  00000000  00000000  0002c0bf  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   000096d6  00000000  00000000  0003406b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00001bc8  00000000  00000000  0003d744  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000030a7  00000000  00000000  0003f30c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00006bf0  00000000  00000000  000423b3  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_alt_sim_info 00000010  00000000  00000000  00048fa4  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 000003a8  00000000  00000000  00048fb8  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .thread_model 0000000c  00000000  00000000  0004c88a  2**0
                  CONTENTS, READONLY
 17 .cpu          00000003  00000000  00000000  0004c896  2**0
                  CONTENTS, READONLY
 18 .qsys         00000001  00000000  00000000  0004c899  2**0
                  CONTENTS, READONLY
 19 .simulation_enabled 00000001  00000000  00000000  0004c89a  2**0
                  CONTENTS, READONLY
 20 .sysid_hash   00000004  00000000  00000000  0004c89b  2**0
                  CONTENTS, READONLY
 21 .sysid_base   00000004  00000000  00000000  0004c89f  2**0
                  CONTENTS, READONLY
 22 .sysid_time   00000004  00000000  00000000  0004c8a3  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000009  00000000  00000000  0004c8a7  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000009  00000000  00000000  0004c8b0  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000009  00000000  00000000  0004c8b9  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 00000006  00000000  00000000  0004c8c2  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 0000002d  00000000  00000000  0004c8c8  2**0
                  CONTENTS, READONLY
 28 .jdi          00004791  00000000  00000000  0004c8f5  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     00048fce  00000000  00000000  00051086  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00180000 l    d  .entry	00000000 .entry
00180020 l    d  .exceptions	00000000 .exceptions
001801c4 l    d  .text	00000000 .text
00188e70 l    d  .rodata	00000000 .rodata
00188f2c l    d  .rwdata	00000000 .rwdata
0018c544 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 G:/WorK/github/synesthesia_moksha/wxp/dgn/sw/limbus_bsp//obj/HAL/src/crt0.o
001801fc l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
00180094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 hello_world_small.c
00000000 l    df *ABS*	00000000 aud_codec.c
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 pcm_bffr.c
00000000 l    df *ABS*	00000000 ssm2603_drvr.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 chthreads.c
00180618 l     F .text	00000040 list_insert
00180658 l     F .text	00000040 list_remove
00000000 l    df *ABS*	00000000 chvt.c
00000000 l    df *ABS*	00000000 chcoreasm.o
0018109c l       .text	00000000 _port_thread_start_loop
00000000 l    df *ABS*	00000000 alt_load.c
00181118 l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_putstr.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00181560 l     F .text	00000038 alt_dev_reg
00188f2c l     O .rwdata	00001060 jtag_uart
00189f8c l     O .rwdata	000000c4 uart_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
00181870 l     F .text	00000204 altera_avalon_jtag_uart_irq
00181a74 l     F .text	000000a4 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
001820b0 l     F .text	00000074 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
00182364 l     F .text	00000098 altera_avalon_uart_irq
001823fc l     F .text	000000d8 altera_avalon_uart_rxirq
001824d4 l     F .text	0000013c altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
00182664 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
001828b8 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 chdynamic.c
00000000 l    df *ABS*	00000000 chheap.c
0018c578 l     O .bss	0000001c default_heap
00000000 l    df *ABS*	00000000 chmemcore.c
0018c554 l     O .bss	00000004 nextmem
0018c558 l     O .bss	00000004 endmem
00000000 l    df *ABS*	00000000 chmempools.c
00000000 l    df *ABS*	00000000 chmtx.c
001835c0 l     F .text	00000094 prio_insert
00183654 l     F .text	00000050 fifo_remove
001836a4 l     F .text	0000004c dequeue
00000000 l    df *ABS*	00000000 chschd.c
00183d2c l     F .text	00000050 fifo_remove
00183d7c l     F .text	0000004c dequeue
00183f88 l     F .text	000000a0 wakeup
00000000 l    df *ABS*	00000000 chsys.c
0018c594 l     O .bss	00000050 mainthread.2342
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
00184608 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
00184740 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0018476c l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
00184bf8 l     F .text	000000e0 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
00184d50 l     F .text	00000050 alt_get_errno
00184da0 l     F .text	000000f0 alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 chregistry.c
00000000 l    df *ABS*	00000000 chcore.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 fputs.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 impure.c
0018a1f8 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
001877c4 l     F .text	00000008 __fp_lock
001877cc l     F .text	00000008 __fp_unlock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 alt_fstat.c
001887e4 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
001888e4 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_lseek.c
001889d8 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
00188b3c l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_sbrk.c
0018aa34 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_write.c
00188d30 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 
001833cc g     F .text	0000005c chPoolInit
00180290 g     F .text	0000007c aud_codec_read_reg
00188668 g     F .text	00000064 _isatty_r
00181204 g     F .text	00000090 alt_main
001805b4 g     F .text	00000024 configure_drvr_bps
001843a4 g     F .text	00000124 chSysTimerHandlerI
00180c64 g     F .text	00000048 chThdExit
00184028 g     F .text	0000009c chSchGoSleepTimeoutS
0018c804 g     O .bss	00000100 alt_irq
001886cc g     F .text	0000006c _lseek_r
0018aa38 g       *ABS*	00000000 __flash_rwdata_start
00180360 g     F .text	0000000c get_i2c_addr
0018378c g     F .text	0000015c chMtxLockS
00182cf4 g     F .text	000000c8 chThdCreateFromMemoryPool
0018055c g     F .text	00000018 disable_dac_drvr
0018ca94 g       *ABS*	00000000 __alt_heap_start
00183948 g     F .text	00000078 chMtxTryLockS
00183044 g     F .text	00000180 chHeapFree
0018837c g     F .text	0000005c __sseek
00187868 g     F .text	0000010c __sinit
00187010 g     F .text	0000013c __swbuf_r
0018c544 g     O .bss	00000002 aud_codec_i2c_bffr
001877e0 g     F .text	00000078 __sfmoreglue
00188b1c g     F .text	00000020 __malloc_unlock
001865ec g     F .text	0000018c memmove
00187858 g     F .text	00000010 _cleanup
0018151c g     F .text	00000044 alt_putstr
00183eec g     F .text	0000009c chSchGoSleepS
00000000  w      *UND*	00000000 __errno
00180000 g     F .entry	0000000c __reset
00180020 g       *ABS*	00000000 __flash_exceptions_start
00188600 g     F .text	00000068 _fstat_r
0018c568 g     O .bss	00000004 errno
00180794 g     F .text	00000168 chThdCreateI
0018c54c g     O .bss	00000004 alt_argv
00192a00 g       *ABS*	00000000 _gp
001840c4 g     F .text	000000b0 chSchWakeupS
00183dc8 g     F .text	00000090 _scheduler_init
00184174 g     F .text	0000004c chSchRescheduleS
001808fc g     F .text	0000008c chThdCreateStatic
0018a078 g     O .rwdata	00000180 alt_fd_list
00180428 g     F .text	000000e4 i2c_xtn_read
0018537c g     F .text	00000090 alt_find_dev
001864ac g     F .text	00000140 memcpy
001877d4 g     F .text	0000000c _cleanup_r
00180350 g     F .text	00000010 configure_i2c_addr
00184cd8 g     F .text	00000078 alt_io_redirect
0018050c g     F .text	00000010 update_acache_mode
00188e70 g       *ABS*	00000000 __DTOR_END__
00180574 g     F .text	00000014 enable_dac_drvr
00183e58 g     F .text	00000094 chSchReadyI
0018532c  w    F .text	00000028 port_halt
00180e08 g     F .text	00000064 _vt_init
0018332c g     F .text	00000074 chCoreAllocI
00181c74 g     F .text	00000218 altera_avalon_jtag_uart_read
00000000  w      *UND*	00000000 malloc
00188934 g     F .text	000000a4 isatty
00182dbc g     F .text	0000005c _heap_init
0018051c g     F .text	00000040 dump_acache_cap_data
0018c574 g     O .bss	00000004 __malloc_top_pad
0018030c g     F .text	00000028 get_i2c_status
00182c3c g     F .text	000000b8 chThdCreateFromHeap
001856d0 g     F .text	000004e4 __sfvwrite_r
00186f20 g     F .text	00000064 _sbrk_r
00188738 g     F .text	0000006c _read_r
001831c4 g     F .text	000000c0 chHeapStatus
0018aa10 g     O .rwdata	00000004 alt_max_fd
001884b0 g     F .text	0000013c _fclose_r
00187794 g     F .text	00000030 fflush
0018c570 g     O .bss	00000004 __malloc_max_sbrked_mem
00180cac g     F .text	000000b8 chThdExitS
00188a28 g     F .text	000000d4 lseek
0018aa24 g     O .rwdata	00000004 _global_impure_ptr
00186924 g     F .text	000005fc _realloc_r
0018ca94 g       *ABS*	00000000 __bss_end
00184b08 g     F .text	000000f0 alt_iic_isr_register
00185100 g     F .text	00000104 alt_tick
001822bc g     F .text	000000a8 altera_avalon_uart_init
00187a80 g     F .text	00000018 __fp_lock_all
00184abc g     F .text	0000004c alt_ic_irq_enabled
00185068 g     F .text	00000098 alt_alarm_stop
0018c55c g     O .bss	00000004 alt_irq_active
00180e6c g     F .text	0000010c chVTSetI
001800ec g     F .exceptions	000000d8 alt_irq_handler
0018a050 g     O .rwdata	00000028 alt_dev_null
00184724 g     F .text	0000001c alt_dcache_flush_all
0018aa38 g       *ABS*	00000000 __ram_rwdata_end
0018aa08 g     O .rwdata	00000008 alt_dev_list
00188d80 g     F .text	000000f0 write
00186778 g     F .text	000000bc _putc_r
001805e4 g     F .text	0000000c configure_drvr_bclk_div
00188f2c g       *ABS*	00000000 __ram_rodata_end
00188834 g     F .text	000000b0 fstat
00180588 g     F .text	00000018 disable_adc_drvr
00183734 g     F .text	00000058 chMtxLock
001833a0 g     F .text	0000002c chCoreStatus
00184238 g     F .text	00000090 chSchDoReschedule
001842f8 g     F .text	000000ac chSysInit
00180b18 g     F .text	0000005c chThdSleep
0018ca94 g       *ABS*	00000000 end
0018036c g     F .text	000000bc i2c_xtn_write
00181000 g     F .text	0000008c chTimeIsWithin
00182908 g     F .text	000001a8 altera_avalon_uart_write
001817b0 g     F .text	000000c0 altera_avalon_jtag_uart_init
00188e70 g       *ABS*	00000000 __CTOR_LIST__
00200000 g       *ABS*	00000000 __alt_stack_pointer
00182124 g     F .text	00000088 alt_avalon_timer_sc_init
0018220c g     F .text	00000060 altera_avalon_uart_write_fd
0018226c g     F .text	00000050 altera_avalon_uart_close_fd
00181e8c g     F .text	00000224 altera_avalon_jtag_uart_write
00187a70 g     F .text	00000004 __sfp_lock_acquire
00186338 g     F .text	000000f8 memchr
00187bec g     F .text	000002d0 _free_r
00181294 g     F .text	00000244 alt_printf
00183428 g     F .text	00000080 chPoolAllocI
0018740c g     F .text	000001a0 __call_exitprocs
001805d8 g     F .text	0000000c configure_drvr_fs_div
0018aa2c g     O .rwdata	00000004 __malloc_sbrk_base
001801c4 g     F .text	0000003c _start
00183284 g     F .text	00000048 _core_init
00183b0c g     F .text	00000120 chMtxUnlockS
0018c560 g     O .bss	00000004 _alt_tick_rate
00185354 g     F .text	00000028 port_time_tick
00180a58 g     F .text	00000060 chThdResume
001838e8 g     F .text	00000060 chMtxTryLock
0018c564 g     O .bss	00000004 _alt_nticks
00188b8c g     F .text	000000f4 read
001815cc g     F .text	00000080 alt_sys_init
001872dc g     F .text	00000130 __register_exitproc
00183c2c g     F .text	00000100 chMtxUnlockAll
001834a8 g     F .text	00000060 chPoolAlloc
00181b18 g     F .text	00000068 altera_avalon_jtag_uart_close
001805f0 g     F .text	00000028 __mulsi3
00188f2c g       *ABS*	00000000 __ram_rwdata_start
00188e70 g       *ABS*	00000000 __ram_rodata_start
0018c5e4 g     O .bss	00000028 __malloc_current_mallinfo
0018c60c g     O .bss	00000010 vtlist
0018164c g     F .text	00000060 altera_avalon_jtag_uart_read_fd
00185520 g     F .text	000000d4 alt_get_fd
001832cc g     F .text	00000060 chCoreAlloc
0018844c g     F .text	00000064 _close_r
00182ea0 g     F .text	000001a4 chHeapAlloc
00182ab0 g     F .text	00000064 chThdAddRef
00186430 g     F .text	0000007c memcmp
0018170c g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0018ca94 g       *ABS*	00000000 __alt_stack_base
0018175c g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
001810a0 g       .text	00000000 port_switch
00187168 g     F .text	00000174 __swsetup_r
00187974 g     F .text	000000fc __sfp
0018a5f8 g     O .rwdata	00000408 __malloc_av_
00187a7c g     F .text	00000004 __sinit_lock_release
001882a0 g     F .text	00000054 __sread
0018540c g     F .text	00000114 alt_find_file
001847bc g     F .text	000000a0 alt_dev_llist_insert
00188afc g     F .text	00000020 __malloc_lock
00188c80 g     F .text	000000b0 sbrk
001875ac g     F .text	000001e8 _fflush_r
0018c544 g       *ABS*	00000000 __bss_start
00180250 g     F .text	00000040 aud_codec_write_reg
00180b74 g     F .text	0000007c chThdSleepUntil
001881c4 g     F .text	000000dc memset
00180200 g     F .text	00000050 main
0018c550 g     O .bss	00000004 alt_envp
0018c56c g     O .bss	00000004 __malloc_max_total_mem
001816ac g     F .text	00000060 altera_avalon_jtag_uart_write_fd
0018c61c g     O .bss	00000020 rlist
00185224 g     F .text	00000070 chRegFirstThread
0018714c g     F .text	0000001c __swbuf
001883d8 g     F .text	00000008 __sclose
00200000 g       *ABS*	00000000 __alt_heap_limit
00180334 g     F .text	00000010 configure_i2c_clk
001885ec g     F .text	00000014 fclose
0018c904 g     O .bss	00000190 _atexit0
00185bb4 g     F .text	00000784 _malloc_r
0018aa14 g     O .rwdata	00000004 alt_errno
00187ebc g     F .text	000000a8 _fwalk
001836f0 g     F .text	00000044 chMtxInit
001842c8 g     F .text	00000030 _idle_thread
00186834 g     F .text	000000f0 putc
00187ab0 g     F .text	0000013c _malloc_trim_r
00188f10 g     O .rodata	00000016 ch_debug
00188e70 g       *ABS*	00000000 __CTOR_END__
00188e70 g       *ABS*	00000000 __flash_rodata_start
00188e70 g       *ABS*	00000000 __DTOR_LIST__
0018108c g       .text	00000000 _port_thread_start
00183508 g     F .text	00000058 chPoolFreeI
00181598 g     F .text	00000034 alt_irq_init
00184fe8 g     F .text	00000080 alt_release_fd
001855f4 g     F .text	00000014 atexit
001883e0 g     F .text	0000006c _write_r
0018aa28 g     O .rwdata	00000004 _impure_ptr
0018c548 g     O .bss	00000004 alt_argc
001848b8 g     F .text	0000005c _do_dtors
00182b14 g     F .text	00000128 chThdRelease
00180020 g       .exceptions	00000000 alt_irq_entry
00180344 g     F .text	0000000c get_i2c_clk
0018c63c g     O .bss	000001c8 _idle_thread_wa
00187a98 g     F .text	00000018 __fp_unlock_all
00183560 g     F .text	00000060 chPoolFree
0018aa00 g     O .rwdata	00000008 alt_fs_list
00180020 g       *ABS*	00000000 __ram_exceptions_start
001839c0 g     F .text	0000014c chMtxUnlock
00184930 g     F .text	00000050 alt_ic_isr_register
0018aa38 g       *ABS*	00000000 _edata
001821ac g     F .text	00000060 altera_avalon_uart_read_fd
0018ca94 g       *ABS*	00000000 _end
001801c4 g       *ABS*	00000000 __ram_exceptions_end
00180f78 g     F .text	00000088 chVTResetI
00181b80 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
00185640 g     F .text	00000074 _fputs_r
00184a1c g     F .text	000000a0 alt_ic_irq_disable
001882f4 g     F .text	00000088 __swrite
0018aa30 g     O .rwdata	00000004 __malloc_trim_threshold
00185204 g     F .text	00000020 altera_nios2_qsys_irq_init
00185608 g     F .text	00000038 exit
00187f64 g     F .text	000000b8 _fwalk_reent
00200000 g       *ABS*	00000000 __alt_data_end
00180020 g     F .exceptions	00000000 alt_exception
00187a74 g     F .text	00000004 __sfp_lock_release
001805a0 g     F .text	00000014 enable_adc_drvr
00180988 g     F .text	000000d0 chThdSetPriority
00180d64 g     F .text	000000a4 chThdWait
00182610 g     F .text	00000054 altera_avalon_uart_close
001841c0 g     F .text	00000078 chSchIsPreemptionRequired
001887a4 g     F .text	00000040 _exit
001844c8 g     F .text	00000140 alt_alarm_start
00180698 g     F .text	000000fc _thread_init
0018801c g     F .text	000001a8 __smakebuf_r
00186f84 g     F .text	0000008c strlen
00184e90 g     F .text	00000158 open
001814d8 g     F .text	00000044 alt_putchar
00180bf0 g     F .text	00000074 chThdYield
00185294 g     F .text	00000098 chRegNextThread
00184914 g     F .text	0000001c alt_icache_flush_all
001856b4 g     F .text	0000001c fputs
0018aa18 g     O .rwdata	00000004 alt_priority_mask
00182e18 g     F .text	00000088 chHeapInit
00184980 g     F .text	0000009c alt_ic_irq_enable
001826b4 g     F .text	00000204 altera_avalon_uart_read
00180000 g       *ABS*	00000000 __alt_mem_sram_cntrlr
0018aa1c g     O .rwdata	00000008 alt_alarm_list
0018485c g     F .text	0000005c _do_ctors
00184658 g     F .text	000000cc close
00180ab8 g     F .text	00000060 chThdTerminate
00181184 g     F .text	00000080 alt_load
00000000  w      *UND*	00000000 free
00187a78 g     F .text	00000004 __sinit_lock_acquire



Disassembly of section .entry:

00180000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  180000:	00400634 	movhi	at,24
    ori r1, r1, %lo(_start)
  180004:	08407114 	ori	at,at,452
    jmp r1
  180008:	0800683a 	jmp	at
	...

Disassembly of section .exceptions:

00180020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
  180020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
  180024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
  180028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  18002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  180030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  180034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  180038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  18003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  180040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
  180044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
  180048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  18004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  180050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  180054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  180058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  18005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  180060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  180064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  180068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  18006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  180070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  180074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  180078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  18007c:	10000326 	beq	r2,zero,18008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  180080:	20000226 	beq	r4,zero,18008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  180084:	01800ec0 	call	1800ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  180088:	00000306 	br	180098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
  18008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
  180090:	e8bfff17 	ldw	r2,-4(ea)

00180094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
  180094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  180098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  18009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  1800a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  1800a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  1800a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  1800ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  1800b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  1800b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  1800b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  1800bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  1800c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
  1800c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  1800c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  1800cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  1800d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  1800d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  1800d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  1800dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  1800e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
  1800e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  1800e8:	ef80083a 	eret

001800ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  1800ec:	defff904 	addi	sp,sp,-28
  1800f0:	dfc00615 	stw	ra,24(sp)
  1800f4:	df000515 	stw	fp,20(sp)
  1800f8:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
  1800fc:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  180100:	0005313a 	rdctl	r2,ipending
  180104:	e0bffe15 	stw	r2,-8(fp)

  return active;
  180108:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
  18010c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
  180110:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
  180114:	00800044 	movi	r2,1
  180118:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  18011c:	e0fffb17 	ldw	r3,-20(fp)
  180120:	e0bffc17 	ldw	r2,-16(fp)
  180124:	1884703a 	and	r2,r3,r2
  180128:	10001726 	beq	r2,zero,180188 <alt_irq_handler+0x9c>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  18012c:	00c00674 	movhi	r3,25
  180130:	18f20104 	addi	r3,r3,-14332
  180134:	e0bffd17 	ldw	r2,-12(fp)
  180138:	100490fa 	slli	r2,r2,3
  18013c:	1885883a 	add	r2,r3,r2
  180140:	10c00017 	ldw	r3,0(r2)
  180144:	01000674 	movhi	r4,25
  180148:	21320104 	addi	r4,r4,-14332
  18014c:	e0bffd17 	ldw	r2,-12(fp)
  180150:	100490fa 	slli	r2,r2,3
  180154:	2085883a 	add	r2,r4,r2
  180158:	10800104 	addi	r2,r2,4
  18015c:	10800017 	ldw	r2,0(r2)
  180160:	1009883a 	mov	r4,r2
  180164:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
  180168:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  18016c:	0005313a 	rdctl	r2,ipending
  180170:	e0bfff15 	stw	r2,-4(fp)

  return active;
  180174:	e0bfff17 	ldw	r2,-4(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
  180178:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
  18017c:	e0bffb17 	ldw	r2,-20(fp)
  180180:	103fe31e 	bne	r2,zero,180110 <alt_irq_handler+0x24>
  180184:	00000706 	br	1801a4 <alt_irq_handler+0xb8>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
  180188:	e0bffc17 	ldw	r2,-16(fp)
  18018c:	1085883a 	add	r2,r2,r2
  180190:	e0bffc15 	stw	r2,-16(fp)
      i++;
  180194:	e0bffd17 	ldw	r2,-12(fp)
  180198:	10800044 	addi	r2,r2,1
  18019c:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
  1801a0:	003fde06 	br	18011c <alt_irq_handler+0x30>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
  1801a4:	01841c00 	call	1841c0 <chSchIsPreemptionRequired>
  1801a8:	10000126 	beq	r2,zero,1801b0 <alt_irq_handler+0xc4>
  1801ac:	01842380 	call	184238 <chSchDoReschedule>
}
  1801b0:	e037883a 	mov	sp,fp
  1801b4:	dfc00117 	ldw	ra,4(sp)
  1801b8:	df000017 	ldw	fp,0(sp)
  1801bc:	dec00204 	addi	sp,sp,8
  1801c0:	f800283a 	ret

Disassembly of section .text:

001801c4 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  1801c4:	06c00834 	movhi	sp,32
    ori sp, sp, %lo(__alt_stack_pointer)
  1801c8:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
  1801cc:	06800674 	movhi	gp,25
    ori gp, gp, %lo(_gp)
  1801d0:	d68a8014 	ori	gp,gp,10752
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  1801d4:	00800634 	movhi	r2,24
    ori r2, r2, %lo(__bss_start)
  1801d8:	10b15114 	ori	r2,r2,50500

    movhi r3, %hi(__bss_end)
  1801dc:	00c00634 	movhi	r3,24
    ori r3, r3, %lo(__bss_end)
  1801e0:	18f2a514 	ori	r3,r3,51860

    beq r2, r3, 1f
  1801e4:	10c00326 	beq	r2,r3,1801f4 <_start+0x30>

0:
    stw zero, (r2)
  1801e8:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  1801ec:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  1801f0:	10fffd36 	bltu	r2,r3,1801e8 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  1801f4:	01811840 	call	181184 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  1801f8:	01812040 	call	181204 <alt_main>

001801fc <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  1801fc:	003fff06 	br	1801fc <alt_after_alt_main>

00180200 <main>:
#include "sys/alt_stdio.h"
#include "ledos/ledos.h"
#include "ch.h"

int main()
{ 
  180200:	deffff04 	addi	sp,sp,-4
  alt_putstr("Hello from Nios II!\n");
  180204:	01000674 	movhi	r4,25
  180208:	21239c04 	addi	r4,r4,-29072
#include "sys/alt_stdio.h"
#include "ledos/ledos.h"
#include "ch.h"

int main()
{ 
  18020c:	dfc00015 	stw	ra,0(sp)
  alt_putstr("Hello from Nios II!\n");
  180210:	018151c0 	call	18151c <alt_putstr>


  IOWR_I2C_ADDR(0x34);
  180214:	0005883a 	mov	r2,zero
  180218:	00c00d04 	movi	r3,52
  18021c:	10c00035 	stwio	r3,0(r2)
  alt_printf("0x%x\n",IORD_I2C_ADDR);
  180220:	11400037 	ldwio	r5,0(r2)
  180224:	01000674 	movhi	r4,25
  180228:	2123a204 	addi	r4,r4,-29048
  18022c:	01812940 	call	181294 <alt_printf>
  IOWR_I2C_CLK_DIV(2);
  180230:	00800404 	movi	r2,16
  180234:	00c00084 	movi	r3,2
  180238:	10c00035 	stwio	r3,0(r2)
  alt_printf("0x%x\n",IORD_I2C_CLK_DIV);
  18023c:	11400037 	ldwio	r5,0(r2)
  180240:	01000674 	movhi	r4,25
  180244:	2123a204 	addi	r4,r4,-29048
  180248:	01812940 	call	181294 <alt_printf>
  18024c:	003fff06 	br	18024c <main+0x4c>

00180250 <aud_codec_write_reg>:
#include "alt_types.h"
#include "sys/alt_stdio.h"
#include "ch.h"


I2C_RES	aud_codec_write_reg(alt_u8 addr, alt_u16 val)	{
  180250:	defffe04 	addi	sp,sp,-8
  180254:	dfc00115 	stw	ra,4(sp)
	aud_codec_i2c_bffr.byte_arry[0]	=	val & 0xff;
  180258:	d0a6d104 	addi	r2,gp,-25788
  18025c:	11400005 	stb	r5,0(r2)
	aud_codec_i2c_bffr.byte_arry[1]	=	((addr & AUD_CODEC_ADDR_MSK) << AUD_CODEC_ADDR_OFFSET) + ((val & 0x100) >> 8);
  180260:	2940400c 	andi	r5,r5,256
  180264:	280ad23a 	srli	r5,r5,8

	return i2c_xtn_write(AUD_CODEC_I2C_WRITE_ADDR,aud_codec_i2c_bffr.byte_arry,2,1,1);
  180268:	01c00044 	movi	r7,1
  18026c:	01000d04 	movi	r4,52
#include "ch.h"


I2C_RES	aud_codec_write_reg(alt_u8 addr, alt_u16 val)	{
	aud_codec_i2c_bffr.byte_arry[0]	=	val & 0xff;
	aud_codec_i2c_bffr.byte_arry[1]	=	((addr & AUD_CODEC_ADDR_MSK) << AUD_CODEC_ADDR_OFFSET) + ((val & 0x100) >> 8);
  180270:	11400045 	stb	r5,1(r2)

	return i2c_xtn_write(AUD_CODEC_I2C_WRITE_ADDR,aud_codec_i2c_bffr.byte_arry,2,1,1);
  180274:	d9c00015 	stw	r7,0(sp)
  180278:	100b883a 	mov	r5,r2
  18027c:	01800084 	movi	r6,2
  180280:	018036c0 	call	18036c <i2c_xtn_write>
}
  180284:	dfc00117 	ldw	ra,4(sp)
  180288:	dec00204 	addi	sp,sp,8
  18028c:	f800283a 	ret

00180290 <aud_codec_read_reg>:

I2C_RES	aud_codec_read_reg(alt_u8 addr, alt_u16 *val)	{
  180290:	defffd04 	addi	sp,sp,-12
	aud_codec_i2c_bffr.byte_arry[0]	=	(addr & AUD_CODEC_ADDR_MSK) << 1;
  180294:	21003fcc 	andi	r4,r4,255
	aud_codec_i2c_bffr.byte_arry[1]	=	((addr & AUD_CODEC_ADDR_MSK) << AUD_CODEC_ADDR_OFFSET) + ((val & 0x100) >> 8);

	return i2c_xtn_write(AUD_CODEC_I2C_WRITE_ADDR,aud_codec_i2c_bffr.byte_arry,2,1,1);
}

I2C_RES	aud_codec_read_reg(alt_u8 addr, alt_u16 *val)	{
  180298:	dc000115 	stw	r16,4(sp)
	aud_codec_i2c_bffr.byte_arry[0]	=	(addr & AUD_CODEC_ADDR_MSK) << 1;
  18029c:	2109883a 	add	r4,r4,r4

	if(i2c_xtn_write(AUD_CODEC_I2C_WRITE_ADDR,aud_codec_i2c_bffr.byte_arry,1,1,0))	{
  1802a0:	04000044 	movi	r16,1

	return i2c_xtn_write(AUD_CODEC_I2C_WRITE_ADDR,aud_codec_i2c_bffr.byte_arry,2,1,1);
}

I2C_RES	aud_codec_read_reg(alt_u8 addr, alt_u16 *val)	{
	aud_codec_i2c_bffr.byte_arry[0]	=	(addr & AUD_CODEC_ADDR_MSK) << 1;
  1802a4:	d126d105 	stb	r4,-25788(gp)

	if(i2c_xtn_write(AUD_CODEC_I2C_WRITE_ADDR,aud_codec_i2c_bffr.byte_arry,1,1,0))	{
  1802a8:	d8000015 	stw	zero,0(sp)
  1802ac:	01000d04 	movi	r4,52
  1802b0:	d166d104 	addi	r5,gp,-25788
  1802b4:	800d883a 	mov	r6,r16
  1802b8:	800f883a 	mov	r7,r16
	aud_codec_i2c_bffr.byte_arry[1]	=	((addr & AUD_CODEC_ADDR_MSK) << AUD_CODEC_ADDR_OFFSET) + ((val & 0x100) >> 8);

	return i2c_xtn_write(AUD_CODEC_I2C_WRITE_ADDR,aud_codec_i2c_bffr.byte_arry,2,1,1);
}

I2C_RES	aud_codec_read_reg(alt_u8 addr, alt_u16 *val)	{
  1802bc:	dfc00215 	stw	ra,8(sp)
	aud_codec_i2c_bffr.byte_arry[0]	=	(addr & AUD_CODEC_ADDR_MSK) << 1;

	if(i2c_xtn_write(AUD_CODEC_I2C_WRITE_ADDR,aud_codec_i2c_bffr.byte_arry,1,1,0))	{
  1802c0:	018036c0 	call	18036c <i2c_xtn_write>
  1802c4:	10000226 	beq	r2,zero,1802d0 <aud_codec_read_reg+0x40>
		return I2C_ERROR;
  1802c8:	00800104 	movi	r2,4
  1802cc:	00000b06 	br	1802fc <aud_codec_read_reg+0x6c>
	}

	if(i2c_xtn_read(AUD_CODEC_I2C_READ_ADDR,aud_codec_i2c_bffr.byte_arry,2,1,1))	{
  1802d0:	dc000015 	stw	r16,0(sp)
  1802d4:	01000d44 	movi	r4,53
  1802d8:	d166d104 	addi	r5,gp,-25788
  1802dc:	01800084 	movi	r6,2
  1802e0:	800f883a 	mov	r7,r16
  1802e4:	01804280 	call	180428 <i2c_xtn_read>
  1802e8:	103ff71e 	bne	r2,zero,1802c8 <aud_codec_read_reg+0x38>
		return I2C_ERROR;
	}

	aud_codec_i2c_bffr.val	=	aud_codec_i2c_bffr.val	&	AUD_CODEC_DATA_MSK;
  1802ec:	d0a6d10b 	ldhu	r2,-25788(gp)
  1802f0:	10807fcc 	andi	r2,r2,511
  1802f4:	d0a6d10d 	sth	r2,-25788(gp)

	return I2C_OK;
  1802f8:	0005883a 	mov	r2,zero
}
  1802fc:	dfc00217 	ldw	ra,8(sp)
  180300:	dc000117 	ldw	r16,4(sp)
  180304:	dec00304 	addi	sp,sp,12
  180308:	f800283a 	ret

0018030c <get_i2c_status>:


I2C_RES	get_i2c_status()	{
	alt_u32 status;

	status = IORD_I2C_STATUS;
  18030c:	00800c04 	movi	r2,48
  180310:	10800037 	ldwio	r2,0(r2)

	if(status & I2C_NACK_DET_MSK)
  180314:	10c0008c 	andi	r3,r2,2
  180318:	1800041e 	bne	r3,zero,18032c <get_i2c_status+0x20>
		return I2C_NACK_DETECTED;
	else if(status & I2C_BUSY_MSK)
  18031c:	1080004c 	andi	r2,r2,1
		return I2C_BUSY;
  180320:	1005003a 	cmpeq	r2,r2,zero
  180324:	10800084 	addi	r2,r2,2
  180328:	f800283a 	ret
	alt_u32 status;

	status = IORD_I2C_STATUS;

	if(status & I2C_NACK_DET_MSK)
		return I2C_NACK_DETECTED;
  18032c:	00800044 	movi	r2,1
	else if(status & I2C_BUSY_MSK)
		return I2C_BUSY;
	else
		return I2C_IDLE;
}
  180330:	f800283a 	ret

00180334 <configure_i2c_clk>:

void 	configure_i2c_clk(alt_u8 clk_val)	{
	IOWR_I2C_CLK_DIV(clk_val & I2C_CLK_DIV_MSK);
  180334:	21003fcc 	andi	r4,r4,255
  180338:	00800404 	movi	r2,16
  18033c:	11000035 	stwio	r4,0(r2)
  180340:	f800283a 	ret

00180344 <get_i2c_clk>:
}

alt_u8 	get_i2c_clk()	{
	return IORD_I2C_CLK_DIV & I2C_CLK_DIV_MSK;
}
  180344:	00800404 	movi	r2,16
  180348:	10800037 	ldwio	r2,0(r2)
  18034c:	f800283a 	ret

00180350 <configure_i2c_addr>:

void 	configure_i2c_addr(alt_u8 addr_val)	{
	IOWR_I2C_ADDR(addr_val & I2C_ADDR_MSK);
  180350:	21003fcc 	andi	r4,r4,255
  180354:	0005883a 	mov	r2,zero
  180358:	11000035 	stwio	r4,0(r2)
  18035c:	f800283a 	ret

00180360 <get_i2c_addr>:
}

alt_u8 	get_i2c_addr()	{
	return	IORD_I2C_ADDR & I2C_ADDR_MSK;
}
  180360:	0005883a 	mov	r2,zero
  180364:	10800037 	ldwio	r2,0(r2)
  180368:	f800283a 	ret

0018036c <i2c_xtn_write>:

I2C_RES	i2c_xtn_write(alt_u8 addr, alt_u8 *data, alt_u8 num_bytes, alt_u8 start, alt_u8 stop)	{
  18036c:	defffe04 	addi	sp,sp,-8
  180370:	dc000015 	stw	r16,0(sp)
  180374:	dfc00115 	stw	ra,4(sp)
	alt_u32 i;

	if(num_bytes > I2C_MAX_XTN_LEN)	{
  180378:	31803fcc 	andi	r6,r6,255
  18037c:	04000104 	movi	r16,4

alt_u8 	get_i2c_addr()	{
	return	IORD_I2C_ADDR & I2C_ADDR_MSK;
}

I2C_RES	i2c_xtn_write(alt_u8 addr, alt_u8 *data, alt_u8 num_bytes, alt_u8 start, alt_u8 stop)	{
  180380:	d8c00217 	ldw	r3,8(sp)
	alt_u32 i;

	if(num_bytes > I2C_MAX_XTN_LEN)	{
  180384:	8180072e 	bgeu	r16,r6,1803a4 <i2c_xtn_write+0x38>
		alt_printf("[i2c_xtn_write] ERROR num_bytes(0x%x) > I2C_MAX_XTN_LEN(0x%x)\n",num_bytes,I2C_MAX_XTN_LEN);
  180388:	300b883a 	mov	r5,r6
  18038c:	01000674 	movhi	r4,25
  180390:	2123a404 	addi	r4,r4,-29040
  180394:	800d883a 	mov	r6,r16
  180398:	01812940 	call	181294 <alt_printf>
		return I2C_ERROR;
  18039c:	8005883a 	mov	r2,r16
  1803a0:	00001d06 	br	180418 <i2c_xtn_write+0xac>
alt_u8 	get_i2c_clk()	{
	return IORD_I2C_CLK_DIV & I2C_CLK_DIV_MSK;
}

void 	configure_i2c_addr(alt_u8 addr_val)	{
	IOWR_I2C_ADDR(addr_val & I2C_ADDR_MSK);
  1803a4:	21003fcc 	andi	r4,r4,255
  1803a8:	0005883a 	mov	r2,zero
  1803ac:	11000035 	stwio	r4,0(r2)
		return I2C_ERROR;
	}

	configure_i2c_addr(addr);

	for(i=0; i<num_bytes;i++)	{
  1803b0:	00000406 	br	1803c4 <i2c_xtn_write+0x58>

alt_u8 	get_i2c_addr()	{
	return	IORD_I2C_ADDR & I2C_ADDR_MSK;
}

I2C_RES	i2c_xtn_write(alt_u8 addr, alt_u8 *data, alt_u8 num_bytes, alt_u8 start, alt_u8 stop)	{
  1803b4:	2889883a 	add	r4,r5,r2
	}

	configure_i2c_addr(addr);

	for(i=0; i<num_bytes;i++)	{
		IOWR_I2C_DATA_CACHE(i,data[i]);
  1803b8:	21000003 	ldbu	r4,0(r4)
  1803bc:	11001435 	stwio	r4,80(r2)
		return I2C_ERROR;
	}

	configure_i2c_addr(addr);

	for(i=0; i<num_bytes;i++)	{
  1803c0:	10800044 	addi	r2,r2,1
  1803c4:	11bffb36 	bltu	r2,r6,1803b4 <i2c_xtn_write+0x48>
		IOWR_I2C_DATA_CACHE(i,data[i]);
	}

	IOWR_I2C_CONFIG((num_bytes << I2C_NUM_BYTES_OFFSET) + I2C_INIT_MSK + ((stop & 0x1) << 1) + (start & 0x1));
  1803c8:	300c923a 	slli	r6,r6,8
  1803cc:	1880004c 	andi	r2,r3,1
  1803d0:	1085883a 	add	r2,r2,r2
  1803d4:	31800104 	addi	r6,r6,4
  1803d8:	3085883a 	add	r2,r6,r2
  1803dc:	39c0004c 	andi	r7,r7,1
  1803e0:	11cf883a 	add	r7,r2,r7
  1803e4:	00c00804 	movi	r3,32
  1803e8:	19c00035 	stwio	r7,0(r3)

	while(IORD_I2C_STATUS & I2C_BUSY_MSK){
  1803ec:	04000c04 	movi	r16,48
  1803f0:	00000206 	br	1803fc <i2c_xtn_write+0x90>
		chThdSleepMilliseconds(1);	//wait for I2C driver to be free
  1803f4:	01000044 	movi	r4,1
  1803f8:	0180b180 	call	180b18 <chThdSleep>
		IOWR_I2C_DATA_CACHE(i,data[i]);
	}

	IOWR_I2C_CONFIG((num_bytes << I2C_NUM_BYTES_OFFSET) + I2C_INIT_MSK + ((stop & 0x1) << 1) + (start & 0x1));

	while(IORD_I2C_STATUS & I2C_BUSY_MSK){
  1803fc:	80800037 	ldwio	r2,0(r16)
  180400:	1080004c 	andi	r2,r2,1
  180404:	103ffb1e 	bne	r2,zero,1803f4 <i2c_xtn_write+0x88>
		chThdSleepMilliseconds(1);	//wait for I2C driver to be free
	}

	if(IORD_I2C_STATUS	&	I2C_NACK_DET_MSK){
  180408:	00800c04 	movi	r2,48
  18040c:	10800037 	ldwio	r2,0(r2)
  180410:	1004d07a 	srli	r2,r2,1
  180414:	1080004c 	andi	r2,r2,1
		return I2C_NACK_DETECTED;
	}

	return I2C_OK;
}
  180418:	dfc00117 	ldw	ra,4(sp)
  18041c:	dc000017 	ldw	r16,0(sp)
  180420:	dec00204 	addi	sp,sp,8
  180424:	f800283a 	ret

00180428 <i2c_xtn_read>:


I2C_RES	i2c_xtn_read(alt_u8 addr, alt_u8 *bffr, alt_u8 num_bytes, alt_u8 start, alt_u8 stop)	{
  180428:	defffc04 	addi	sp,sp,-16
  18042c:	dc800215 	stw	r18,8(sp)
  180430:	dc400115 	stw	r17,4(sp)
  180434:	dc000015 	stw	r16,0(sp)
  180438:	dfc00315 	stw	ra,12(sp)
	alt_u32 i;

	if(num_bytes > I2C_MAX_XTN_LEN)	{
  18043c:	30803fcc 	andi	r2,r6,255
  180440:	04000104 	movi	r16,4

	return I2C_OK;
}


I2C_RES	i2c_xtn_read(alt_u8 addr, alt_u8 *bffr, alt_u8 num_bytes, alt_u8 start, alt_u8 stop)	{
  180444:	2825883a 	mov	r18,r5
  180448:	d8c00417 	ldw	r3,16(sp)
  18044c:	3023883a 	mov	r17,r6
	alt_u32 i;

	if(num_bytes > I2C_MAX_XTN_LEN)	{
  180450:	8080072e 	bgeu	r16,r2,180470 <i2c_xtn_read+0x48>
		alt_printf("[i2c_xtn_write] ERROR num_bytes(0x%x) > I2C_MAX_XTN_LEN(0x%x)\n",num_bytes,I2C_MAX_XTN_LEN);
  180454:	100b883a 	mov	r5,r2
  180458:	01000674 	movhi	r4,25
  18045c:	2123a404 	addi	r4,r4,-29040
  180460:	800d883a 	mov	r6,r16
  180464:	01812940 	call	181294 <alt_printf>
		return I2C_ERROR;
  180468:	8005883a 	mov	r2,r16
  18046c:	00002106 	br	1804f4 <i2c_xtn_read+0xcc>
alt_u8 	get_i2c_clk()	{
	return IORD_I2C_CLK_DIV & I2C_CLK_DIV_MSK;
}

void 	configure_i2c_addr(alt_u8 addr_val)	{
	IOWR_I2C_ADDR(addr_val & I2C_ADDR_MSK);
  180470:	21003fcc 	andi	r4,r4,255
  180474:	000b883a 	mov	r5,zero
  180478:	29000035 	stwio	r4,0(r5)
		return I2C_ERROR;
	}

	configure_i2c_addr(addr);

	IOWR_I2C_CONFIG((num_bytes << I2C_NUM_BYTES_OFFSET) + I2C_RD_N_WR_MSK + I2C_INIT_MSK + ((stop & 0x1) << 1) + (start & 0x1));
  18047c:	1004923a 	slli	r2,r2,8
  180480:	18c0004c 	andi	r3,r3,1
  180484:	18c7883a 	add	r3,r3,r3
  180488:	10800304 	addi	r2,r2,12
  18048c:	10c7883a 	add	r3,r2,r3
  180490:	39c0004c 	andi	r7,r7,1
  180494:	19cf883a 	add	r7,r3,r7
  180498:	01000804 	movi	r4,32
  18049c:	21c00035 	stwio	r7,0(r4)

	while(IORD_I2C_STATUS & I2C_BUSY_MSK){
  1804a0:	04000c04 	movi	r16,48
  1804a4:	00000206 	br	1804b0 <i2c_xtn_read+0x88>
		chThdSleepMilliseconds(1);	//wait for I2C driver to be free
  1804a8:	01000044 	movi	r4,1
  1804ac:	0180b180 	call	180b18 <chThdSleep>

	configure_i2c_addr(addr);

	IOWR_I2C_CONFIG((num_bytes << I2C_NUM_BYTES_OFFSET) + I2C_RD_N_WR_MSK + I2C_INIT_MSK + ((stop & 0x1) << 1) + (start & 0x1));

	while(IORD_I2C_STATUS & I2C_BUSY_MSK){
  1804b0:	80800037 	ldwio	r2,0(r16)
  1804b4:	1080004c 	andi	r2,r2,1
  1804b8:	103ffb1e 	bne	r2,zero,1804a8 <i2c_xtn_read+0x80>
		chThdSleepMilliseconds(1);	//wait for I2C driver to be free
	}

	if(IORD_I2C_STATUS	&	I2C_NACK_DET_MSK){
  1804bc:	00800c04 	movi	r2,48
  1804c0:	10800037 	ldwio	r2,0(r2)
  1804c4:	1080008c 	andi	r2,r2,2
  1804c8:	1000091e 	bne	r2,zero,1804f0 <i2c_xtn_read+0xc8>
		return I2C_NACK_DETECTED;
	}

	for(i=0; i<num_bytes;i++)	{
  1804cc:	8c403fcc 	andi	r17,r17,255
  1804d0:	00000406 	br	1804e4 <i2c_xtn_read+0xbc>
		bffr[i]	=	IORD_I2C_DATA_CACHE(i)	&	0xff;
  1804d4:	11001437 	ldwio	r4,80(r2)

	return I2C_OK;
}


I2C_RES	i2c_xtn_read(alt_u8 addr, alt_u8 *bffr, alt_u8 num_bytes, alt_u8 start, alt_u8 stop)	{
  1804d8:	9087883a 	add	r3,r18,r2
	if(IORD_I2C_STATUS	&	I2C_NACK_DET_MSK){
		return I2C_NACK_DETECTED;
	}

	for(i=0; i<num_bytes;i++)	{
		bffr[i]	=	IORD_I2C_DATA_CACHE(i)	&	0xff;
  1804dc:	19000005 	stb	r4,0(r3)

	if(IORD_I2C_STATUS	&	I2C_NACK_DET_MSK){
		return I2C_NACK_DETECTED;
	}

	for(i=0; i<num_bytes;i++)	{
  1804e0:	10800044 	addi	r2,r2,1
  1804e4:	147ffb36 	bltu	r2,r17,1804d4 <i2c_xtn_read+0xac>
		bffr[i]	=	IORD_I2C_DATA_CACHE(i)	&	0xff;
	}

	return I2C_OK;
  1804e8:	0005883a 	mov	r2,zero
  1804ec:	00000106 	br	1804f4 <i2c_xtn_read+0xcc>
	while(IORD_I2C_STATUS & I2C_BUSY_MSK){
		chThdSleepMilliseconds(1);	//wait for I2C driver to be free
	}

	if(IORD_I2C_STATUS	&	I2C_NACK_DET_MSK){
		return I2C_NACK_DETECTED;
  1804f0:	00800044 	movi	r2,1
	for(i=0; i<num_bytes;i++)	{
		bffr[i]	=	IORD_I2C_DATA_CACHE(i)	&	0xff;
	}

	return I2C_OK;
}
  1804f4:	dfc00317 	ldw	ra,12(sp)
  1804f8:	dc800217 	ldw	r18,8(sp)
  1804fc:	dc400117 	ldw	r17,4(sp)
  180500:	dc000017 	ldw	r16,0(sp)
  180504:	dec00404 	addi	sp,sp,16
  180508:	f800283a 	ret

0018050c <update_acache_mode>:
#include "alt_types.h"
#include "sys/alt_stdio.h"


void update_acache_mode(PCM_BFFR_MODE_T mode)	{
	IOWR_PCM_BFFR_CONTROL(mode & PCM_BFFR_MODE_MSK);
  18050c:	2100004c 	andi	r4,r4,1
  180510:	00880004 	movi	r2,8192
  180514:	11000035 	stwio	r4,0(r2)
  180518:	f800283a 	ret

0018051c <dump_acache_cap_data>:
}

void dump_acache_cap_data(alt_u32 *lbffr, alt_u32 *rbffr)	{
	alt_u32	i;

	for(i=0; i<PCM_BFFR_NUM_SAMPLES; i++)	{
  18051c:	0005883a 	mov	r2,zero
		IOWR_PCM_BFFR_CAP_ADDR(i);
  180520:	01880804 	movi	r6,8224
		lbffr[i]	=	IORD_PCM_BFFR_CAP_DATA;
  180524:	00c80c04 	movi	r3,8240
}

void dump_acache_cap_data(alt_u32 *lbffr, alt_u32 *rbffr)	{
	alt_u32	i;

	for(i=0; i<PCM_BFFR_NUM_SAMPLES; i++)	{
  180528:	01c02004 	movi	r7,128
		IOWR_PCM_BFFR_CAP_ADDR(i);
  18052c:	30800035 	stwio	r2,0(r6)
		lbffr[i]	=	IORD_PCM_BFFR_CAP_DATA;
  180530:	1a000037 	ldwio	r8,0(r3)
  180534:	22000015 	stw	r8,0(r4)

void update_acache_mode(PCM_BFFR_MODE_T mode)	{
	IOWR_PCM_BFFR_CONTROL(mode & PCM_BFFR_MODE_MSK);
}

void dump_acache_cap_data(alt_u32 *lbffr, alt_u32 *rbffr)	{
  180538:	12002004 	addi	r8,r2,128

	for(i=0; i<PCM_BFFR_NUM_SAMPLES; i++)	{
		IOWR_PCM_BFFR_CAP_ADDR(i);
		lbffr[i]	=	IORD_PCM_BFFR_CAP_DATA;

		IOWR_PCM_BFFR_CAP_ADDR(i+PCM_BFFR_NUM_SAMPLES);
  18053c:	32000035 	stwio	r8,0(r6)
		rbffr[i]	=	IORD_PCM_BFFR_CAP_DATA;
  180540:	1a000037 	ldwio	r8,0(r3)
  180544:	2a000015 	stw	r8,0(r5)
}

void dump_acache_cap_data(alt_u32 *lbffr, alt_u32 *rbffr)	{
	alt_u32	i;

	for(i=0; i<PCM_BFFR_NUM_SAMPLES; i++)	{
  180548:	10800044 	addi	r2,r2,1
  18054c:	21000104 	addi	r4,r4,4
  180550:	29400104 	addi	r5,r5,4
  180554:	11fff51e 	bne	r2,r7,18052c <dump_acache_cap_data+0x10>
		lbffr[i]	=	IORD_PCM_BFFR_CAP_DATA;

		IOWR_PCM_BFFR_CAP_ADDR(i+PCM_BFFR_NUM_SAMPLES);
		rbffr[i]	=	IORD_PCM_BFFR_CAP_DATA;
	}
}
  180558:	f800283a 	ret

0018055c <disable_dac_drvr>:
#include "alt_types.h"
#include "sys/alt_stdio.h"


void disable_dac_drvr()	{
	IOWR_SSM2603_DRVR_CONFIG(IORD_SSM2603_DRVR_CONFIG	&	~SSM2603_DRVR_DAC_EN_MSK);
  18055c:	00840004 	movi	r2,4096
  180560:	11000037 	ldwio	r4,0(r2)
  180564:	00ffff84 	movi	r3,-2
  180568:	20c6703a 	and	r3,r4,r3
  18056c:	10c00035 	stwio	r3,0(r2)
  180570:	f800283a 	ret

00180574 <enable_dac_drvr>:
}

void enable_dac_drvr()	{
	IOWR_SSM2603_DRVR_CONFIG(IORD_SSM2603_DRVR_CONFIG	|	SSM2603_DRVR_DAC_EN_MSK);
  180574:	00840004 	movi	r2,4096
  180578:	10c00037 	ldwio	r3,0(r2)
  18057c:	18c00054 	ori	r3,r3,1
  180580:	10c00035 	stwio	r3,0(r2)
  180584:	f800283a 	ret

00180588 <disable_adc_drvr>:
}

void disable_adc_drvr()	{
	IOWR_SSM2603_DRVR_CONFIG(IORD_SSM2603_DRVR_CONFIG	&	~SSM2603_DRVR_ADC_EN_MSK);
  180588:	00840004 	movi	r2,4096
  18058c:	11000037 	ldwio	r4,0(r2)
  180590:	00ffff44 	movi	r3,-3
  180594:	20c6703a 	and	r3,r4,r3
  180598:	10c00035 	stwio	r3,0(r2)
  18059c:	f800283a 	ret

001805a0 <enable_adc_drvr>:
}

void enable_adc_drvr()	{
	IOWR_SSM2603_DRVR_CONFIG(IORD_SSM2603_DRVR_CONFIG	|	SSM2603_DRVR_ADC_EN_MSK);
  1805a0:	00840004 	movi	r2,4096
  1805a4:	10c00037 	ldwio	r3,0(r2)
  1805a8:	18c00094 	ori	r3,r3,2
  1805ac:	10c00035 	stwio	r3,0(r2)
  1805b0:	f800283a 	ret

001805b4 <configure_drvr_bps>:
}

void configure_drvr_bps(BPS_T val)	{
	IOWR_SSM2603_DRVR_CONFIG((IORD_SSM2603_DRVR_CONFIG & ~SSM2603_DRVR_BPS_MSK) | (val << SSM2603_DRVR_BPS_OFFSET));
  1805b4:	00840004 	movi	r2,4096
  1805b8:	11400037 	ldwio	r5,0(r2)
  1805bc:	00fffcc4 	movi	r3,-13
  1805c0:	2109883a 	add	r4,r4,r4
  1805c4:	28c6703a 	and	r3,r5,r3
  1805c8:	2109883a 	add	r4,r4,r4
  1805cc:	1908b03a 	or	r4,r3,r4
  1805d0:	11000035 	stwio	r4,0(r2)
  1805d4:	f800283a 	ret

001805d8 <configure_drvr_fs_div>:
}

void configure_drvr_fs_div(FS_DIV_T val)	{
	IOWR_SSM2603_DRVR_FS_VAL(val);
  1805d8:	00840c04 	movi	r2,4144
  1805dc:	11000035 	stwio	r4,0(r2)
  1805e0:	f800283a 	ret

001805e4 <configure_drvr_bclk_div>:
}

void configure_drvr_bclk_div(BCLK_DIV_T val)	{
	IOWR_SSM2603_DRVR_BCLK_DIV(val);
  1805e4:	00840804 	movi	r2,4128
  1805e8:	11000035 	stwio	r4,0(r2)
  1805ec:	f800283a 	ret

001805f0 <__mulsi3>:
  1805f0:	0005883a 	mov	r2,zero
  1805f4:	20000726 	beq	r4,zero,180614 <__mulsi3+0x24>
  1805f8:	20c0004c 	andi	r3,r4,1
  1805fc:	2008d07a 	srli	r4,r4,1
  180600:	18000126 	beq	r3,zero,180608 <__mulsi3+0x18>
  180604:	1145883a 	add	r2,r2,r5
  180608:	294b883a 	add	r5,r5,r5
  18060c:	203ffa1e 	bne	r4,zero,1805f8 <__mulsi3+0x8>
  180610:	f800283a 	ret
  180614:	f800283a 	ret

00180618 <list_insert>:
  tp->p_prev->p_next = tp->p_next;
  tp->p_next->p_prev = tp->p_prev;
  return tp;
}

static INLINE void list_insert(Thread *tp, ThreadsList *tlp) {
  180618:	defffd04 	addi	sp,sp,-12
  18061c:	df000215 	stw	fp,8(sp)
  180620:	df000204 	addi	fp,sp,8
  180624:	e13ffe15 	stw	r4,-8(fp)
  180628:	e17fff15 	stw	r5,-4(fp)

  tp->p_next = tlp->p_next;
  18062c:	e0bfff17 	ldw	r2,-4(fp)
  180630:	10c00017 	ldw	r3,0(r2)
  180634:	e0bffe17 	ldw	r2,-8(fp)
  180638:	10c00015 	stw	r3,0(r2)
  tlp->p_next = tp;
  18063c:	e0bfff17 	ldw	r2,-4(fp)
  180640:	e0fffe17 	ldw	r3,-8(fp)
  180644:	10c00015 	stw	r3,0(r2)
}
  180648:	e037883a 	mov	sp,fp
  18064c:	df000017 	ldw	fp,0(sp)
  180650:	dec00104 	addi	sp,sp,4
  180654:	f800283a 	ret

00180658 <list_remove>:

static INLINE Thread *list_remove(ThreadsList *tlp) {
  180658:	defffd04 	addi	sp,sp,-12
  18065c:	df000215 	stw	fp,8(sp)
  180660:	df000204 	addi	fp,sp,8
  180664:	e13fff15 	stw	r4,-4(fp)

  Thread *tp = tlp->p_next;
  180668:	e0bfff17 	ldw	r2,-4(fp)
  18066c:	10800017 	ldw	r2,0(r2)
  180670:	e0bffe15 	stw	r2,-8(fp)
  tlp->p_next = tp->p_next;
  180674:	e0bffe17 	ldw	r2,-8(fp)
  180678:	10c00017 	ldw	r3,0(r2)
  18067c:	e0bfff17 	ldw	r2,-4(fp)
  180680:	10c00015 	stw	r3,0(r2)
  return tp;
  180684:	e0bffe17 	ldw	r2,-8(fp)
}
  180688:	e037883a 	mov	sp,fp
  18068c:	df000017 	ldw	fp,0(sp)
  180690:	dec00104 	addi	sp,sp,4
  180694:	f800283a 	ret

00180698 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {
  180698:	defffd04 	addi	sp,sp,-12
  18069c:	df000215 	stw	fp,8(sp)
  1806a0:	df000204 	addi	fp,sp,8
  1806a4:	e13ffe15 	stw	r4,-8(fp)
  1806a8:	e17fff15 	stw	r5,-4(fp)

  tp->p_prio = prio;
  1806ac:	e0bffe17 	ldw	r2,-8(fp)
  1806b0:	e0ffff17 	ldw	r3,-4(fp)
  1806b4:	10c00215 	stw	r3,8(r2)
  tp->p_state = THD_STATE_SUSPENDED;
  1806b8:	e0bffe17 	ldw	r2,-8(fp)
  1806bc:	00c00084 	movi	r3,2
  1806c0:	10c00705 	stb	r3,28(r2)
  tp->p_flags = THD_MEM_MODE_STATIC;
  1806c4:	e0bffe17 	ldw	r2,-8(fp)
  1806c8:	10000745 	stb	zero,29(r2)
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
  1806cc:	e0bffe17 	ldw	r2,-8(fp)
  1806d0:	e0ffff17 	ldw	r3,-4(fp)
  1806d4:	10c01015 	stw	r3,64(r2)
  tp->p_mtxlist = NULL;
  1806d8:	e0bffe17 	ldw	r2,-8(fp)
  1806dc:	10000f15 	stw	zero,60(r2)
#endif
#if CH_USE_EVENTS
  tp->p_epending = 0;
  1806e0:	e0bffe17 	ldw	r2,-8(fp)
  1806e4:	10000e15 	stw	zero,56(r2)
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
  1806e8:	e0bffe17 	ldw	r2,-8(fp)
  1806ec:	10000815 	stw	zero,32(r2)
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
  1806f0:	e0bffe17 	ldw	r2,-8(fp)
  1806f4:	00c00044 	movi	r3,1
  1806f8:	10c00785 	stb	r3,30(r2)
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
  1806fc:	e0bffe17 	ldw	r2,-8(fp)
  180700:	10000615 	stw	zero,24(r2)
  REG_INSERT(tp);
  180704:	e0bffe17 	ldw	r2,-8(fp)
  180708:	00c00674 	movhi	r3,25
  18070c:	18f18704 	addi	r3,r3,-14820
  180710:	10c00415 	stw	r3,16(r2)
  180714:	00800674 	movhi	r2,25
  180718:	10b18704 	addi	r2,r2,-14820
  18071c:	10c00517 	ldw	r3,20(r2)
  180720:	e0bffe17 	ldw	r2,-8(fp)
  180724:	10c00515 	stw	r3,20(r2)
  180728:	e0bffe17 	ldw	r2,-8(fp)
  18072c:	10800517 	ldw	r2,20(r2)
  180730:	00c00674 	movhi	r3,25
  180734:	18f18704 	addi	r3,r3,-14820
  180738:	e13ffe17 	ldw	r4,-8(fp)
  18073c:	19000515 	stw	r4,20(r3)
  180740:	00c00674 	movhi	r3,25
  180744:	18f18704 	addi	r3,r3,-14820
  180748:	18c00517 	ldw	r3,20(r3)
  18074c:	10c00415 	stw	r3,16(r2)
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
  180750:	e0bffe17 	ldw	r2,-8(fp)
  180754:	10c00a04 	addi	r3,r2,40
  180758:	e0bffe17 	ldw	r2,-8(fp)
  18075c:	10c00a15 	stw	r3,40(r2)
#endif
#if CH_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
  180760:	e0bffe17 	ldw	r2,-8(fp)
  180764:	10c00b04 	addi	r3,r2,44
  180768:	e0bffe17 	ldw	r2,-8(fp)
  18076c:	10c00c15 	stw	r3,48(r2)
  180770:	e0bffe17 	ldw	r2,-8(fp)
  180774:	10c00c17 	ldw	r3,48(r2)
  180778:	e0bffe17 	ldw	r2,-8(fp)
  18077c:	10c00b15 	stw	r3,44(r2)
  tp->p_stklimit = (stkalign_t *)(tp + 1);
#endif
#if defined(THREAD_EXT_INIT_HOOK)
  THREAD_EXT_INIT_HOOK(tp);
#endif
  return tp;
  180780:	e0bffe17 	ldw	r2,-8(fp)
}
  180784:	e037883a 	mov	sp,fp
  180788:	df000017 	ldw	fp,0(sp)
  18078c:	dec00104 	addi	sp,sp,4
  180790:	f800283a 	ret

00180794 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
Thread *chThdCreateI(void *wsp, size_t size,
                     tprio_t prio, tfunc_t pf, void *arg) {
  180794:	defff904 	addi	sp,sp,-28
  180798:	dfc00615 	stw	ra,24(sp)
  18079c:	df000515 	stw	fp,20(sp)
  1807a0:	df000504 	addi	fp,sp,20
  1807a4:	e13ffc15 	stw	r4,-16(fp)
  1807a8:	e17ffd15 	stw	r5,-12(fp)
  1807ac:	e1bffe15 	stw	r6,-8(fp)
  1807b0:	e1ffff15 	stw	r7,-4(fp)
  /* Thread structure is laid out in the lower part of the thread workspace.*/
  Thread *tp = wsp;
  1807b4:	e0bffc17 	ldw	r2,-16(fp)
  1807b8:	e0bffb15 	stw	r2,-20(fp)

  chDbgCheckClassI();

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
  1807bc:	e0bffc17 	ldw	r2,-16(fp)
  1807c0:	10000326 	beq	r2,zero,1807d0 <chThdCreateI+0x3c>
  1807c4:	e0bffd17 	ldw	r2,-12(fp)
  1807c8:	10805230 	cmpltui	r2,r2,328
  1807cc:	1000001e 	bne	r2,zero,1807d0 <chThdCreateI+0x3c>
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
  1807d0:	e0bffd17 	ldw	r2,-12(fp)
  1807d4:	10bff504 	addi	r2,r2,-44
  1807d8:	e0fffc17 	ldw	r3,-16(fp)
  1807dc:	1887883a 	add	r3,r3,r2
  1807e0:	e0bffb17 	ldw	r2,-20(fp)
  1807e4:	10c00315 	stw	r3,12(r2)
  1807e8:	e0bffb17 	ldw	r2,-20(fp)
  1807ec:	10800317 	ldw	r2,12(r2)
  1807f0:	e0ffff17 	ldw	r3,-4(fp)
  1807f4:	10c00215 	stw	r3,8(r2)
  1807f8:	e0bffb17 	ldw	r2,-20(fp)
  1807fc:	10800317 	ldw	r2,12(r2)
  180800:	e0c00217 	ldw	r3,8(fp)
  180804:	10c00315 	stw	r3,12(r2)
  180808:	e0bffb17 	ldw	r2,-20(fp)
  18080c:	10800317 	ldw	r2,12(r2)
  180810:	00c60634 	movhi	r3,6168
  180814:	18c60604 	addi	r3,r3,6168
  180818:	10c00415 	stw	r3,16(r2)
  18081c:	e0bffb17 	ldw	r2,-20(fp)
  180820:	10800317 	ldw	r2,12(r2)
  180824:	00c64674 	movhi	r3,6425
  180828:	18c64644 	addi	r3,r3,6425
  18082c:	10c00515 	stw	r3,20(r2)
  180830:	e0bffb17 	ldw	r2,-20(fp)
  180834:	10800317 	ldw	r2,12(r2)
  180838:	00c80834 	movhi	r3,8224
  18083c:	18c80804 	addi	r3,r3,8224
  180840:	10c00615 	stw	r3,24(r2)
  180844:	e0bffb17 	ldw	r2,-20(fp)
  180848:	10800317 	ldw	r2,12(r2)
  18084c:	00c84874 	movhi	r3,8481
  180850:	18c84844 	addi	r3,r3,8481
  180854:	10c00715 	stw	r3,28(r2)
  180858:	e0bffb17 	ldw	r2,-20(fp)
  18085c:	10800317 	ldw	r2,12(r2)
  180860:	00c888b4 	movhi	r3,8738
  180864:	18c88884 	addi	r3,r3,8738
  180868:	10c00815 	stw	r3,32(r2)
  18086c:	e0bffb17 	ldw	r2,-20(fp)
  180870:	10800317 	ldw	r2,12(r2)
  180874:	00c8c8f4 	movhi	r3,8995
  180878:	18c8c8c4 	addi	r3,r3,8995
  18087c:	10c00915 	stw	r3,36(r2)
  180880:	e0bffb17 	ldw	r2,-20(fp)
  180884:	10800317 	ldw	r2,12(r2)
  180888:	00c00044 	movi	r3,1
  18088c:	10c00a15 	stw	r3,40(r2)
  180890:	e0bffb17 	ldw	r2,-20(fp)
  180894:	10800317 	ldw	r2,12(r2)
  180898:	00ca0a34 	movhi	r3,10280
  18089c:	18ca0a04 	addi	r3,r3,10280
  1808a0:	10c00115 	stw	r3,4(r2)
  1808a4:	e0bffb17 	ldw	r2,-20(fp)
  1808a8:	10800317 	ldw	r2,12(r2)
  1808ac:	00c00634 	movhi	r3,24
  1808b0:	18c42304 	addi	r3,r3,4236
  1808b4:	10c00015 	stw	r3,0(r2)
  1808b8:	e0bffc17 	ldw	r2,-16(fp)
  1808bc:	10c01404 	addi	r3,r2,80
  1808c0:	e0bffb17 	ldw	r2,-20(fp)
  1808c4:	10c01215 	stw	r3,72(r2)
  1808c8:	e0fffc17 	ldw	r3,-16(fp)
  1808cc:	e0bffd17 	ldw	r2,-12(fp)
  1808d0:	1887883a 	add	r3,r3,r2
  1808d4:	e0bffb17 	ldw	r2,-20(fp)
  1808d8:	10c01315 	stw	r3,76(r2)
  return _thread_init(tp, prio);
  1808dc:	e13ffb17 	ldw	r4,-20(fp)
  1808e0:	e17ffe17 	ldw	r5,-8(fp)
  1808e4:	01806980 	call	180698 <_thread_init>
}
  1808e8:	e037883a 	mov	sp,fp
  1808ec:	dfc00117 	ldw	ra,4(sp)
  1808f0:	df000017 	ldw	fp,0(sp)
  1808f4:	dec00204 	addi	sp,sp,8
  1808f8:	f800283a 	ret

001808fc <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
Thread *chThdCreateStatic(void *wsp, size_t size,
                          tprio_t prio, tfunc_t pf, void *arg) {
  1808fc:	defff604 	addi	sp,sp,-40
  180900:	dfc00915 	stw	ra,36(sp)
  180904:	df000815 	stw	fp,32(sp)
  180908:	df000804 	addi	fp,sp,32
  18090c:	e13ffc15 	stw	r4,-16(fp)
  180910:	e17ffd15 	stw	r5,-12(fp)
  180914:	e1bffe15 	stw	r6,-8(fp)
  180918:	e1ffff15 	stw	r7,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  18091c:	0005303a 	rdctl	r2,status
  180920:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  180924:	e0fffa17 	ldw	r3,-24(fp)
  180928:	00bfff84 	movi	r2,-2
  18092c:	1884703a 	and	r2,r3,r2
  180930:	1001703a 	wrctl	status,r2
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  chSysLock();
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), RDY_OK);
  180934:	e0800217 	ldw	r2,8(fp)
  180938:	d8800015 	stw	r2,0(sp)
  18093c:	e13ffc17 	ldw	r4,-16(fp)
  180940:	e17ffd17 	ldw	r5,-12(fp)
  180944:	e1bffe17 	ldw	r6,-8(fp)
  180948:	e1ffff17 	ldw	r7,-4(fp)
  18094c:	01807940 	call	180794 <chThdCreateI>
  180950:	e0bff915 	stw	r2,-28(fp)
  180954:	e13ff917 	ldw	r4,-28(fp)
  180958:	000b883a 	mov	r5,zero
  18095c:	01840c40 	call	1840c4 <chSchWakeupS>
  180960:	00800044 	movi	r2,1
  180964:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  180968:	e0bffb17 	ldw	r2,-20(fp)
  18096c:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return tp;
  180970:	e0bff917 	ldw	r2,-28(fp)
}
  180974:	e037883a 	mov	sp,fp
  180978:	dfc00117 	ldw	ra,4(sp)
  18097c:	df000017 	ldw	fp,0(sp)
  180980:	dec00204 	addi	sp,sp,8
  180984:	f800283a 	ret

00180988 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
  180988:	defffa04 	addi	sp,sp,-24
  18098c:	dfc00515 	stw	ra,20(sp)
  180990:	df000415 	stw	fp,16(sp)
  180994:	df000404 	addi	fp,sp,16
  180998:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  18099c:	0005303a 	rdctl	r2,status
  1809a0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  1809a4:	e0fffd17 	ldw	r3,-12(fp)
  1809a8:	00bfff84 	movi	r2,-2
  1809ac:	1884703a 	and	r2,r3,r2
  1809b0:	1001703a 	wrctl	status,r2

  chDbgCheck(newprio <= HIGHPRIO, "chThdSetPriority");

  chSysLock();
#if CH_USE_MUTEXES
  oldprio = currp->p_realprio;
  1809b4:	00800674 	movhi	r2,25
  1809b8:	10b18704 	addi	r2,r2,-14820
  1809bc:	10800717 	ldw	r2,28(r2)
  1809c0:	10801017 	ldw	r2,64(r2)
  1809c4:	e0bffc15 	stw	r2,-16(fp)
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio))
  1809c8:	00800674 	movhi	r2,25
  1809cc:	10b18704 	addi	r2,r2,-14820
  1809d0:	10800717 	ldw	r2,28(r2)
  1809d4:	10c00217 	ldw	r3,8(r2)
  1809d8:	00800674 	movhi	r2,25
  1809dc:	10b18704 	addi	r2,r2,-14820
  1809e0:	10800717 	ldw	r2,28(r2)
  1809e4:	10801017 	ldw	r2,64(r2)
  1809e8:	18800626 	beq	r3,r2,180a04 <chThdSetPriority+0x7c>
  1809ec:	00800674 	movhi	r2,25
  1809f0:	10b18704 	addi	r2,r2,-14820
  1809f4:	10800717 	ldw	r2,28(r2)
  1809f8:	10c00217 	ldw	r3,8(r2)
  1809fc:	e0bfff17 	ldw	r2,-4(fp)
  180a00:	1880052e 	bgeu	r3,r2,180a18 <chThdSetPriority+0x90>
    currp->p_prio = newprio;
  180a04:	00800674 	movhi	r2,25
  180a08:	10b18704 	addi	r2,r2,-14820
  180a0c:	10800717 	ldw	r2,28(r2)
  180a10:	e0ffff17 	ldw	r3,-4(fp)
  180a14:	10c00215 	stw	r3,8(r2)
  currp->p_realprio = newprio;
  180a18:	00800674 	movhi	r2,25
  180a1c:	10b18704 	addi	r2,r2,-14820
  180a20:	10800717 	ldw	r2,28(r2)
  180a24:	e0ffff17 	ldw	r3,-4(fp)
  180a28:	10c01015 	stw	r3,64(r2)
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
  180a2c:	01841740 	call	184174 <chSchRescheduleS>
  180a30:	00800044 	movi	r2,1
  180a34:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  180a38:	e0bffe17 	ldw	r2,-8(fp)
  180a3c:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return oldprio;
  180a40:	e0bffc17 	ldw	r2,-16(fp)
}
  180a44:	e037883a 	mov	sp,fp
  180a48:	dfc00117 	ldw	ra,4(sp)
  180a4c:	df000017 	ldw	fp,0(sp)
  180a50:	dec00204 	addi	sp,sp,8
  180a54:	f800283a 	ret

00180a58 <chThdResume>:
 * @param[in] tp        pointer to the thread
 * @return              The pointer to the thread.
 *
 * @api
 */
Thread *chThdResume(Thread *tp) {
  180a58:	defffb04 	addi	sp,sp,-20
  180a5c:	dfc00415 	stw	ra,16(sp)
  180a60:	df000315 	stw	fp,12(sp)
  180a64:	df000304 	addi	fp,sp,12
  180a68:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  180a6c:	0005303a 	rdctl	r2,status
  180a70:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  180a74:	e0fffd17 	ldw	r3,-12(fp)
  180a78:	00bfff84 	movi	r2,-2
  180a7c:	1884703a 	and	r2,r3,r2
  180a80:	1001703a 	wrctl	status,r2

  chSysLock();
  chDbgAssert(tp->p_state == THD_STATE_SUSPENDED,
              "chThdResume(), #1",
              "thread not in THD_STATE_SUSPENDED state");
  chSchWakeupS(tp, RDY_OK);
  180a84:	e13fff17 	ldw	r4,-4(fp)
  180a88:	000b883a 	mov	r5,zero
  180a8c:	01840c40 	call	1840c4 <chSchWakeupS>
  180a90:	00800044 	movi	r2,1
  180a94:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  180a98:	e0bffe17 	ldw	r2,-8(fp)
  180a9c:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return tp;
  180aa0:	e0bfff17 	ldw	r2,-4(fp)
}
  180aa4:	e037883a 	mov	sp,fp
  180aa8:	dfc00117 	ldw	ra,4(sp)
  180aac:	df000017 	ldw	fp,0(sp)
  180ab0:	dec00204 	addi	sp,sp,8
  180ab4:	f800283a 	ret

00180ab8 <chThdTerminate>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdTerminate(Thread *tp) {
  180ab8:	defffc04 	addi	sp,sp,-16
  180abc:	df000315 	stw	fp,12(sp)
  180ac0:	df000304 	addi	fp,sp,12
  180ac4:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  180ac8:	0005303a 	rdctl	r2,status
  180acc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  180ad0:	e0fffd17 	ldw	r3,-12(fp)
  180ad4:	00bfff84 	movi	r2,-2
  180ad8:	1884703a 	and	r2,r3,r2
  180adc:	1001703a 	wrctl	status,r2

  chSysLock();
  tp->p_flags |= THD_TERMINATE;
  180ae0:	e0bfff17 	ldw	r2,-4(fp)
  180ae4:	10800743 	ldbu	r2,29(r2)
  180ae8:	10800114 	ori	r2,r2,4
  180aec:	1007883a 	mov	r3,r2
  180af0:	e0bfff17 	ldw	r2,-4(fp)
  180af4:	10c00745 	stb	r3,29(r2)
  180af8:	00800044 	movi	r2,1
  180afc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  180b00:	e0bffe17 	ldw	r2,-8(fp)
  180b04:	1001703a 	wrctl	status,r2
  chSysUnlock();
}
  180b08:	e037883a 	mov	sp,fp
  180b0c:	df000017 	ldw	fp,0(sp)
  180b10:	dec00104 	addi	sp,sp,4
  180b14:	f800283a 	ret

00180b18 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
  180b18:	defffb04 	addi	sp,sp,-20
  180b1c:	dfc00415 	stw	ra,16(sp)
  180b20:	df000315 	stw	fp,12(sp)
  180b24:	df000304 	addi	fp,sp,12
  180b28:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  180b2c:	0005303a 	rdctl	r2,status
  180b30:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  180b34:	e0fffd17 	ldw	r3,-12(fp)
  180b38:	00bfff84 	movi	r2,-2
  180b3c:	1884703a 	and	r2,r3,r2
  180b40:	1001703a 	wrctl	status,r2

  chDbgCheck(time != TIME_IMMEDIATE, "chThdSleep");

  chSysLock();
  chThdSleepS(time);
  180b44:	01000184 	movi	r4,6
  180b48:	e17fff17 	ldw	r5,-4(fp)
  180b4c:	01840280 	call	184028 <chSchGoSleepTimeoutS>
  180b50:	00800044 	movi	r2,1
  180b54:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  180b58:	e0bffe17 	ldw	r2,-8(fp)
  180b5c:	1001703a 	wrctl	status,r2
  chSysUnlock();
}
  180b60:	e037883a 	mov	sp,fp
  180b64:	dfc00117 	ldw	ra,4(sp)
  180b68:	df000017 	ldw	fp,0(sp)
  180b6c:	dec00204 	addi	sp,sp,8
  180b70:	f800283a 	ret

00180b74 <chThdSleepUntil>:
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
  180b74:	defffb04 	addi	sp,sp,-20
  180b78:	dfc00415 	stw	ra,16(sp)
  180b7c:	df000315 	stw	fp,12(sp)
  180b80:	df000304 	addi	fp,sp,12
  180b84:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  180b88:	0005303a 	rdctl	r2,status
  180b8c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  180b90:	e0fffd17 	ldw	r3,-12(fp)
  180b94:	00bfff84 	movi	r2,-2
  180b98:	1884703a 	and	r2,r3,r2
  180b9c:	1001703a 	wrctl	status,r2

  chSysLock();
  if ((time -= chTimeNow()) > 0)
  180ba0:	00800674 	movhi	r2,25
  180ba4:	10b18304 	addi	r2,r2,-14836
  180ba8:	10800317 	ldw	r2,12(r2)
  180bac:	e0ffff17 	ldw	r3,-4(fp)
  180bb0:	1885c83a 	sub	r2,r3,r2
  180bb4:	e0bfff15 	stw	r2,-4(fp)
  180bb8:	e0bfff17 	ldw	r2,-4(fp)
  180bbc:	10000326 	beq	r2,zero,180bcc <chThdSleepUntil+0x58>
    chThdSleepS(time);
  180bc0:	01000184 	movi	r4,6
  180bc4:	e17fff17 	ldw	r5,-4(fp)
  180bc8:	01840280 	call	184028 <chSchGoSleepTimeoutS>
  180bcc:	00800044 	movi	r2,1
  180bd0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  180bd4:	e0bffe17 	ldw	r2,-8(fp)
  180bd8:	1001703a 	wrctl	status,r2
  chSysUnlock();
}
  180bdc:	e037883a 	mov	sp,fp
  180be0:	dfc00117 	ldw	ra,4(sp)
  180be4:	df000017 	ldw	fp,0(sp)
  180be8:	dec00204 	addi	sp,sp,8
  180bec:	f800283a 	ret

00180bf0 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
  180bf0:	defffc04 	addi	sp,sp,-16
  180bf4:	dfc00315 	stw	ra,12(sp)
  180bf8:	df000215 	stw	fp,8(sp)
  180bfc:	df000204 	addi	fp,sp,8
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  180c00:	0005303a 	rdctl	r2,status
  180c04:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  180c08:	e0fffe17 	ldw	r3,-8(fp)
  180c0c:	00bfff84 	movi	r2,-2
  180c10:	1884703a 	and	r2,r3,r2
  180c14:	1001703a 	wrctl	status,r2

  chSysLock();
  chSchDoYieldS();
  180c18:	00800674 	movhi	r2,25
  180c1c:	10b18704 	addi	r2,r2,-14820
  180c20:	10800017 	ldw	r2,0(r2)
  180c24:	10c00217 	ldw	r3,8(r2)
  180c28:	00800674 	movhi	r2,25
  180c2c:	10b18704 	addi	r2,r2,-14820
  180c30:	10800717 	ldw	r2,28(r2)
  180c34:	10800217 	ldw	r2,8(r2)
  180c38:	18800136 	bltu	r3,r2,180c40 <chThdYield+0x50>
  180c3c:	01842380 	call	184238 <chSchDoReschedule>
  180c40:	00800044 	movi	r2,1
  180c44:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  180c48:	e0bfff17 	ldw	r2,-4(fp)
  180c4c:	1001703a 	wrctl	status,r2
  chSysUnlock();
}
  180c50:	e037883a 	mov	sp,fp
  180c54:	dfc00117 	ldw	ra,4(sp)
  180c58:	df000017 	ldw	fp,0(sp)
  180c5c:	dec00204 	addi	sp,sp,8
  180c60:	f800283a 	ret

00180c64 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
  180c64:	defffc04 	addi	sp,sp,-16
  180c68:	dfc00315 	stw	ra,12(sp)
  180c6c:	df000215 	stw	fp,8(sp)
  180c70:	df000204 	addi	fp,sp,8
  180c74:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  180c78:	0005303a 	rdctl	r2,status
  180c7c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  180c80:	e0fffe17 	ldw	r3,-8(fp)
  180c84:	00bfff84 	movi	r2,-2
  180c88:	1884703a 	and	r2,r3,r2
  180c8c:	1001703a 	wrctl	status,r2

  chSysLock();
  chThdExitS(msg);
  180c90:	e13fff17 	ldw	r4,-4(fp)
  180c94:	0180cac0 	call	180cac <chThdExitS>
  /* The thread never returns here.*/
}
  180c98:	e037883a 	mov	sp,fp
  180c9c:	dfc00117 	ldw	ra,4(sp)
  180ca0:	df000017 	ldw	fp,0(sp)
  180ca4:	dec00204 	addi	sp,sp,8
  180ca8:	f800283a 	ret

00180cac <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  180cac:	defffc04 	addi	sp,sp,-16
  180cb0:	dfc00315 	stw	ra,12(sp)
  180cb4:	df000215 	stw	fp,8(sp)
  180cb8:	df000204 	addi	fp,sp,8
  180cbc:	e13fff15 	stw	r4,-4(fp)
  Thread *tp = currp;
  180cc0:	00800674 	movhi	r2,25
  180cc4:	10b18704 	addi	r2,r2,-14820
  180cc8:	10800717 	ldw	r2,28(r2)
  180ccc:	e0bffe15 	stw	r2,-8(fp)

  tp->p_u.exitcode = msg;
  180cd0:	e0bffe17 	ldw	r2,-8(fp)
  180cd4:	e0ffff17 	ldw	r3,-4(fp)
  180cd8:	10c00915 	stw	r3,36(r2)
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
  180cdc:	00000606 	br	180cf8 <chThdExitS+0x4c>
    chSchReadyI(list_remove(&tp->p_waiting));
  180ce0:	e0bffe17 	ldw	r2,-8(fp)
  180ce4:	10800a04 	addi	r2,r2,40
  180ce8:	1009883a 	mov	r4,r2
  180cec:	01806580 	call	180658 <list_remove>
  180cf0:	1009883a 	mov	r4,r2
  180cf4:	0183e580 	call	183e58 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
  180cf8:	e0bffe17 	ldw	r2,-8(fp)
  180cfc:	10c00a17 	ldw	r3,40(r2)
  180d00:	e0bffe17 	ldw	r2,-8(fp)
  180d04:	10800a04 	addi	r2,r2,40
  180d08:	18bff51e 	bne	r3,r2,180ce0 <chThdExitS+0x34>
    chSchReadyI(list_remove(&tp->p_waiting));
#endif
#if CH_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
  180d0c:	e0bffe17 	ldw	r2,-8(fp)
  180d10:	10800743 	ldbu	r2,29(r2)
  180d14:	10803fcc 	andi	r2,r2,255
  180d18:	108000cc 	andi	r2,r2,3
  180d1c:	10000a1e 	bne	r2,zero,180d48 <chThdExitS+0x9c>
    REG_REMOVE(tp);
  180d20:	e0bffe17 	ldw	r2,-8(fp)
  180d24:	10800517 	ldw	r2,20(r2)
  180d28:	e0fffe17 	ldw	r3,-8(fp)
  180d2c:	18c00417 	ldw	r3,16(r3)
  180d30:	10c00415 	stw	r3,16(r2)
  180d34:	e0bffe17 	ldw	r2,-8(fp)
  180d38:	10800417 	ldw	r2,16(r2)
  180d3c:	e0fffe17 	ldw	r3,-8(fp)
  180d40:	18c00517 	ldw	r3,20(r3)
  180d44:	10c00515 	stw	r3,20(r2)
#endif
  chSchGoSleepS(THD_STATE_FINAL);
  180d48:	01000384 	movi	r4,14
  180d4c:	0183eec0 	call	183eec <chSchGoSleepS>
  /* The thread never returns here.*/
  chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
}
  180d50:	e037883a 	mov	sp,fp
  180d54:	dfc00117 	ldw	ra,4(sp)
  180d58:	df000017 	ldw	fp,0(sp)
  180d5c:	dec00204 	addi	sp,sp,8
  180d60:	f800283a 	ret

00180d64 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(Thread *tp) {
  180d64:	defffa04 	addi	sp,sp,-24
  180d68:	dfc00515 	stw	ra,20(sp)
  180d6c:	df000415 	stw	fp,16(sp)
  180d70:	df000404 	addi	fp,sp,16
  180d74:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  180d78:	0005303a 	rdctl	r2,status
  180d7c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  180d80:	e0fffd17 	ldw	r3,-12(fp)
  180d84:	00bfff84 	movi	r2,-2
  180d88:	1884703a 	and	r2,r3,r2
  180d8c:	1001703a 	wrctl	status,r2
  chSysLock();
  chDbgAssert(tp != currp, "chThdWait(), #1", "waiting self");
#if CH_USE_DYNAMIC
  chDbgAssert(tp->p_refs > 0, "chThdWait(), #2", "not referenced");
#endif
  if (tp->p_state != THD_STATE_FINAL) {
  180d90:	e0bfff17 	ldw	r2,-4(fp)
  180d94:	10800703 	ldbu	r2,28(r2)
  180d98:	10803fcc 	andi	r2,r2,255
  180d9c:	108003a0 	cmpeqi	r2,r2,14
  180da0:	10000a1e 	bne	r2,zero,180dcc <chThdWait+0x68>
    list_insert(currp, &tp->p_waiting);
  180da4:	00800674 	movhi	r2,25
  180da8:	10b18704 	addi	r2,r2,-14820
  180dac:	10c00717 	ldw	r3,28(r2)
  180db0:	e0bfff17 	ldw	r2,-4(fp)
  180db4:	10800a04 	addi	r2,r2,40
  180db8:	1809883a 	mov	r4,r3
  180dbc:	100b883a 	mov	r5,r2
  180dc0:	01806180 	call	180618 <list_insert>
    chSchGoSleepS(THD_STATE_WTEXIT);
  180dc4:	010001c4 	movi	r4,7
  180dc8:	0183eec0 	call	183eec <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
  180dcc:	e0bfff17 	ldw	r2,-4(fp)
  180dd0:	10800917 	ldw	r2,36(r2)
  180dd4:	e0bffc15 	stw	r2,-16(fp)
  180dd8:	00800044 	movi	r2,1
  180ddc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  180de0:	e0bffe17 	ldw	r2,-8(fp)
  180de4:	1001703a 	wrctl	status,r2
  chSysUnlock();
#if CH_USE_DYNAMIC
  chThdRelease(tp);
  180de8:	e13fff17 	ldw	r4,-4(fp)
  180dec:	0182b140 	call	182b14 <chThdRelease>
#endif
  return msg;
  180df0:	e0bffc17 	ldw	r2,-16(fp)
}
  180df4:	e037883a 	mov	sp,fp
  180df8:	dfc00117 	ldw	ra,4(sp)
  180dfc:	df000017 	ldw	fp,0(sp)
  180e00:	dec00204 	addi	sp,sp,8
  180e04:	f800283a 	ret

00180e08 <_vt_init>:
 * @brief   Virtual Timers initialization.
 * @note    Internal use only.
 *
 * @notapi
 */
void _vt_init(void) {
  180e08:	deffff04 	addi	sp,sp,-4
  180e0c:	df000015 	stw	fp,0(sp)
  180e10:	d839883a 	mov	fp,sp

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
  180e14:	00800674 	movhi	r2,25
  180e18:	10b18304 	addi	r2,r2,-14836
  180e1c:	00c00674 	movhi	r3,25
  180e20:	18f18304 	addi	r3,r3,-14836
  180e24:	10c00115 	stw	r3,4(r2)
  180e28:	00800674 	movhi	r2,25
  180e2c:	10b18304 	addi	r2,r2,-14836
  180e30:	10c00117 	ldw	r3,4(r2)
  180e34:	00800674 	movhi	r2,25
  180e38:	10b18304 	addi	r2,r2,-14836
  180e3c:	10c00015 	stw	r3,0(r2)
  vtlist.vt_time = (systime_t)-1;
  180e40:	00800674 	movhi	r2,25
  180e44:	10b18304 	addi	r2,r2,-14836
  180e48:	00ffffc4 	movi	r3,-1
  180e4c:	10c00215 	stw	r3,8(r2)
  vtlist.vt_systime = 0;
  180e50:	00800674 	movhi	r2,25
  180e54:	10b18304 	addi	r2,r2,-14836
  180e58:	10000315 	stw	zero,12(r2)
}
  180e5c:	e037883a 	mov	sp,fp
  180e60:	df000017 	ldw	fp,0(sp)
  180e64:	dec00104 	addi	sp,sp,4
  180e68:	f800283a 	ret

00180e6c <chVTSetI>:
 * @param[in] par       a parameter that will be passed to the callback
 *                      function
 *
 * @iclass
 */
void chVTSetI(VirtualTimer *vtp, systime_t time, vtfunc_t vtfunc, void *par) {
  180e6c:	defffa04 	addi	sp,sp,-24
  180e70:	df000515 	stw	fp,20(sp)
  180e74:	df000504 	addi	fp,sp,20
  180e78:	e13ffc15 	stw	r4,-16(fp)
  180e7c:	e17ffd15 	stw	r5,-12(fp)
  180e80:	e1bffe15 	stw	r6,-8(fp)
  180e84:	e1ffff15 	stw	r7,-4(fp)
  VirtualTimer *p;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
  180e88:	e0bffc17 	ldw	r2,-16(fp)
  180e8c:	10000226 	beq	r2,zero,180e98 <chVTSetI+0x2c>
  180e90:	e0bffe17 	ldw	r2,-8(fp)
  180e94:	10000026 	beq	r2,zero,180e98 <chVTSetI+0x2c>
             "chVTSetI");

  vtp->vt_par = par;
  180e98:	e0bffc17 	ldw	r2,-16(fp)
  180e9c:	e0ffff17 	ldw	r3,-4(fp)
  180ea0:	10c00415 	stw	r3,16(r2)
  vtp->vt_func = vtfunc;
  180ea4:	e0bffc17 	ldw	r2,-16(fp)
  180ea8:	e0fffe17 	ldw	r3,-8(fp)
  180eac:	10c00315 	stw	r3,12(r2)
  p = vtlist.vt_next;
  180eb0:	00800674 	movhi	r2,25
  180eb4:	10b18304 	addi	r2,r2,-14836
  180eb8:	10800017 	ldw	r2,0(r2)
  180ebc:	e0bffb15 	stw	r2,-20(fp)
  while (p->vt_time < time) {
  180ec0:	00000806 	br	180ee4 <chVTSetI+0x78>
    time -= p->vt_time;
  180ec4:	e0bffb17 	ldw	r2,-20(fp)
  180ec8:	10800217 	ldw	r2,8(r2)
  180ecc:	e0fffd17 	ldw	r3,-12(fp)
  180ed0:	1885c83a 	sub	r2,r3,r2
  180ed4:	e0bffd15 	stw	r2,-12(fp)
    p = p->vt_next;
  180ed8:	e0bffb17 	ldw	r2,-20(fp)
  180edc:	10800017 	ldw	r2,0(r2)
  180ee0:	e0bffb15 	stw	r2,-20(fp)
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
  while (p->vt_time < time) {
  180ee4:	e0bffb17 	ldw	r2,-20(fp)
  180ee8:	10c00217 	ldw	r3,8(r2)
  180eec:	e0bffd17 	ldw	r2,-12(fp)
  180ef0:	18bff436 	bltu	r3,r2,180ec4 <chVTSetI+0x58>
    time -= p->vt_time;
    p = p->vt_next;
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
  180ef4:	e0bffc17 	ldw	r2,-16(fp)
  180ef8:	e0fffb17 	ldw	r3,-20(fp)
  180efc:	10c00015 	stw	r3,0(r2)
  180f00:	e0bffc17 	ldw	r2,-16(fp)
  180f04:	10800017 	ldw	r2,0(r2)
  180f08:	10c00117 	ldw	r3,4(r2)
  180f0c:	e0bffc17 	ldw	r2,-16(fp)
  180f10:	10c00115 	stw	r3,4(r2)
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
  180f14:	e0bffc17 	ldw	r2,-16(fp)
  180f18:	10800117 	ldw	r2,4(r2)
  180f1c:	e0fffb17 	ldw	r3,-20(fp)
  180f20:	e13ffc17 	ldw	r4,-16(fp)
  180f24:	19000115 	stw	r4,4(r3)
  180f28:	e0fffb17 	ldw	r3,-20(fp)
  180f2c:	18c00117 	ldw	r3,4(r3)
  180f30:	10c00015 	stw	r3,0(r2)
  vtp->vt_time = time;
  180f34:	e0bffc17 	ldw	r2,-16(fp)
  180f38:	e0fffd17 	ldw	r3,-12(fp)
  180f3c:	10c00215 	stw	r3,8(r2)
  if (p != (void *)&vtlist)
  180f40:	e0fffb17 	ldw	r3,-20(fp)
  180f44:	00800674 	movhi	r2,25
  180f48:	10b18304 	addi	r2,r2,-14836
  180f4c:	18800626 	beq	r3,r2,180f68 <chVTSetI+0xfc>
    p->vt_time -= time;
  180f50:	e0bffb17 	ldw	r2,-20(fp)
  180f54:	10c00217 	ldw	r3,8(r2)
  180f58:	e0bffd17 	ldw	r2,-12(fp)
  180f5c:	1887c83a 	sub	r3,r3,r2
  180f60:	e0bffb17 	ldw	r2,-20(fp)
  180f64:	10c00215 	stw	r3,8(r2)
}
  180f68:	e037883a 	mov	sp,fp
  180f6c:	df000017 	ldw	fp,0(sp)
  180f70:	dec00104 	addi	sp,sp,4
  180f74:	f800283a 	ret

00180f78 <chVTResetI>:
 *
 * @param[in] vtp       the @p VirtualTimer structure pointer
 *
 * @iclass
 */
void chVTResetI(VirtualTimer *vtp) {
  180f78:	defffe04 	addi	sp,sp,-8
  180f7c:	df000115 	stw	fp,4(sp)
  180f80:	df000104 	addi	fp,sp,4
  180f84:	e13fff15 	stw	r4,-4(fp)
  chDbgCheck(vtp != NULL, "chVTResetI");
  chDbgAssert(vtp->vt_func != NULL,
              "chVTResetI(), #1",
              "timer not set or already triggered");

  if (vtp->vt_next != (void *)&vtlist)
  180f88:	e0bfff17 	ldw	r2,-4(fp)
  180f8c:	10c00017 	ldw	r3,0(r2)
  180f90:	00800674 	movhi	r2,25
  180f94:	10b18304 	addi	r2,r2,-14836
  180f98:	18800926 	beq	r3,r2,180fc0 <chVTResetI+0x48>
    vtp->vt_next->vt_time += vtp->vt_time;
  180f9c:	e0bfff17 	ldw	r2,-4(fp)
  180fa0:	10800017 	ldw	r2,0(r2)
  180fa4:	e0ffff17 	ldw	r3,-4(fp)
  180fa8:	18c00017 	ldw	r3,0(r3)
  180fac:	19000217 	ldw	r4,8(r3)
  180fb0:	e0ffff17 	ldw	r3,-4(fp)
  180fb4:	18c00217 	ldw	r3,8(r3)
  180fb8:	20c7883a 	add	r3,r4,r3
  180fbc:	10c00215 	stw	r3,8(r2)
  vtp->vt_prev->vt_next = vtp->vt_next;
  180fc0:	e0bfff17 	ldw	r2,-4(fp)
  180fc4:	10800117 	ldw	r2,4(r2)
  180fc8:	e0ffff17 	ldw	r3,-4(fp)
  180fcc:	18c00017 	ldw	r3,0(r3)
  180fd0:	10c00015 	stw	r3,0(r2)
  vtp->vt_next->vt_prev = vtp->vt_prev;
  180fd4:	e0bfff17 	ldw	r2,-4(fp)
  180fd8:	10800017 	ldw	r2,0(r2)
  180fdc:	e0ffff17 	ldw	r3,-4(fp)
  180fe0:	18c00117 	ldw	r3,4(r3)
  180fe4:	10c00115 	stw	r3,4(r2)
  vtp->vt_func = (vtfunc_t)NULL;
  180fe8:	e0bfff17 	ldw	r2,-4(fp)
  180fec:	10000315 	stw	zero,12(r2)
}
  180ff0:	e037883a 	mov	sp,fp
  180ff4:	df000017 	ldw	fp,0(sp)
  180ff8:	dec00104 	addi	sp,sp,4
  180ffc:	f800283a 	ret

00181000 <chTimeIsWithin>:
 * @retval TRUE         current time within the specified time window.
 * @retval FALSE        current time not within the specified time window.
 *
 * @api
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {
  181000:	defffc04 	addi	sp,sp,-16
  181004:	df000315 	stw	fp,12(sp)
  181008:	df000304 	addi	fp,sp,12
  18100c:	e13ffe15 	stw	r4,-8(fp)
  181010:	e17fff15 	stw	r5,-4(fp)

  systime_t time = chTimeNow();
  181014:	00800674 	movhi	r2,25
  181018:	10b18304 	addi	r2,r2,-14836
  18101c:	10800317 	ldw	r2,12(r2)
  181020:	e0bffd15 	stw	r2,-12(fp)
  return end > start ? (time >= start) && (time < end) :
  181024:	e0bfff17 	ldw	r2,-4(fp)
  181028:	e0fffe17 	ldw	r3,-8(fp)
  18102c:	18800a2e 	bgeu	r3,r2,181058 <chTimeIsWithin+0x58>
  181030:	e0fffd17 	ldw	r3,-12(fp)
  181034:	e0bffe17 	ldw	r2,-8(fp)
  181038:	18800536 	bltu	r3,r2,181050 <chTimeIsWithin+0x50>
  18103c:	e0fffd17 	ldw	r3,-12(fp)
  181040:	e0bfff17 	ldw	r2,-4(fp)
  181044:	1880022e 	bgeu	r3,r2,181050 <chTimeIsWithin+0x50>
  181048:	00800044 	movi	r2,1
  18104c:	00000106 	br	181054 <chTimeIsWithin+0x54>
  181050:	0005883a 	mov	r2,zero
  181054:	00000906 	br	18107c <chTimeIsWithin+0x7c>
  181058:	e0fffd17 	ldw	r3,-12(fp)
  18105c:	e0bffe17 	ldw	r2,-8(fp)
  181060:	1880032e 	bgeu	r3,r2,181070 <chTimeIsWithin+0x70>
                       (time >= start) || (time < end);
  181064:	e0fffd17 	ldw	r3,-12(fp)
  181068:	e0bfff17 	ldw	r2,-4(fp)
  18106c:	1880022e 	bgeu	r3,r2,181078 <chTimeIsWithin+0x78>
 * @api
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {

  systime_t time = chTimeNow();
  return end > start ? (time >= start) && (time < end) :
  181070:	00800044 	movi	r2,1
  181074:	00000106 	br	18107c <chTimeIsWithin+0x7c>
  181078:	0005883a 	mov	r2,zero
                       (time >= start) || (time < end);
}
  18107c:	e037883a 	mov	sp,fp
  181080:	df000017 	ldw	fp,0(sp)
  181084:	dec00104 	addi	sp,sp,4
  181088:	f800283a 	ret

0018108c <_port_thread_start>:
/*                                                                         */
/*  Start a thread by invoking its work function.                          */
/***************************************************************************/
_port_thread_start:

      mov   r4, r17        /* r4 = Register Arguments (First 32 bits) */
  18108c:	8809883a 	mov	r4,r17
      mov   r5, r16        /* Store thread pointer for the callr,     */
  181090:	800b883a 	mov	r5,r16
      callr r5             /* and call the thread */
  181094:	283ee83a 	callr	r5
      call  chThdExit      /* This is the thread exit function. */
  181098:	0180c640 	call	180c64 <chThdExit>

0018109c <_port_thread_start_loop>:
      
_port_thread_start_loop:      
      br    _port_thread_start_loop
  18109c:	003fff06 	br	18109c <_port_thread_start_loop>

001810a0 <port_switch>:
/***************************************************************************/
port_switch:

      /* r4 = ntp, r5 = otp */

      addi  sp, sp, -44    /* Size of the intctx structure */
  1810a0:	defff504 	addi	sp,sp,-44
      
      stw   ra,   0(sp)
  1810a4:	dfc00015 	stw	ra,0(sp)
      stw   fp,   4(sp)
  1810a8:	df000115 	stw	fp,4(sp)
      stw   r16,  8(sp)
  1810ac:	dc000215 	stw	r16,8(sp)
      stw   r17, 12(sp)
  1810b0:	dc400315 	stw	r17,12(sp)
      stw   r18, 16(sp)
  1810b4:	dc800415 	stw	r18,16(sp)
      stw   r19, 20(sp)
  1810b8:	dcc00515 	stw	r19,20(sp)
      stw   r20, 24(sp)
  1810bc:	dd000615 	stw	r20,24(sp)
      stw   r21, 28(sp)
  1810c0:	dd400715 	stw	r21,28(sp)
      stw   r22, 32(sp)
  1810c4:	dd800815 	stw	r22,32(sp)
      stw   r23, 36(sp)
  1810c8:	ddc00915 	stw	r23,36(sp)
      
      rdctl r23, status    /* r23 is not more needed and can */
  1810cc:	002f303a 	rdctl	r23,status
      stw   r23, 40(sp)    /* be used here to store the status */
  1810d0:	ddc00a15 	stw	r23,40(sp)
      
      stw   sp, 12(r5)     /* Save old stack: otp->p_ctx.sp = sp */
  1810d4:	2ec00315 	stw	sp,12(r5)
      
      ldw   sp, 12(r4)     /* Get new stack: sp = ntp->p_ctx.sp */
  1810d8:	26c00317 	ldw	sp,12(r4)
      
      ldw   ra,   0(sp)
  1810dc:	dfc00017 	ldw	ra,0(sp)
      ldw   fp,   4(sp)
  1810e0:	df000117 	ldw	fp,4(sp)
      ldw   r16,  8(sp)
  1810e4:	dc000217 	ldw	r16,8(sp)
      ldw   r17, 12(sp)
  1810e8:	dc400317 	ldw	r17,12(sp)
      ldw   r18, 16(sp)
  1810ec:	dc800417 	ldw	r18,16(sp)
      ldw   r19, 20(sp)
  1810f0:	dcc00517 	ldw	r19,20(sp)
      ldw   r20, 24(sp)
  1810f4:	dd000617 	ldw	r20,24(sp)
      ldw   r21, 28(sp)
  1810f8:	dd400717 	ldw	r21,28(sp)
      ldw   r22, 32(sp)
  1810fc:	dd800817 	ldw	r22,32(sp)
      ldw   r23, 36(sp)
  181100:	ddc00917 	ldw	r23,36(sp)
      
      ldw   r4,  40(sp)    /* r4 is not more needed and can */
  181104:	d9000a17 	ldw	r4,40(sp)
      wrctl status, r4     /* be used here to store the status */
  181108:	2001703a 	wrctl	status,r4
      
      addi  sp, sp, 44     /* Size of the intctx structure */
  18110c:	dec00b04 	addi	sp,sp,44
      
      ret
  181110:	f800283a 	ret
   
      nop
  181114:	0001883a 	nop

00181118 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  181118:	defffc04 	addi	sp,sp,-16
  18111c:	df000315 	stw	fp,12(sp)
  181120:	df000304 	addi	fp,sp,12
  181124:	e13ffd15 	stw	r4,-12(fp)
  181128:	e17ffe15 	stw	r5,-8(fp)
  18112c:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
  181130:	e0fffe17 	ldw	r3,-8(fp)
  181134:	e0bffd17 	ldw	r2,-12(fp)
  181138:	18800e26 	beq	r3,r2,181174 <alt_load_section+0x5c>
  {
    while( to != end )
  18113c:	00000a06 	br	181168 <alt_load_section+0x50>
    {
      *to++ = *from++;
  181140:	e0bffd17 	ldw	r2,-12(fp)
  181144:	10c00017 	ldw	r3,0(r2)
  181148:	e0bffe17 	ldw	r2,-8(fp)
  18114c:	10c00015 	stw	r3,0(r2)
  181150:	e0bffe17 	ldw	r2,-8(fp)
  181154:	10800104 	addi	r2,r2,4
  181158:	e0bffe15 	stw	r2,-8(fp)
  18115c:	e0bffd17 	ldw	r2,-12(fp)
  181160:	10800104 	addi	r2,r2,4
  181164:	e0bffd15 	stw	r2,-12(fp)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
  181168:	e0fffe17 	ldw	r3,-8(fp)
  18116c:	e0bfff17 	ldw	r2,-4(fp)
  181170:	18bff31e 	bne	r3,r2,181140 <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
  181174:	e037883a 	mov	sp,fp
  181178:	df000017 	ldw	fp,0(sp)
  18117c:	dec00104 	addi	sp,sp,4
  181180:	f800283a 	ret

00181184 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
  181184:	defffe04 	addi	sp,sp,-8
  181188:	dfc00115 	stw	ra,4(sp)
  18118c:	df000015 	stw	fp,0(sp)
  181190:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
  181194:	01000674 	movhi	r4,25
  181198:	212a8e04 	addi	r4,r4,-21960
  18119c:	01400674 	movhi	r5,25
  1811a0:	2963cb04 	addi	r5,r5,-28884
  1811a4:	01800674 	movhi	r6,25
  1811a8:	31aa8e04 	addi	r6,r6,-21960
  1811ac:	01811180 	call	181118 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
  1811b0:	01000634 	movhi	r4,24
  1811b4:	21000804 	addi	r4,r4,32
  1811b8:	01400634 	movhi	r5,24
  1811bc:	29400804 	addi	r5,r5,32
  1811c0:	01800634 	movhi	r6,24
  1811c4:	31807104 	addi	r6,r6,452
  1811c8:	01811180 	call	181118 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
  1811cc:	01000674 	movhi	r4,25
  1811d0:	21239c04 	addi	r4,r4,-29072
  1811d4:	01400674 	movhi	r5,25
  1811d8:	29639c04 	addi	r5,r5,-29072
  1811dc:	01800674 	movhi	r6,25
  1811e0:	31a3cb04 	addi	r6,r6,-28884
  1811e4:	01811180 	call	181118 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  1811e8:	01847240 	call	184724 <alt_dcache_flush_all>
  alt_icache_flush_all();
  1811ec:	01849140 	call	184914 <alt_icache_flush_all>
}
  1811f0:	e037883a 	mov	sp,fp
  1811f4:	dfc00117 	ldw	ra,4(sp)
  1811f8:	df000017 	ldw	fp,0(sp)
  1811fc:	dec00204 	addi	sp,sp,8
  181200:	f800283a 	ret

00181204 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  181204:	defffc04 	addi	sp,sp,-16
  181208:	dfc00315 	stw	ra,12(sp)
  18120c:	df000215 	stw	fp,8(sp)
  181210:	df000204 	addi	fp,sp,8
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  181214:	0009883a 	mov	r4,zero
  181218:	01815980 	call	181598 <alt_irq_init>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  18121c:	0005303a 	rdctl	r2,status
  181220:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  181224:	e0ffff17 	ldw	r3,-4(fp)
  181228:	00bfff84 	movi	r2,-2
  18122c:	1884703a 	and	r2,r3,r2
  181230:	1001703a 	wrctl	status,r2

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
  181234:	01842f80 	call	1842f8 <chSysInit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  181238:	01815cc0 	call	1815cc <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
  18123c:	01000674 	movhi	r4,25
  181240:	2123b404 	addi	r4,r4,-28976
  181244:	01400674 	movhi	r5,25
  181248:	2963b404 	addi	r5,r5,-28976
  18124c:	01800674 	movhi	r6,25
  181250:	31a3b404 	addi	r6,r6,-28976
  181254:	0184cd80 	call	184cd8 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
  181258:	018485c0 	call	18485c <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
  18125c:	01000634 	movhi	r4,24
  181260:	21122e04 	addi	r4,r4,18616
  181264:	01855f40 	call	1855f4 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
  181268:	d126d217 	ldw	r4,-25784(gp)
  18126c:	d0e6d317 	ldw	r3,-25780(gp)
  181270:	d0a6d417 	ldw	r2,-25776(gp)
  181274:	180b883a 	mov	r5,r3
  181278:	100d883a 	mov	r6,r2
  18127c:	01802000 	call	180200 <main>
  181280:	e0bffe15 	stw	r2,-8(fp)
  close(STDOUT_FILENO);
  181284:	01000044 	movi	r4,1
  181288:	01846580 	call	184658 <close>
  exit (result);
  18128c:	e13ffe17 	ldw	r4,-8(fp)
  181290:	01856080 	call	185608 <exit>

00181294 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
  181294:	defff204 	addi	sp,sp,-56
  181298:	dfc00a15 	stw	ra,40(sp)
  18129c:	df000915 	stw	fp,36(sp)
  1812a0:	df000904 	addi	fp,sp,36
  1812a4:	e1400215 	stw	r5,8(fp)
  1812a8:	e1800315 	stw	r6,12(fp)
  1812ac:	e1c00415 	stw	r7,16(fp)
  1812b0:	e13fff15 	stw	r4,-4(fp)
	va_list args;
	va_start(args, fmt);
  1812b4:	e0800204 	addi	r2,fp,8
  1812b8:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
  1812bc:	e0bfff17 	ldw	r2,-4(fp)
  1812c0:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
  1812c4:	00007306 	br	181494 <alt_printf+0x200>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
  1812c8:	e0bff807 	ldb	r2,-32(fp)
  1812cc:	10800960 	cmpeqi	r2,r2,37
  1812d0:	1000041e 	bne	r2,zero,1812e4 <alt_printf+0x50>
        {
            alt_putchar(c);
  1812d4:	e0bff807 	ldb	r2,-32(fp)
  1812d8:	1009883a 	mov	r4,r2
  1812dc:	01814d80 	call	1814d8 <alt_putchar>
  1812e0:	00006c06 	br	181494 <alt_printf+0x200>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
  1812e4:	e0bff717 	ldw	r2,-36(fp)
  1812e8:	10800003 	ldbu	r2,0(r2)
  1812ec:	e0bff805 	stb	r2,-32(fp)
  1812f0:	e0bff807 	ldb	r2,-32(fp)
  1812f4:	1004c03a 	cmpne	r2,r2,zero
  1812f8:	e0fff717 	ldw	r3,-36(fp)
  1812fc:	18c00044 	addi	r3,r3,1
  181300:	e0fff715 	stw	r3,-36(fp)
  181304:	10803fcc 	andi	r2,r2,255
  181308:	10006d26 	beq	r2,zero,1814c0 <alt_printf+0x22c>
            {
                if (c == '%')
  18130c:	e0bff807 	ldb	r2,-32(fp)
  181310:	10800958 	cmpnei	r2,r2,37
  181314:	1000041e 	bne	r2,zero,181328 <alt_printf+0x94>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
  181318:	e0bff807 	ldb	r2,-32(fp)
  18131c:	1009883a 	mov	r4,r2
  181320:	01814d80 	call	1814d8 <alt_putchar>
  181324:	00005b06 	br	181494 <alt_printf+0x200>
                } 
                else if (c == 'c')
  181328:	e0bff807 	ldb	r2,-32(fp)
  18132c:	108018d8 	cmpnei	r2,r2,99
  181330:	1000081e 	bne	r2,zero,181354 <alt_printf+0xc0>
                {
                    int v = va_arg(args, int);
  181334:	e0bffe17 	ldw	r2,-8(fp)
  181338:	10c00104 	addi	r3,r2,4
  18133c:	e0fffe15 	stw	r3,-8(fp)
  181340:	10800017 	ldw	r2,0(r2)
  181344:	e0bffb15 	stw	r2,-20(fp)
                    alt_putchar(v);
  181348:	e13ffb17 	ldw	r4,-20(fp)
  18134c:	01814d80 	call	1814d8 <alt_putchar>
  181350:	00005006 	br	181494 <alt_printf+0x200>
                }
                else if (c == 'x')
  181354:	e0bff807 	ldb	r2,-32(fp)
  181358:	10801e18 	cmpnei	r2,r2,120
  18135c:	1000341e 	bne	r2,zero,181430 <alt_printf+0x19c>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
  181360:	e0bffe17 	ldw	r2,-8(fp)
  181364:	10c00104 	addi	r3,r2,4
  181368:	e0fffe15 	stw	r3,-8(fp)
  18136c:	10800017 	ldw	r2,0(r2)
  181370:	e0bffc15 	stw	r2,-16(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
  181374:	e0bffc17 	ldw	r2,-16(fp)
  181378:	1000031e 	bne	r2,zero,181388 <alt_printf+0xf4>
                    {
                        alt_putchar('0');
  18137c:	01000c04 	movi	r4,48
  181380:	01814d80 	call	1814d8 <alt_putchar>
                        continue;
  181384:	00004306 	br	181494 <alt_printf+0x200>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
  181388:	00800704 	movi	r2,28
  18138c:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
  181390:	00000306 	br	1813a0 <alt_printf+0x10c>
                        digit_shift -= 4;
  181394:	e0bff917 	ldw	r2,-28(fp)
  181398:	10bfff04 	addi	r2,r2,-4
  18139c:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
  1813a0:	00c003c4 	movi	r3,15
  1813a4:	e0bff917 	ldw	r2,-28(fp)
  1813a8:	1884983a 	sll	r2,r3,r2
  1813ac:	1007883a 	mov	r3,r2
  1813b0:	e0bffc17 	ldw	r2,-16(fp)
  1813b4:	1884703a 	and	r2,r3,r2
  1813b8:	103ff626 	beq	r2,zero,181394 <alt_printf+0x100>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
  1813bc:	00001906 	br	181424 <alt_printf+0x190>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
  1813c0:	00c003c4 	movi	r3,15
  1813c4:	e0bff917 	ldw	r2,-28(fp)
  1813c8:	1884983a 	sll	r2,r3,r2
  1813cc:	1007883a 	mov	r3,r2
  1813d0:	e0bffc17 	ldw	r2,-16(fp)
  1813d4:	1886703a 	and	r3,r3,r2
  1813d8:	e0bff917 	ldw	r2,-28(fp)
  1813dc:	1884d83a 	srl	r2,r3,r2
  1813e0:	e0bffd15 	stw	r2,-12(fp)
                        if (digit <= 9)
  1813e4:	e0bffd17 	ldw	r2,-12(fp)
  1813e8:	108002a8 	cmpgeui	r2,r2,10
  1813ec:	1000041e 	bne	r2,zero,181400 <alt_printf+0x16c>
                            c = '0' + digit;
  1813f0:	e0bffd17 	ldw	r2,-12(fp)
  1813f4:	10800c04 	addi	r2,r2,48
  1813f8:	e0bff805 	stb	r2,-32(fp)
  1813fc:	00000306 	br	18140c <alt_printf+0x178>
                        else
                            c = 'a' + digit - 10;
  181400:	e0bffd17 	ldw	r2,-12(fp)
  181404:	108015c4 	addi	r2,r2,87
  181408:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
  18140c:	e0bff807 	ldb	r2,-32(fp)
  181410:	1009883a 	mov	r4,r2
  181414:	01814d80 	call	1814d8 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
  181418:	e0bff917 	ldw	r2,-28(fp)
  18141c:	10bfff04 	addi	r2,r2,-4
  181420:	e0bff915 	stw	r2,-28(fp)
  181424:	e0bff917 	ldw	r2,-28(fp)
  181428:	103fe50e 	bge	r2,zero,1813c0 <alt_printf+0x12c>
  18142c:	00001906 	br	181494 <alt_printf+0x200>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
  181430:	e0bff807 	ldb	r2,-32(fp)
  181434:	10801cd8 	cmpnei	r2,r2,115
  181438:	1000161e 	bne	r2,zero,181494 <alt_printf+0x200>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
  18143c:	e0bffe17 	ldw	r2,-8(fp)
  181440:	10c00104 	addi	r3,r2,4
  181444:	e0fffe15 	stw	r3,-8(fp)
  181448:	10800017 	ldw	r2,0(r2)
  18144c:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
  181450:	00000a06 	br	18147c <alt_printf+0x1e8>
                      alt_putchar(*s++);
  181454:	e0bffa17 	ldw	r2,-24(fp)
  181458:	10800003 	ldbu	r2,0(r2)
  18145c:	10803fcc 	andi	r2,r2,255
  181460:	1080201c 	xori	r2,r2,128
  181464:	10bfe004 	addi	r2,r2,-128
  181468:	e0fffa17 	ldw	r3,-24(fp)
  18146c:	18c00044 	addi	r3,r3,1
  181470:	e0fffa15 	stw	r3,-24(fp)
  181474:	1009883a 	mov	r4,r2
  181478:	01814d80 	call	1814d8 <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
  18147c:	e0bffa17 	ldw	r2,-24(fp)
  181480:	10800003 	ldbu	r2,0(r2)
  181484:	10803fcc 	andi	r2,r2,255
  181488:	1080201c 	xori	r2,r2,128
  18148c:	10bfe004 	addi	r2,r2,-128
  181490:	103ff01e 	bne	r2,zero,181454 <alt_printf+0x1c0>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
  181494:	e0bff717 	ldw	r2,-36(fp)
  181498:	10800003 	ldbu	r2,0(r2)
  18149c:	e0bff805 	stb	r2,-32(fp)
  1814a0:	e0bff807 	ldb	r2,-32(fp)
  1814a4:	1004c03a 	cmpne	r2,r2,zero
  1814a8:	e0fff717 	ldw	r3,-36(fp)
  1814ac:	18c00044 	addi	r3,r3,1
  1814b0:	e0fff715 	stw	r3,-36(fp)
  1814b4:	10803fcc 	andi	r2,r2,255
  1814b8:	103f831e 	bne	r2,zero,1812c8 <alt_printf+0x34>
  1814bc:	00000106 	br	1814c4 <alt_printf+0x230>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
  1814c0:	0001883a 	nop
            }
        }
    }
}
  1814c4:	e037883a 	mov	sp,fp
  1814c8:	dfc00117 	ldw	ra,4(sp)
  1814cc:	df000017 	ldw	fp,0(sp)
  1814d0:	dec00504 	addi	sp,sp,20
  1814d4:	f800283a 	ret

001814d8 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
  1814d8:	defffd04 	addi	sp,sp,-12
  1814dc:	dfc00215 	stw	ra,8(sp)
  1814e0:	df000115 	stw	fp,4(sp)
  1814e4:	df000104 	addi	fp,sp,4
  1814e8:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
  1814ec:	00800674 	movhi	r2,25
  1814f0:	10aa8a04 	addi	r2,r2,-21976
  1814f4:	10800017 	ldw	r2,0(r2)
  1814f8:	10800217 	ldw	r2,8(r2)
  1814fc:	e13fff17 	ldw	r4,-4(fp)
  181500:	100b883a 	mov	r5,r2
  181504:	01868340 	call	186834 <putc>
#endif
}
  181508:	e037883a 	mov	sp,fp
  18150c:	dfc00117 	ldw	ra,4(sp)
  181510:	df000017 	ldw	fp,0(sp)
  181514:	dec00204 	addi	sp,sp,8
  181518:	f800283a 	ret

0018151c <alt_putstr>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided fputs() routine.
 */
int 
alt_putstr(const char* str)
{
  18151c:	defffd04 	addi	sp,sp,-12
  181520:	dfc00215 	stw	ra,8(sp)
  181524:	df000115 	stw	fp,4(sp)
  181528:	df000104 	addi	fp,sp,4
  18152c:	e13fff15 	stw	r4,-4(fp)
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
#else
    return fputs(str, stdout);
  181530:	00800674 	movhi	r2,25
  181534:	10aa8a04 	addi	r2,r2,-21976
  181538:	10800017 	ldw	r2,0(r2)
  18153c:	10800217 	ldw	r2,8(r2)
  181540:	e13fff17 	ldw	r4,-4(fp)
  181544:	100b883a 	mov	r5,r2
  181548:	01856b40 	call	1856b4 <fputs>
#endif
}
  18154c:	e037883a 	mov	sp,fp
  181550:	dfc00117 	ldw	ra,4(sp)
  181554:	df000017 	ldw	fp,0(sp)
  181558:	dec00204 	addi	sp,sp,8
  18155c:	f800283a 	ret

00181560 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  181560:	defffd04 	addi	sp,sp,-12
  181564:	dfc00215 	stw	ra,8(sp)
  181568:	df000115 	stw	fp,4(sp)
  18156c:	df000104 	addi	fp,sp,4
  181570:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
  181574:	e13fff17 	ldw	r4,-4(fp)
  181578:	01400674 	movhi	r5,25
  18157c:	296a8204 	addi	r5,r5,-22008
  181580:	01847bc0 	call	1847bc <alt_dev_llist_insert>
}
  181584:	e037883a 	mov	sp,fp
  181588:	dfc00117 	ldw	ra,4(sp)
  18158c:	df000017 	ldw	fp,0(sp)
  181590:	dec00204 	addi	sp,sp,8
  181594:	f800283a 	ret

00181598 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  181598:	defffd04 	addi	sp,sp,-12
  18159c:	dfc00215 	stw	ra,8(sp)
  1815a0:	df000115 	stw	fp,4(sp)
  1815a4:	df000104 	addi	fp,sp,4
  1815a8:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( CPU, cpu);
  1815ac:	01852040 	call	185204 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  1815b0:	00800044 	movi	r2,1
  1815b4:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  1815b8:	e037883a 	mov	sp,fp
  1815bc:	dfc00117 	ldw	ra,4(sp)
  1815c0:	df000017 	ldw	fp,0(sp)
  1815c4:	dec00204 	addi	sp,sp,8
  1815c8:	f800283a 	ret

001815cc <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  1815cc:	defffe04 	addi	sp,sp,-8
  1815d0:	dfc00115 	stw	ra,4(sp)
  1815d4:	df000015 	stw	fp,0(sp)
  1815d8:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
  1815dc:	01000834 	movhi	r4,32
  1815e0:	21040804 	addi	r4,r4,4128
  1815e4:	000b883a 	mov	r5,zero
  1815e8:	01800044 	movi	r6,1
  1815ec:	01c0fa04 	movi	r7,1000
  1815f0:	01821240 	call	182124 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
  1815f4:	01000674 	movhi	r4,25
  1815f8:	2123d504 	addi	r4,r4,-28844
  1815fc:	000b883a 	mov	r5,zero
  181600:	000d883a 	mov	r6,zero
  181604:	01817b00 	call	1817b0 <altera_avalon_jtag_uart_init>
  181608:	01000674 	movhi	r4,25
  18160c:	2123cb04 	addi	r4,r4,-28884
  181610:	01815600 	call	181560 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
  181614:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( UART_0, uart_0);
  181618:	01000674 	movhi	r4,25
  18161c:	2127ed04 	addi	r4,r4,-24652
  181620:	000b883a 	mov	r5,zero
  181624:	01800084 	movi	r6,2
  181628:	01822bc0 	call	1822bc <altera_avalon_uart_init>
  18162c:	01000674 	movhi	r4,25
  181630:	2127e304 	addi	r4,r4,-24692
  181634:	01815600 	call	181560 <alt_dev_reg>
}
  181638:	e037883a 	mov	sp,fp
  18163c:	dfc00117 	ldw	ra,4(sp)
  181640:	df000017 	ldw	fp,0(sp)
  181644:	dec00204 	addi	sp,sp,8
  181648:	f800283a 	ret

0018164c <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  18164c:	defffa04 	addi	sp,sp,-24
  181650:	dfc00515 	stw	ra,20(sp)
  181654:	df000415 	stw	fp,16(sp)
  181658:	df000404 	addi	fp,sp,16
  18165c:	e13ffd15 	stw	r4,-12(fp)
  181660:	e17ffe15 	stw	r5,-8(fp)
  181664:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  181668:	e0bffd17 	ldw	r2,-12(fp)
  18166c:	10800017 	ldw	r2,0(r2)
  181670:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  181674:	e0bffc17 	ldw	r2,-16(fp)
  181678:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
  18167c:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  181680:	10800217 	ldw	r2,8(r2)
  181684:	1809883a 	mov	r4,r3
  181688:	e17ffe17 	ldw	r5,-8(fp)
  18168c:	e1bfff17 	ldw	r6,-4(fp)
  181690:	100f883a 	mov	r7,r2
  181694:	0181c740 	call	181c74 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
  181698:	e037883a 	mov	sp,fp
  18169c:	dfc00117 	ldw	ra,4(sp)
  1816a0:	df000017 	ldw	fp,0(sp)
  1816a4:	dec00204 	addi	sp,sp,8
  1816a8:	f800283a 	ret

001816ac <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  1816ac:	defffa04 	addi	sp,sp,-24
  1816b0:	dfc00515 	stw	ra,20(sp)
  1816b4:	df000415 	stw	fp,16(sp)
  1816b8:	df000404 	addi	fp,sp,16
  1816bc:	e13ffd15 	stw	r4,-12(fp)
  1816c0:	e17ffe15 	stw	r5,-8(fp)
  1816c4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  1816c8:	e0bffd17 	ldw	r2,-12(fp)
  1816cc:	10800017 	ldw	r2,0(r2)
  1816d0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  1816d4:	e0bffc17 	ldw	r2,-16(fp)
  1816d8:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
  1816dc:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  1816e0:	10800217 	ldw	r2,8(r2)
  1816e4:	1809883a 	mov	r4,r3
  1816e8:	e17ffe17 	ldw	r5,-8(fp)
  1816ec:	e1bfff17 	ldw	r6,-4(fp)
  1816f0:	100f883a 	mov	r7,r2
  1816f4:	0181e8c0 	call	181e8c <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
  1816f8:	e037883a 	mov	sp,fp
  1816fc:	dfc00117 	ldw	ra,4(sp)
  181700:	df000017 	ldw	fp,0(sp)
  181704:	dec00204 	addi	sp,sp,8
  181708:	f800283a 	ret

0018170c <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
  18170c:	defffc04 	addi	sp,sp,-16
  181710:	dfc00315 	stw	ra,12(sp)
  181714:	df000215 	stw	fp,8(sp)
  181718:	df000204 	addi	fp,sp,8
  18171c:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  181720:	e0bfff17 	ldw	r2,-4(fp)
  181724:	10800017 	ldw	r2,0(r2)
  181728:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
  18172c:	e0bffe17 	ldw	r2,-8(fp)
  181730:	10c00a04 	addi	r3,r2,40
  181734:	e0bfff17 	ldw	r2,-4(fp)
  181738:	10800217 	ldw	r2,8(r2)
  18173c:	1809883a 	mov	r4,r3
  181740:	100b883a 	mov	r5,r2
  181744:	0181b180 	call	181b18 <altera_avalon_jtag_uart_close>
}
  181748:	e037883a 	mov	sp,fp
  18174c:	dfc00117 	ldw	ra,4(sp)
  181750:	df000017 	ldw	fp,0(sp)
  181754:	dec00204 	addi	sp,sp,8
  181758:	f800283a 	ret

0018175c <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
  18175c:	defffa04 	addi	sp,sp,-24
  181760:	dfc00515 	stw	ra,20(sp)
  181764:	df000415 	stw	fp,16(sp)
  181768:	df000404 	addi	fp,sp,16
  18176c:	e13ffd15 	stw	r4,-12(fp)
  181770:	e17ffe15 	stw	r5,-8(fp)
  181774:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
  181778:	e0bffd17 	ldw	r2,-12(fp)
  18177c:	10800017 	ldw	r2,0(r2)
  181780:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
  181784:	e0bffc17 	ldw	r2,-16(fp)
  181788:	10800a04 	addi	r2,r2,40
  18178c:	1009883a 	mov	r4,r2
  181790:	e17ffe17 	ldw	r5,-8(fp)
  181794:	e1bfff17 	ldw	r6,-4(fp)
  181798:	0181b800 	call	181b80 <altera_avalon_jtag_uart_ioctl>
}
  18179c:	e037883a 	mov	sp,fp
  1817a0:	dfc00117 	ldw	ra,4(sp)
  1817a4:	df000017 	ldw	fp,0(sp)
  1817a8:	dec00204 	addi	sp,sp,8
  1817ac:	f800283a 	ret

001817b0 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
  1817b0:	defffa04 	addi	sp,sp,-24
  1817b4:	dfc00515 	stw	ra,20(sp)
  1817b8:	df000415 	stw	fp,16(sp)
  1817bc:	df000404 	addi	fp,sp,16
  1817c0:	e13ffd15 	stw	r4,-12(fp)
  1817c4:	e17ffe15 	stw	r5,-8(fp)
  1817c8:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  1817cc:	e0bffd17 	ldw	r2,-12(fp)
  1817d0:	00c00044 	movi	r3,1
  1817d4:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
  1817d8:	e0bffd17 	ldw	r2,-12(fp)
  1817dc:	10800017 	ldw	r2,0(r2)
  1817e0:	10800104 	addi	r2,r2,4
  1817e4:	e0fffd17 	ldw	r3,-12(fp)
  1817e8:	18c00817 	ldw	r3,32(r3)
  1817ec:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
  1817f0:	e0fffe17 	ldw	r3,-8(fp)
  1817f4:	e0bfff17 	ldw	r2,-4(fp)
  1817f8:	d8000015 	stw	zero,0(sp)
  1817fc:	1809883a 	mov	r4,r3
  181800:	100b883a 	mov	r5,r2
  181804:	01800634 	movhi	r6,24
  181808:	31861c04 	addi	r6,r6,6256
  18180c:	e1fffd17 	ldw	r7,-12(fp)
  181810:	01849300 	call	184930 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
  181814:	e0bffd17 	ldw	r2,-12(fp)
  181818:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
  18181c:	e0bffd17 	ldw	r2,-12(fp)
  181820:	10c00204 	addi	r3,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  181824:	00800674 	movhi	r2,25
  181828:	10b15804 	addi	r2,r2,-15008
  18182c:	10800017 	ldw	r2,0(r2)
  181830:	1809883a 	mov	r4,r3
  181834:	100b883a 	mov	r5,r2
  181838:	01800634 	movhi	r6,24
  18183c:	31869d04 	addi	r6,r6,6772
  181840:	e1fffd17 	ldw	r7,-12(fp)
  181844:	01844c80 	call	1844c8 <alt_alarm_start>
  181848:	1000040e 	bge	r2,zero,18185c <altera_avalon_jtag_uart_init+0xac>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
  18184c:	e0bffd17 	ldw	r2,-12(fp)
  181850:	00e00034 	movhi	r3,32768
  181854:	18ffffc4 	addi	r3,r3,-1
  181858:	10c00115 	stw	r3,4(r2)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
  18185c:	e037883a 	mov	sp,fp
  181860:	dfc00117 	ldw	ra,4(sp)
  181864:	df000017 	ldw	fp,0(sp)
  181868:	dec00204 	addi	sp,sp,8
  18186c:	f800283a 	ret

00181870 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
  181870:	defff804 	addi	sp,sp,-32
  181874:	df000715 	stw	fp,28(sp)
  181878:	df000704 	addi	fp,sp,28
  18187c:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
  181880:	e0bfff17 	ldw	r2,-4(fp)
  181884:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
  181888:	e0bffb17 	ldw	r2,-20(fp)
  18188c:	10800017 	ldw	r2,0(r2)
  181890:	e0bffc15 	stw	r2,-16(fp)
  181894:	00000106 	br	18189c <altera_avalon_jtag_uart_irq+0x2c>
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
  181898:	0001883a 	nop
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  18189c:	e0bffc17 	ldw	r2,-16(fp)
  1818a0:	10800104 	addi	r2,r2,4
  1818a4:	10800037 	ldwio	r2,0(r2)
  1818a8:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
  1818ac:	e0bffd17 	ldw	r2,-12(fp)
  1818b0:	1080c00c 	andi	r2,r2,768
  1818b4:	10006a26 	beq	r2,zero,181a60 <altera_avalon_jtag_uart_irq+0x1f0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
  1818b8:	e0bffd17 	ldw	r2,-12(fp)
  1818bc:	1080400c 	andi	r2,r2,256
  1818c0:	10003326 	beq	r2,zero,181990 <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
  1818c4:	00800074 	movhi	r2,1
  1818c8:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  1818cc:	e0bffb17 	ldw	r2,-20(fp)
  1818d0:	10800a17 	ldw	r2,40(r2)
  1818d4:	10800044 	addi	r2,r2,1
  1818d8:	1081ffcc 	andi	r2,r2,2047
  1818dc:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
  1818e0:	e0bffb17 	ldw	r2,-20(fp)
  1818e4:	10c00b17 	ldw	r3,44(r2)
  1818e8:	e0bffe17 	ldw	r2,-8(fp)
  1818ec:	18801426 	beq	r3,r2,181940 <altera_avalon_jtag_uart_irq+0xd0>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
  1818f0:	e0bffc17 	ldw	r2,-16(fp)
  1818f4:	10800037 	ldwio	r2,0(r2)
  1818f8:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
  1818fc:	e0bff917 	ldw	r2,-28(fp)
  181900:	10a0000c 	andi	r2,r2,32768
  181904:	10001026 	beq	r2,zero,181948 <altera_avalon_jtag_uart_irq+0xd8>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
  181908:	e0bffb17 	ldw	r2,-20(fp)
  18190c:	10800a17 	ldw	r2,40(r2)
  181910:	e0fff917 	ldw	r3,-28(fp)
  181914:	e13ffb17 	ldw	r4,-20(fp)
  181918:	2085883a 	add	r2,r4,r2
  18191c:	10800e04 	addi	r2,r2,56
  181920:	10c00005 	stb	r3,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  181924:	e0bffb17 	ldw	r2,-20(fp)
  181928:	10800a17 	ldw	r2,40(r2)
  18192c:	10800044 	addi	r2,r2,1
  181930:	10c1ffcc 	andi	r3,r2,2047
  181934:	e0bffb17 	ldw	r2,-20(fp)
  181938:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
  18193c:	003fe306 	br	1818cc <altera_avalon_jtag_uart_irq+0x5c>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
  181940:	0001883a 	nop
  181944:	00000106 	br	18194c <altera_avalon_jtag_uart_irq+0xdc>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
  181948:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
  18194c:	e0bff917 	ldw	r2,-28(fp)
  181950:	10bfffec 	andhi	r2,r2,65535
  181954:	10000e26 	beq	r2,zero,181990 <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  181958:	e0bffb17 	ldw	r2,-20(fp)
  18195c:	10c00817 	ldw	r3,32(r2)
  181960:	00bfff84 	movi	r2,-2
  181964:	1886703a 	and	r3,r3,r2
  181968:	e0bffb17 	ldw	r2,-20(fp)
  18196c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
  181970:	e0bffc17 	ldw	r2,-16(fp)
  181974:	10800104 	addi	r2,r2,4
  181978:	e0fffb17 	ldw	r3,-20(fp)
  18197c:	18c00817 	ldw	r3,32(r3)
  181980:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  181984:	e0bffc17 	ldw	r2,-16(fp)
  181988:	10800104 	addi	r2,r2,4
  18198c:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
  181990:	e0bffd17 	ldw	r2,-12(fp)
  181994:	1080800c 	andi	r2,r2,512
  181998:	103fbf26 	beq	r2,zero,181898 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
  18199c:	e0bffd17 	ldw	r2,-12(fp)
  1819a0:	1004d43a 	srli	r2,r2,16
  1819a4:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
  1819a8:	00001406 	br	1819fc <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
  1819ac:	e0bffc17 	ldw	r2,-16(fp)
  1819b0:	e0fffb17 	ldw	r3,-20(fp)
  1819b4:	18c00d17 	ldw	r3,52(r3)
  1819b8:	e13ffb17 	ldw	r4,-20(fp)
  1819bc:	20c7883a 	add	r3,r4,r3
  1819c0:	18c20e04 	addi	r3,r3,2104
  1819c4:	18c00003 	ldbu	r3,0(r3)
  1819c8:	18c03fcc 	andi	r3,r3,255
  1819cc:	18c0201c 	xori	r3,r3,128
  1819d0:	18ffe004 	addi	r3,r3,-128
  1819d4:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  1819d8:	e0bffb17 	ldw	r2,-20(fp)
  1819dc:	10800d17 	ldw	r2,52(r2)
  1819e0:	10800044 	addi	r2,r2,1
  1819e4:	10c1ffcc 	andi	r3,r2,2047
  1819e8:	e0bffb17 	ldw	r2,-20(fp)
  1819ec:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
  1819f0:	e0bffa17 	ldw	r2,-24(fp)
  1819f4:	10bfffc4 	addi	r2,r2,-1
  1819f8:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
  1819fc:	e0bffa17 	ldw	r2,-24(fp)
  181a00:	10000526 	beq	r2,zero,181a18 <altera_avalon_jtag_uart_irq+0x1a8>
  181a04:	e0bffb17 	ldw	r2,-20(fp)
  181a08:	10c00d17 	ldw	r3,52(r2)
  181a0c:	e0bffb17 	ldw	r2,-20(fp)
  181a10:	10800c17 	ldw	r2,48(r2)
  181a14:	18bfe51e 	bne	r3,r2,1819ac <altera_avalon_jtag_uart_irq+0x13c>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
  181a18:	e0bffa17 	ldw	r2,-24(fp)
  181a1c:	103f9e26 	beq	r2,zero,181898 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  181a20:	e0bffb17 	ldw	r2,-20(fp)
  181a24:	10c00817 	ldw	r3,32(r2)
  181a28:	00bfff44 	movi	r2,-3
  181a2c:	1886703a 	and	r3,r3,r2
  181a30:	e0bffb17 	ldw	r2,-20(fp)
  181a34:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  181a38:	e0bffb17 	ldw	r2,-20(fp)
  181a3c:	10800017 	ldw	r2,0(r2)
  181a40:	10800104 	addi	r2,r2,4
  181a44:	e0fffb17 	ldw	r3,-20(fp)
  181a48:	18c00817 	ldw	r3,32(r3)
  181a4c:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  181a50:	e0bffc17 	ldw	r2,-16(fp)
  181a54:	10800104 	addi	r2,r2,4
  181a58:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
  181a5c:	003f8e06 	br	181898 <altera_avalon_jtag_uart_irq+0x28>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
  181a60:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
  181a64:	e037883a 	mov	sp,fp
  181a68:	df000017 	ldw	fp,0(sp)
  181a6c:	dec00104 	addi	sp,sp,4
  181a70:	f800283a 	ret

00181a74 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
  181a74:	defffc04 	addi	sp,sp,-16
  181a78:	df000315 	stw	fp,12(sp)
  181a7c:	df000304 	addi	fp,sp,12
  181a80:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
  181a84:	e0bfff17 	ldw	r2,-4(fp)
  181a88:	e0bffd15 	stw	r2,-12(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
  181a8c:	e0bffd17 	ldw	r2,-12(fp)
  181a90:	10800017 	ldw	r2,0(r2)
  181a94:	10800104 	addi	r2,r2,4
  181a98:	10800037 	ldwio	r2,0(r2)
  181a9c:	e0bffe15 	stw	r2,-8(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
  181aa0:	e0bffe17 	ldw	r2,-8(fp)
  181aa4:	1081000c 	andi	r2,r2,1024
  181aa8:	10000a26 	beq	r2,zero,181ad4 <altera_avalon_jtag_uart_timeout+0x60>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
  181aac:	e0bffd17 	ldw	r2,-12(fp)
  181ab0:	10800017 	ldw	r2,0(r2)
  181ab4:	10800104 	addi	r2,r2,4
  181ab8:	e0fffd17 	ldw	r3,-12(fp)
  181abc:	18c00817 	ldw	r3,32(r3)
  181ac0:	18c10014 	ori	r3,r3,1024
  181ac4:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
  181ac8:	e0bffd17 	ldw	r2,-12(fp)
  181acc:	10000915 	stw	zero,36(r2)
  181ad0:	00000a06 	br	181afc <altera_avalon_jtag_uart_timeout+0x88>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
  181ad4:	e0bffd17 	ldw	r2,-12(fp)
  181ad8:	10800917 	ldw	r2,36(r2)
  181adc:	00e00034 	movhi	r3,32768
  181ae0:	18ffff04 	addi	r3,r3,-4
  181ae4:	18800536 	bltu	r3,r2,181afc <altera_avalon_jtag_uart_timeout+0x88>
    sp->host_inactive++;
  181ae8:	e0bffd17 	ldw	r2,-12(fp)
  181aec:	10800917 	ldw	r2,36(r2)
  181af0:	10c00044 	addi	r3,r2,1
  181af4:	e0bffd17 	ldw	r2,-12(fp)
  181af8:	10c00915 	stw	r3,36(r2)
  181afc:	00800674 	movhi	r2,25
  181b00:	10b15804 	addi	r2,r2,-15008
  181b04:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
  181b08:	e037883a 	mov	sp,fp
  181b0c:	df000017 	ldw	fp,0(sp)
  181b10:	dec00104 	addi	sp,sp,4
  181b14:	f800283a 	ret

00181b18 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
  181b18:	defffd04 	addi	sp,sp,-12
  181b1c:	df000215 	stw	fp,8(sp)
  181b20:	df000204 	addi	fp,sp,8
  181b24:	e13ffe15 	stw	r4,-8(fp)
  181b28:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  181b2c:	00000506 	br	181b44 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
  181b30:	e0bfff17 	ldw	r2,-4(fp)
  181b34:	1090000c 	andi	r2,r2,16384
  181b38:	10000226 	beq	r2,zero,181b44 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
  181b3c:	00bffd44 	movi	r2,-11
  181b40:	00000b06 	br	181b70 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  181b44:	e0bffe17 	ldw	r2,-8(fp)
  181b48:	10c00d17 	ldw	r3,52(r2)
  181b4c:	e0bffe17 	ldw	r2,-8(fp)
  181b50:	10800c17 	ldw	r2,48(r2)
  181b54:	18800526 	beq	r3,r2,181b6c <altera_avalon_jtag_uart_close+0x54>
  181b58:	e0bffe17 	ldw	r2,-8(fp)
  181b5c:	10c00917 	ldw	r3,36(r2)
  181b60:	e0bffe17 	ldw	r2,-8(fp)
  181b64:	10800117 	ldw	r2,4(r2)
  181b68:	18bff136 	bltu	r3,r2,181b30 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
  181b6c:	0005883a 	mov	r2,zero
}
  181b70:	e037883a 	mov	sp,fp
  181b74:	df000017 	ldw	fp,0(sp)
  181b78:	dec00104 	addi	sp,sp,4
  181b7c:	f800283a 	ret

00181b80 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
  181b80:	defffa04 	addi	sp,sp,-24
  181b84:	df000515 	stw	fp,20(sp)
  181b88:	df000504 	addi	fp,sp,20
  181b8c:	e13ffd15 	stw	r4,-12(fp)
  181b90:	e17ffe15 	stw	r5,-8(fp)
  181b94:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
  181b98:	00bff9c4 	movi	r2,-25
  181b9c:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
  181ba0:	e0bffe17 	ldw	r2,-8(fp)
  181ba4:	10da8060 	cmpeqi	r3,r2,27137
  181ba8:	1800031e 	bne	r3,zero,181bb8 <altera_avalon_jtag_uart_ioctl+0x38>
  181bac:	109a80a0 	cmpeqi	r2,r2,27138
  181bb0:	1000181e 	bne	r2,zero,181c14 <altera_avalon_jtag_uart_ioctl+0x94>
  181bb4:	00002606 	br	181c50 <altera_avalon_jtag_uart_ioctl+0xd0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
  181bb8:	e0bffd17 	ldw	r2,-12(fp)
  181bbc:	10c00117 	ldw	r3,4(r2)
  181bc0:	00a00034 	movhi	r2,32768
  181bc4:	10bfffc4 	addi	r2,r2,-1
  181bc8:	18802226 	beq	r3,r2,181c54 <altera_avalon_jtag_uart_ioctl+0xd4>
    {
      int timeout = *((int *)arg);
  181bcc:	e0bfff17 	ldw	r2,-4(fp)
  181bd0:	10800017 	ldw	r2,0(r2)
  181bd4:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
  181bd8:	e0bffc17 	ldw	r2,-16(fp)
  181bdc:	10800090 	cmplti	r2,r2,2
  181be0:	1000061e 	bne	r2,zero,181bfc <altera_avalon_jtag_uart_ioctl+0x7c>
  181be4:	e0fffc17 	ldw	r3,-16(fp)
  181be8:	00a00034 	movhi	r2,32768
  181bec:	10bfffc4 	addi	r2,r2,-1
  181bf0:	18800226 	beq	r3,r2,181bfc <altera_avalon_jtag_uart_ioctl+0x7c>
  181bf4:	e0bffc17 	ldw	r2,-16(fp)
  181bf8:	00000206 	br	181c04 <altera_avalon_jtag_uart_ioctl+0x84>
  181bfc:	00a00034 	movhi	r2,32768
  181c00:	10bfff84 	addi	r2,r2,-2
  181c04:	e0fffd17 	ldw	r3,-12(fp)
  181c08:	18800115 	stw	r2,4(r3)
      rc = 0;
  181c0c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
  181c10:	00001006 	br	181c54 <altera_avalon_jtag_uart_ioctl+0xd4>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
  181c14:	e0bffd17 	ldw	r2,-12(fp)
  181c18:	10c00117 	ldw	r3,4(r2)
  181c1c:	00a00034 	movhi	r2,32768
  181c20:	10bfffc4 	addi	r2,r2,-1
  181c24:	18800d26 	beq	r3,r2,181c5c <altera_avalon_jtag_uart_ioctl+0xdc>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
  181c28:	e0bffd17 	ldw	r2,-12(fp)
  181c2c:	10c00917 	ldw	r3,36(r2)
  181c30:	e0bffd17 	ldw	r2,-12(fp)
  181c34:	10800117 	ldw	r2,4(r2)
  181c38:	1885803a 	cmpltu	r2,r3,r2
  181c3c:	10c03fcc 	andi	r3,r2,255
  181c40:	e0bfff17 	ldw	r2,-4(fp)
  181c44:	10c00015 	stw	r3,0(r2)
      rc = 0;
  181c48:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
  181c4c:	00000306 	br	181c5c <altera_avalon_jtag_uart_ioctl+0xdc>

  default:
    break;
  181c50:	00000306 	br	181c60 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
  181c54:	0001883a 	nop
  181c58:	00000106 	br	181c60 <altera_avalon_jtag_uart_ioctl+0xe0>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
  181c5c:	0001883a 	nop

  default:
    break;
  }

  return rc;
  181c60:	e0bffb17 	ldw	r2,-20(fp)
}
  181c64:	e037883a 	mov	sp,fp
  181c68:	df000017 	ldw	fp,0(sp)
  181c6c:	dec00104 	addi	sp,sp,4
  181c70:	f800283a 	ret

00181c74 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
  181c74:	defff304 	addi	sp,sp,-52
  181c78:	dfc00c15 	stw	ra,48(sp)
  181c7c:	df000b15 	stw	fp,44(sp)
  181c80:	df000b04 	addi	fp,sp,44
  181c84:	e13ffc15 	stw	r4,-16(fp)
  181c88:	e17ffd15 	stw	r5,-12(fp)
  181c8c:	e1bffe15 	stw	r6,-8(fp)
  181c90:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
  181c94:	e0bffd17 	ldw	r2,-12(fp)
  181c98:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  181c9c:	00004706 	br	181dbc <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
  181ca0:	e0bffc17 	ldw	r2,-16(fp)
  181ca4:	10800a17 	ldw	r2,40(r2)
  181ca8:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
  181cac:	e0bffc17 	ldw	r2,-16(fp)
  181cb0:	10800b17 	ldw	r2,44(r2)
  181cb4:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
  181cb8:	e0fff717 	ldw	r3,-36(fp)
  181cbc:	e0bff817 	ldw	r2,-32(fp)
  181cc0:	18800536 	bltu	r3,r2,181cd8 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
  181cc4:	e0fff717 	ldw	r3,-36(fp)
  181cc8:	e0bff817 	ldw	r2,-32(fp)
  181ccc:	1885c83a 	sub	r2,r3,r2
  181cd0:	e0bff615 	stw	r2,-40(fp)
  181cd4:	00000406 	br	181ce8 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
  181cd8:	00c20004 	movi	r3,2048
  181cdc:	e0bff817 	ldw	r2,-32(fp)
  181ce0:	1885c83a 	sub	r2,r3,r2
  181ce4:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
  181ce8:	e0bff617 	ldw	r2,-40(fp)
  181cec:	10001e26 	beq	r2,zero,181d68 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
  181cf0:	e0fffe17 	ldw	r3,-8(fp)
  181cf4:	e0bff617 	ldw	r2,-40(fp)
  181cf8:	1880022e 	bgeu	r3,r2,181d04 <altera_avalon_jtag_uart_read+0x90>
        n = space;
  181cfc:	e0bffe17 	ldw	r2,-8(fp)
  181d00:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
  181d04:	e0bff817 	ldw	r2,-32(fp)
  181d08:	10800e04 	addi	r2,r2,56
  181d0c:	e0fffc17 	ldw	r3,-16(fp)
  181d10:	1885883a 	add	r2,r3,r2
  181d14:	e13ff517 	ldw	r4,-44(fp)
  181d18:	100b883a 	mov	r5,r2
  181d1c:	e1bff617 	ldw	r6,-40(fp)
  181d20:	01864ac0 	call	1864ac <memcpy>
      ptr   += n;
  181d24:	e0fff517 	ldw	r3,-44(fp)
  181d28:	e0bff617 	ldw	r2,-40(fp)
  181d2c:	1885883a 	add	r2,r3,r2
  181d30:	e0bff515 	stw	r2,-44(fp)
      space -= n;
  181d34:	e0fffe17 	ldw	r3,-8(fp)
  181d38:	e0bff617 	ldw	r2,-40(fp)
  181d3c:	1885c83a 	sub	r2,r3,r2
  181d40:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  181d44:	e0fff817 	ldw	r3,-32(fp)
  181d48:	e0bff617 	ldw	r2,-40(fp)
  181d4c:	1885883a 	add	r2,r3,r2
  181d50:	10c1ffcc 	andi	r3,r2,2047
  181d54:	e0bffc17 	ldw	r2,-16(fp)
  181d58:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
  181d5c:	e0bffe17 	ldw	r2,-8(fp)
  181d60:	00bfcf16 	blt	zero,r2,181ca0 <altera_avalon_jtag_uart_read+0x2c>
  181d64:	00000106 	br	181d6c <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
  181d68:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
  181d6c:	e0fff517 	ldw	r3,-44(fp)
  181d70:	e0bffd17 	ldw	r2,-12(fp)
  181d74:	1880141e 	bne	r3,r2,181dc8 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
  181d78:	e0bfff17 	ldw	r2,-4(fp)
  181d7c:	1090000c 	andi	r2,r2,16384
  181d80:	1000131e 	bne	r2,zero,181dd0 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
  181d84:	0001883a 	nop
  181d88:	e0bffc17 	ldw	r2,-16(fp)
  181d8c:	10c00a17 	ldw	r3,40(r2)
  181d90:	e0bff717 	ldw	r2,-36(fp)
  181d94:	1880051e 	bne	r3,r2,181dac <altera_avalon_jtag_uart_read+0x138>
  181d98:	e0bffc17 	ldw	r2,-16(fp)
  181d9c:	10c00917 	ldw	r3,36(r2)
  181da0:	e0bffc17 	ldw	r2,-16(fp)
  181da4:	10800117 	ldw	r2,4(r2)
  181da8:	18bff736 	bltu	r3,r2,181d88 <altera_avalon_jtag_uart_read+0x114>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
  181dac:	e0bffc17 	ldw	r2,-16(fp)
  181db0:	10c00a17 	ldw	r3,40(r2)
  181db4:	e0bff717 	ldw	r2,-36(fp)
  181db8:	18800726 	beq	r3,r2,181dd8 <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  181dbc:	e0bffe17 	ldw	r2,-8(fp)
  181dc0:	00bfb716 	blt	zero,r2,181ca0 <altera_avalon_jtag_uart_read+0x2c>
  181dc4:	00000506 	br	181ddc <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
  181dc8:	0001883a 	nop
  181dcc:	00000306 	br	181ddc <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
  181dd0:	0001883a 	nop
  181dd4:	00000106 	br	181ddc <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
  181dd8:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
  181ddc:	e0fff517 	ldw	r3,-44(fp)
  181de0:	e0bffd17 	ldw	r2,-12(fp)
  181de4:	18801726 	beq	r3,r2,181e44 <altera_avalon_jtag_uart_read+0x1d0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  181de8:	0005303a 	rdctl	r2,status
  181dec:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  181df0:	e0fffa17 	ldw	r3,-24(fp)
  181df4:	00bfff84 	movi	r2,-2
  181df8:	1884703a 	and	r2,r3,r2
  181dfc:	1001703a 	wrctl	status,r2
  
  return context;
  181e00:	e0bffa17 	ldw	r2,-24(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
  181e04:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  181e08:	e0bffc17 	ldw	r2,-16(fp)
  181e0c:	10800817 	ldw	r2,32(r2)
  181e10:	10c00054 	ori	r3,r2,1
  181e14:	e0bffc17 	ldw	r2,-16(fp)
  181e18:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  181e1c:	e0bffc17 	ldw	r2,-16(fp)
  181e20:	10800017 	ldw	r2,0(r2)
  181e24:	10800104 	addi	r2,r2,4
  181e28:	e0fffc17 	ldw	r3,-16(fp)
  181e2c:	18c00817 	ldw	r3,32(r3)
  181e30:	10c00035 	stwio	r3,0(r2)
  181e34:	e0bff917 	ldw	r2,-28(fp)
  181e38:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  181e3c:	e0bffb17 	ldw	r2,-20(fp)
  181e40:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
  181e44:	e0fff517 	ldw	r3,-44(fp)
  181e48:	e0bffd17 	ldw	r2,-12(fp)
  181e4c:	18800426 	beq	r3,r2,181e60 <altera_avalon_jtag_uart_read+0x1ec>
    return ptr - buffer;
  181e50:	e0fff517 	ldw	r3,-44(fp)
  181e54:	e0bffd17 	ldw	r2,-12(fp)
  181e58:	1885c83a 	sub	r2,r3,r2
  181e5c:	00000606 	br	181e78 <altera_avalon_jtag_uart_read+0x204>
  else if (flags & O_NONBLOCK)
  181e60:	e0bfff17 	ldw	r2,-4(fp)
  181e64:	1090000c 	andi	r2,r2,16384
  181e68:	10000226 	beq	r2,zero,181e74 <altera_avalon_jtag_uart_read+0x200>
    return -EWOULDBLOCK;
  181e6c:	00bffd44 	movi	r2,-11
  181e70:	00000106 	br	181e78 <altera_avalon_jtag_uart_read+0x204>
  else
    return -EIO;
  181e74:	00bffec4 	movi	r2,-5
}
  181e78:	e037883a 	mov	sp,fp
  181e7c:	dfc00117 	ldw	ra,4(sp)
  181e80:	df000017 	ldw	fp,0(sp)
  181e84:	dec00204 	addi	sp,sp,8
  181e88:	f800283a 	ret

00181e8c <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  181e8c:	defff304 	addi	sp,sp,-52
  181e90:	dfc00c15 	stw	ra,48(sp)
  181e94:	df000b15 	stw	fp,44(sp)
  181e98:	df000b04 	addi	fp,sp,44
  181e9c:	e13ffc15 	stw	r4,-16(fp)
  181ea0:	e17ffd15 	stw	r5,-12(fp)
  181ea4:	e1bffe15 	stw	r6,-8(fp)
  181ea8:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
  181eac:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
  181eb0:	e0bffd17 	ldw	r2,-12(fp)
  181eb4:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  181eb8:	00003706 	br	181f98 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
  181ebc:	e0bffc17 	ldw	r2,-16(fp)
  181ec0:	10800c17 	ldw	r2,48(r2)
  181ec4:	e0bff815 	stw	r2,-32(fp)
      out = sp->tx_out;
  181ec8:	e0bffc17 	ldw	r2,-16(fp)
  181ecc:	10800d17 	ldw	r2,52(r2)
  181ed0:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
  181ed4:	e0fff817 	ldw	r3,-32(fp)
  181ed8:	e0bff517 	ldw	r2,-44(fp)
  181edc:	1880062e 	bgeu	r3,r2,181ef8 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
  181ee0:	e0fff517 	ldw	r3,-44(fp)
  181ee4:	e0bff817 	ldw	r2,-32(fp)
  181ee8:	1885c83a 	sub	r2,r3,r2
  181eec:	10bfffc4 	addi	r2,r2,-1
  181ef0:	e0bff615 	stw	r2,-40(fp)
  181ef4:	00000b06 	br	181f24 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
  181ef8:	e0bff517 	ldw	r2,-44(fp)
  181efc:	10000526 	beq	r2,zero,181f14 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
  181f00:	00c20004 	movi	r3,2048
  181f04:	e0bff817 	ldw	r2,-32(fp)
  181f08:	1885c83a 	sub	r2,r3,r2
  181f0c:	e0bff615 	stw	r2,-40(fp)
  181f10:	00000406 	br	181f24 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
  181f14:	00c1ffc4 	movi	r3,2047
  181f18:	e0bff817 	ldw	r2,-32(fp)
  181f1c:	1885c83a 	sub	r2,r3,r2
  181f20:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
  181f24:	e0bff617 	ldw	r2,-40(fp)
  181f28:	10001e26 	beq	r2,zero,181fa4 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
  181f2c:	e0fffe17 	ldw	r3,-8(fp)
  181f30:	e0bff617 	ldw	r2,-40(fp)
  181f34:	1880022e 	bgeu	r3,r2,181f40 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
  181f38:	e0bffe17 	ldw	r2,-8(fp)
  181f3c:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
  181f40:	e0bff817 	ldw	r2,-32(fp)
  181f44:	10820e04 	addi	r2,r2,2104
  181f48:	e0fffc17 	ldw	r3,-16(fp)
  181f4c:	1885883a 	add	r2,r3,r2
  181f50:	1009883a 	mov	r4,r2
  181f54:	e17ffd17 	ldw	r5,-12(fp)
  181f58:	e1bff617 	ldw	r6,-40(fp)
  181f5c:	01864ac0 	call	1864ac <memcpy>
      ptr   += n;
  181f60:	e0fffd17 	ldw	r3,-12(fp)
  181f64:	e0bff617 	ldw	r2,-40(fp)
  181f68:	1885883a 	add	r2,r3,r2
  181f6c:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
  181f70:	e0fffe17 	ldw	r3,-8(fp)
  181f74:	e0bff617 	ldw	r2,-40(fp)
  181f78:	1885c83a 	sub	r2,r3,r2
  181f7c:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  181f80:	e0fff817 	ldw	r3,-32(fp)
  181f84:	e0bff617 	ldw	r2,-40(fp)
  181f88:	1885883a 	add	r2,r3,r2
  181f8c:	10c1ffcc 	andi	r3,r2,2047
  181f90:	e0bffc17 	ldw	r2,-16(fp)
  181f94:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  181f98:	e0bffe17 	ldw	r2,-8(fp)
  181f9c:	00bfc716 	blt	zero,r2,181ebc <altera_avalon_jtag_uart_write+0x30>
  181fa0:	00000106 	br	181fa8 <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
  181fa4:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  181fa8:	0005303a 	rdctl	r2,status
  181fac:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  181fb0:	e0fffa17 	ldw	r3,-24(fp)
  181fb4:	00bfff84 	movi	r2,-2
  181fb8:	1884703a 	and	r2,r3,r2
  181fbc:	1001703a 	wrctl	status,r2
  
  return context;
  181fc0:	e0bffa17 	ldw	r2,-24(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
  181fc4:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  181fc8:	e0bffc17 	ldw	r2,-16(fp)
  181fcc:	10800817 	ldw	r2,32(r2)
  181fd0:	10c00094 	ori	r3,r2,2
  181fd4:	e0bffc17 	ldw	r2,-16(fp)
  181fd8:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  181fdc:	e0bffc17 	ldw	r2,-16(fp)
  181fe0:	10800017 	ldw	r2,0(r2)
  181fe4:	10800104 	addi	r2,r2,4
  181fe8:	e0fffc17 	ldw	r3,-16(fp)
  181fec:	18c00817 	ldw	r3,32(r3)
  181ff0:	10c00035 	stwio	r3,0(r2)
  181ff4:	e0bff917 	ldw	r2,-28(fp)
  181ff8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  181ffc:	e0bffb17 	ldw	r2,-20(fp)
  182000:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
  182004:	e0bffe17 	ldw	r2,-8(fp)
  182008:	0080110e 	bge	zero,r2,182050 <altera_avalon_jtag_uart_write+0x1c4>
    {
      if (flags & O_NONBLOCK)
  18200c:	e0bfff17 	ldw	r2,-4(fp)
  182010:	1090000c 	andi	r2,r2,16384
  182014:	1000111e 	bne	r2,zero,18205c <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
  182018:	0001883a 	nop
  18201c:	e0bffc17 	ldw	r2,-16(fp)
  182020:	10c00d17 	ldw	r3,52(r2)
  182024:	e0bff517 	ldw	r2,-44(fp)
  182028:	1880051e 	bne	r3,r2,182040 <altera_avalon_jtag_uart_write+0x1b4>
  18202c:	e0bffc17 	ldw	r2,-16(fp)
  182030:	10c00917 	ldw	r3,36(r2)
  182034:	e0bffc17 	ldw	r2,-16(fp)
  182038:	10800117 	ldw	r2,4(r2)
  18203c:	18bff736 	bltu	r3,r2,18201c <altera_avalon_jtag_uart_write+0x190>
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
  182040:	e0bffc17 	ldw	r2,-16(fp)
  182044:	10c00d17 	ldw	r3,52(r2)
  182048:	e0bff517 	ldw	r2,-44(fp)
  18204c:	18800526 	beq	r3,r2,182064 <altera_avalon_jtag_uart_write+0x1d8>
         break;
    }
  }
  while (count > 0);
  182050:	e0bffe17 	ldw	r2,-8(fp)
  182054:	00bfd016 	blt	zero,r2,181f98 <altera_avalon_jtag_uart_write+0x10c>
  182058:	00000306 	br	182068 <altera_avalon_jtag_uart_write+0x1dc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
  18205c:	0001883a 	nop
  182060:	00000106 	br	182068 <altera_avalon_jtag_uart_write+0x1dc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
         break;
  182064:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
  182068:	e0fffd17 	ldw	r3,-12(fp)
  18206c:	e0bff717 	ldw	r2,-36(fp)
  182070:	18800426 	beq	r3,r2,182084 <altera_avalon_jtag_uart_write+0x1f8>
    return ptr - start;
  182074:	e0fffd17 	ldw	r3,-12(fp)
  182078:	e0bff717 	ldw	r2,-36(fp)
  18207c:	1885c83a 	sub	r2,r3,r2
  182080:	00000606 	br	18209c <altera_avalon_jtag_uart_write+0x210>
  else if (flags & O_NONBLOCK)
  182084:	e0bfff17 	ldw	r2,-4(fp)
  182088:	1090000c 	andi	r2,r2,16384
  18208c:	10000226 	beq	r2,zero,182098 <altera_avalon_jtag_uart_write+0x20c>
    return -EWOULDBLOCK;
  182090:	00bffd44 	movi	r2,-11
  182094:	00000106 	br	18209c <altera_avalon_jtag_uart_write+0x210>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
  182098:	00bffec4 	movi	r2,-5
}
  18209c:	e037883a 	mov	sp,fp
  1820a0:	dfc00117 	ldw	ra,4(sp)
  1820a4:	df000017 	ldw	fp,0(sp)
  1820a8:	dec00204 	addi	sp,sp,8
  1820ac:	f800283a 	ret

001820b0 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
  1820b0:	defffa04 	addi	sp,sp,-24
  1820b4:	dfc00515 	stw	ra,20(sp)
  1820b8:	df000415 	stw	fp,16(sp)
  1820bc:	df000404 	addi	fp,sp,16
  1820c0:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
  1820c4:	0007883a 	mov	r3,zero
  1820c8:	e0bfff17 	ldw	r2,-4(fp)
  1820cc:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
  1820d0:	e0bfff17 	ldw	r2,-4(fp)
  1820d4:	10800104 	addi	r2,r2,4
  1820d8:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  1820dc:	0005303a 	rdctl	r2,status
  1820e0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  1820e4:	e0fffd17 	ldw	r3,-12(fp)
  1820e8:	00bfff84 	movi	r2,-2
  1820ec:	1884703a 	and	r2,r3,r2
  1820f0:	1001703a 	wrctl	status,r2
  
  return context;
  1820f4:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
  1820f8:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
  1820fc:	01851000 	call	185100 <alt_tick>
  182100:	e0bffc17 	ldw	r2,-16(fp)
  182104:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  182108:	e0bffe17 	ldw	r2,-8(fp)
  18210c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
  182110:	e037883a 	mov	sp,fp
  182114:	dfc00117 	ldw	ra,4(sp)
  182118:	df000017 	ldw	fp,0(sp)
  18211c:	dec00204 	addi	sp,sp,8
  182120:	f800283a 	ret

00182124 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
  182124:	defff804 	addi	sp,sp,-32
  182128:	dfc00715 	stw	ra,28(sp)
  18212c:	df000615 	stw	fp,24(sp)
  182130:	df000604 	addi	fp,sp,24
  182134:	e13ffc15 	stw	r4,-16(fp)
  182138:	e17ffd15 	stw	r5,-12(fp)
  18213c:	e1bffe15 	stw	r6,-8(fp)
  182140:	e1ffff15 	stw	r7,-4(fp)
  182144:	e0bfff17 	ldw	r2,-4(fp)
  182148:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
  18214c:	00800674 	movhi	r2,25
  182150:	10b15804 	addi	r2,r2,-15008
  182154:	10800017 	ldw	r2,0(r2)
  182158:	1000041e 	bne	r2,zero,18216c <alt_avalon_timer_sc_init+0x48>
  {
    _alt_tick_rate = nticks;
  18215c:	00800674 	movhi	r2,25
  182160:	10b15804 	addi	r2,r2,-15008
  182164:	e0fffb17 	ldw	r3,-20(fp)
  182168:	10c00015 	stw	r3,0(r2)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
  18216c:	e0bffc17 	ldw	r2,-16(fp)
  182170:	10800104 	addi	r2,r2,4
  182174:	00c001c4 	movi	r3,7
  182178:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
  18217c:	d8000015 	stw	zero,0(sp)
  182180:	e13ffd17 	ldw	r4,-12(fp)
  182184:	e17ffe17 	ldw	r5,-8(fp)
  182188:	01800634 	movhi	r6,24
  18218c:	31882c04 	addi	r6,r6,8368
  182190:	e1fffc17 	ldw	r7,-16(fp)
  182194:	01849300 	call	184930 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
  182198:	e037883a 	mov	sp,fp
  18219c:	dfc00117 	ldw	ra,4(sp)
  1821a0:	df000017 	ldw	fp,0(sp)
  1821a4:	dec00204 	addi	sp,sp,8
  1821a8:	f800283a 	ret

001821ac <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  1821ac:	defffa04 	addi	sp,sp,-24
  1821b0:	dfc00515 	stw	ra,20(sp)
  1821b4:	df000415 	stw	fp,16(sp)
  1821b8:	df000404 	addi	fp,sp,16
  1821bc:	e13ffd15 	stw	r4,-12(fp)
  1821c0:	e17ffe15 	stw	r5,-8(fp)
  1821c4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  1821c8:	e0bffd17 	ldw	r2,-12(fp)
  1821cc:	10800017 	ldw	r2,0(r2)
  1821d0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
  1821d4:	e0bffc17 	ldw	r2,-16(fp)
  1821d8:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
  1821dc:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 

    return altera_avalon_uart_read(&dev->state, buffer, space,
  1821e0:	10800217 	ldw	r2,8(r2)
  1821e4:	1809883a 	mov	r4,r3
  1821e8:	e17ffe17 	ldw	r5,-8(fp)
  1821ec:	e1bfff17 	ldw	r6,-4(fp)
  1821f0:	100f883a 	mov	r7,r2
  1821f4:	01826b40 	call	1826b4 <altera_avalon_uart_read>
      fd->fd_flags);
}
  1821f8:	e037883a 	mov	sp,fp
  1821fc:	dfc00117 	ldw	ra,4(sp)
  182200:	df000017 	ldw	fp,0(sp)
  182204:	dec00204 	addi	sp,sp,8
  182208:	f800283a 	ret

0018220c <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  18220c:	defffa04 	addi	sp,sp,-24
  182210:	dfc00515 	stw	ra,20(sp)
  182214:	df000415 	stw	fp,16(sp)
  182218:	df000404 	addi	fp,sp,16
  18221c:	e13ffd15 	stw	r4,-12(fp)
  182220:	e17ffe15 	stw	r5,-8(fp)
  182224:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  182228:	e0bffd17 	ldw	r2,-12(fp)
  18222c:	10800017 	ldw	r2,0(r2)
  182230:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
  182234:	e0bffc17 	ldw	r2,-16(fp)
  182238:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
  18223c:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 

    return altera_avalon_uart_write(&dev->state, buffer, space,
  182240:	10800217 	ldw	r2,8(r2)
  182244:	1809883a 	mov	r4,r3
  182248:	e17ffe17 	ldw	r5,-8(fp)
  18224c:	e1bfff17 	ldw	r6,-4(fp)
  182250:	100f883a 	mov	r7,r2
  182254:	01829080 	call	182908 <altera_avalon_uart_write>
      fd->fd_flags);
}
  182258:	e037883a 	mov	sp,fp
  18225c:	dfc00117 	ldw	ra,4(sp)
  182260:	df000017 	ldw	fp,0(sp)
  182264:	dec00204 	addi	sp,sp,8
  182268:	f800283a 	ret

0018226c <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
  18226c:	defffc04 	addi	sp,sp,-16
  182270:	dfc00315 	stw	ra,12(sp)
  182274:	df000215 	stw	fp,8(sp)
  182278:	df000204 	addi	fp,sp,8
  18227c:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  182280:	e0bfff17 	ldw	r2,-4(fp)
  182284:	10800017 	ldw	r2,0(r2)
  182288:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
  18228c:	e0bffe17 	ldw	r2,-8(fp)
  182290:	10c00a04 	addi	r3,r2,40
  182294:	e0bfff17 	ldw	r2,-4(fp)
  182298:	10800217 	ldw	r2,8(r2)
  18229c:	1809883a 	mov	r4,r3
  1822a0:	100b883a 	mov	r5,r2
  1822a4:	01826100 	call	182610 <altera_avalon_uart_close>
}
  1822a8:	e037883a 	mov	sp,fp
  1822ac:	dfc00117 	ldw	ra,4(sp)
  1822b0:	df000017 	ldw	fp,0(sp)
  1822b4:	dec00204 	addi	sp,sp,8
  1822b8:	f800283a 	ret

001822bc <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
  1822bc:	defff804 	addi	sp,sp,-32
  1822c0:	dfc00715 	stw	ra,28(sp)
  1822c4:	df000615 	stw	fp,24(sp)
  1822c8:	df000604 	addi	fp,sp,24
  1822cc:	e13ffd15 	stw	r4,-12(fp)
  1822d0:	e17ffe15 	stw	r5,-8(fp)
  1822d4:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
  1822d8:	e0bffd17 	ldw	r2,-12(fp)
  1822dc:	10800017 	ldw	r2,0(r2)
  1822e0:	e0bffb15 	stw	r2,-20(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
  1822e4:	0005883a 	mov	r2,zero
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
  1822e8:	1000041e 	bne	r2,zero,1822fc <altera_avalon_uart_init+0x40>
  1822ec:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
  1822f0:	1000021e 	bne	r2,zero,1822fc <altera_avalon_uart_init+0x40>
  1822f4:	0005883a 	mov	r2,zero
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
  1822f8:	10000226 	beq	r2,zero,182304 <altera_avalon_uart_init+0x48>
  1822fc:	00800044 	movi	r2,1
  182300:	00000106 	br	182308 <altera_avalon_uart_init+0x4c>
  182304:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
  182308:	e0bffc15 	stw	r2,-16(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
  18230c:	e0bffc17 	ldw	r2,-16(fp)
  182310:	10000f1e 	bne	r2,zero,182350 <altera_avalon_uart_init+0x94>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
  182314:	e0bffd17 	ldw	r2,-12(fp)
  182318:	00c32004 	movi	r3,3200
  18231c:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
  182320:	e0bffb17 	ldw	r2,-20(fp)
  182324:	10800304 	addi	r2,r2,12
  182328:	e0fffd17 	ldw	r3,-12(fp)
  18232c:	18c00117 	ldw	r3,4(r3)
  182330:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
  182334:	d8000015 	stw	zero,0(sp)
  182338:	e13ffe17 	ldw	r4,-8(fp)
  18233c:	e17fff17 	ldw	r5,-4(fp)
  182340:	01800634 	movhi	r6,24
  182344:	3188d904 	addi	r6,r6,9060
  182348:	e1fffd17 	ldw	r7,-12(fp)
  18234c:	01849300 	call	184930 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
  182350:	e037883a 	mov	sp,fp
  182354:	dfc00117 	ldw	ra,4(sp)
  182358:	df000017 	ldw	fp,0(sp)
  18235c:	dec00204 	addi	sp,sp,8
  182360:	f800283a 	ret

00182364 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
  182364:	defffa04 	addi	sp,sp,-24
  182368:	dfc00515 	stw	ra,20(sp)
  18236c:	df000415 	stw	fp,16(sp)
  182370:	df000404 	addi	fp,sp,16
  182374:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
  182378:	e0bfff17 	ldw	r2,-4(fp)
  18237c:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
  182380:	e0bffc17 	ldw	r2,-16(fp)
  182384:	10800017 	ldw	r2,0(r2)
  182388:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
  18238c:	e0bffd17 	ldw	r2,-12(fp)
  182390:	10800204 	addi	r2,r2,8
  182394:	10800037 	ldwio	r2,0(r2)
  182398:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
  18239c:	e0bffd17 	ldw	r2,-12(fp)
  1823a0:	10800204 	addi	r2,r2,8
  1823a4:	0007883a 	mov	r3,zero
  1823a8:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
  1823ac:	e0bffd17 	ldw	r2,-12(fp)
  1823b0:	10800204 	addi	r2,r2,8
  1823b4:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
  1823b8:	e0bffe17 	ldw	r2,-8(fp)
  1823bc:	1080200c 	andi	r2,r2,128
  1823c0:	10000326 	beq	r2,zero,1823d0 <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
  1823c4:	e13ffc17 	ldw	r4,-16(fp)
  1823c8:	e17ffe17 	ldw	r5,-8(fp)
  1823cc:	01823fc0 	call	1823fc <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
  1823d0:	e0bffe17 	ldw	r2,-8(fp)
  1823d4:	1081100c 	andi	r2,r2,1088
  1823d8:	10000326 	beq	r2,zero,1823e8 <altera_avalon_uart_irq+0x84>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
  1823dc:	e13ffc17 	ldw	r4,-16(fp)
  1823e0:	e17ffe17 	ldw	r5,-8(fp)
  1823e4:	01824d40 	call	1824d4 <altera_avalon_uart_txirq>
  }
  

}
  1823e8:	e037883a 	mov	sp,fp
  1823ec:	dfc00117 	ldw	ra,4(sp)
  1823f0:	df000017 	ldw	fp,0(sp)
  1823f4:	dec00204 	addi	sp,sp,8
  1823f8:	f800283a 	ret

001823fc <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
  1823fc:	defffc04 	addi	sp,sp,-16
  182400:	df000315 	stw	fp,12(sp)
  182404:	df000304 	addi	fp,sp,12
  182408:	e13ffe15 	stw	r4,-8(fp)
  18240c:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
  182410:	e0bfff17 	ldw	r2,-4(fp)
  182414:	108000cc 	andi	r2,r2,3
  182418:	1000291e 	bne	r2,zero,1824c0 <altera_avalon_uart_rxirq+0xc4>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
  18241c:	e0bffe17 	ldw	r2,-8(fp)
  182420:	10800317 	ldw	r2,12(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  182424:	e0bffe17 	ldw	r2,-8(fp)
  182428:	10800317 	ldw	r2,12(r2)
  18242c:	10800044 	addi	r2,r2,1
  182430:	10800fcc 	andi	r2,r2,63
  182434:	e0bffd15 	stw	r2,-12(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
  182438:	e0bffe17 	ldw	r2,-8(fp)
  18243c:	10800317 	ldw	r2,12(r2)
  182440:	e0fffe17 	ldw	r3,-8(fp)
  182444:	18c00017 	ldw	r3,0(r3)
  182448:	18c00037 	ldwio	r3,0(r3)
  18244c:	e13ffe17 	ldw	r4,-8(fp)
  182450:	2085883a 	add	r2,r4,r2
  182454:	10800704 	addi	r2,r2,28
  182458:	10c00005 	stb	r3,0(r2)

  sp->rx_end = next;
  18245c:	e0bffe17 	ldw	r2,-8(fp)
  182460:	e0fffd17 	ldw	r3,-12(fp)
  182464:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  182468:	e0bffe17 	ldw	r2,-8(fp)
  18246c:	10800317 	ldw	r2,12(r2)
  182470:	10800044 	addi	r2,r2,1
  182474:	10800fcc 	andi	r2,r2,63
  182478:	e0bffd15 	stw	r2,-12(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
  18247c:	e0bffe17 	ldw	r2,-8(fp)
  182480:	10c00217 	ldw	r3,8(r2)
  182484:	e0bffd17 	ldw	r2,-12(fp)
  182488:	18800e1e 	bne	r3,r2,1824c4 <altera_avalon_uart_rxirq+0xc8>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  18248c:	e0bffe17 	ldw	r2,-8(fp)
  182490:	10c00117 	ldw	r3,4(r2)
  182494:	00bfdfc4 	movi	r2,-129
  182498:	1886703a 	and	r3,r3,r2
  18249c:	e0bffe17 	ldw	r2,-8(fp)
  1824a0:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  1824a4:	e0bffe17 	ldw	r2,-8(fp)
  1824a8:	10800017 	ldw	r2,0(r2)
  1824ac:	10800304 	addi	r2,r2,12
  1824b0:	e0fffe17 	ldw	r3,-8(fp)
  1824b4:	18c00117 	ldw	r3,4(r3)
  1824b8:	10c00035 	stwio	r3,0(r2)
  1824bc:	00000106 	br	1824c4 <altera_avalon_uart_rxirq+0xc8>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
  1824c0:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
  1824c4:	e037883a 	mov	sp,fp
  1824c8:	df000017 	ldw	fp,0(sp)
  1824cc:	dec00104 	addi	sp,sp,4
  1824d0:	f800283a 	ret

001824d4 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
  1824d4:	defffd04 	addi	sp,sp,-12
  1824d8:	df000215 	stw	fp,8(sp)
  1824dc:	df000204 	addi	fp,sp,8
  1824e0:	e13ffe15 	stw	r4,-8(fp)
  1824e4:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
  1824e8:	e0bffe17 	ldw	r2,-8(fp)
  1824ec:	10c00417 	ldw	r3,16(r2)
  1824f0:	e0bffe17 	ldw	r2,-8(fp)
  1824f4:	10800517 	ldw	r2,20(r2)
  1824f8:	18803026 	beq	r3,r2,1825bc <altera_avalon_uart_txirq+0xe8>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
  1824fc:	e0bffe17 	ldw	r2,-8(fp)
  182500:	10800617 	ldw	r2,24(r2)
  182504:	1080008c 	andi	r2,r2,2
  182508:	10000326 	beq	r2,zero,182518 <altera_avalon_uart_txirq+0x44>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
  18250c:	e0bfff17 	ldw	r2,-4(fp)
  182510:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
  182514:	10001b26 	beq	r2,zero,182584 <altera_avalon_uart_txirq+0xb0>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
  182518:	e0bffe17 	ldw	r2,-8(fp)
  18251c:	10800417 	ldw	r2,16(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
  182520:	e0bffe17 	ldw	r2,-8(fp)
  182524:	10800017 	ldw	r2,0(r2)
  182528:	10800104 	addi	r2,r2,4
  18252c:	e0fffe17 	ldw	r3,-8(fp)
  182530:	18c00417 	ldw	r3,16(r3)
  182534:	e13ffe17 	ldw	r4,-8(fp)
  182538:	20c7883a 	add	r3,r4,r3
  18253c:	18c01704 	addi	r3,r3,92
  182540:	18c00003 	ldbu	r3,0(r3)
  182544:	18c03fcc 	andi	r3,r3,255
  182548:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
  18254c:	e0bffe17 	ldw	r2,-8(fp)
  182550:	10800417 	ldw	r2,16(r2)
  182554:	10800044 	addi	r2,r2,1
  182558:	e0fffe17 	ldw	r3,-8(fp)
  18255c:	18800415 	stw	r2,16(r3)
  182560:	10c00fcc 	andi	r3,r2,63
  182564:	e0bffe17 	ldw	r2,-8(fp)
  182568:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
  18256c:	e0bffe17 	ldw	r2,-8(fp)
  182570:	10800117 	ldw	r2,4(r2)
  182574:	10c01014 	ori	r3,r2,64
  182578:	e0bffe17 	ldw	r2,-8(fp)
  18257c:	10c00115 	stw	r3,4(r2)
  182580:	00000e06 	br	1825bc <altera_avalon_uart_txirq+0xe8>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
  182584:	e0bffe17 	ldw	r2,-8(fp)
  182588:	10800017 	ldw	r2,0(r2)
  18258c:	10800204 	addi	r2,r2,8
  182590:	10800037 	ldwio	r2,0(r2)
  182594:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
  182598:	e0bfff17 	ldw	r2,-4(fp)
  18259c:	1082000c 	andi	r2,r2,2048
  1825a0:	1000061e 	bne	r2,zero,1825bc <altera_avalon_uart_txirq+0xe8>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
  1825a4:	e0bffe17 	ldw	r2,-8(fp)
  1825a8:	10c00117 	ldw	r3,4(r2)
  1825ac:	00bfefc4 	movi	r2,-65
  1825b0:	1886703a 	and	r3,r3,r2
  1825b4:	e0bffe17 	ldw	r2,-8(fp)
  1825b8:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
  1825bc:	e0bffe17 	ldw	r2,-8(fp)
  1825c0:	10c00417 	ldw	r3,16(r2)
  1825c4:	e0bffe17 	ldw	r2,-8(fp)
  1825c8:	10800517 	ldw	r2,20(r2)
  1825cc:	1880061e 	bne	r3,r2,1825e8 <altera_avalon_uart_txirq+0x114>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  1825d0:	e0bffe17 	ldw	r2,-8(fp)
  1825d4:	10c00117 	ldw	r3,4(r2)
  1825d8:	00beefc4 	movi	r2,-1089
  1825dc:	1886703a 	and	r3,r3,r2
  1825e0:	e0bffe17 	ldw	r2,-8(fp)
  1825e4:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  1825e8:	e0bffe17 	ldw	r2,-8(fp)
  1825ec:	10800017 	ldw	r2,0(r2)
  1825f0:	10800304 	addi	r2,r2,12
  1825f4:	e0fffe17 	ldw	r3,-8(fp)
  1825f8:	18c00117 	ldw	r3,4(r3)
  1825fc:	10c00035 	stwio	r3,0(r2)
}
  182600:	e037883a 	mov	sp,fp
  182604:	df000017 	ldw	fp,0(sp)
  182608:	dec00104 	addi	sp,sp,4
  18260c:	f800283a 	ret

00182610 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  182610:	defffd04 	addi	sp,sp,-12
  182614:	df000215 	stw	fp,8(sp)
  182618:	df000204 	addi	fp,sp,8
  18261c:	e13ffe15 	stw	r4,-8(fp)
  182620:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
  182624:	00000506 	br	18263c <altera_avalon_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
  182628:	e0bfff17 	ldw	r2,-4(fp)
  18262c:	1090000c 	andi	r2,r2,16384
  182630:	10000226 	beq	r2,zero,18263c <altera_avalon_uart_close+0x2c>
      return -EWOULDBLOCK; 
  182634:	00bffd44 	movi	r2,-11
  182638:	00000606 	br	182654 <altera_avalon_uart_close+0x44>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
  18263c:	e0bffe17 	ldw	r2,-8(fp)
  182640:	10c00417 	ldw	r3,16(r2)
  182644:	e0bffe17 	ldw	r2,-8(fp)
  182648:	10800517 	ldw	r2,20(r2)
  18264c:	18bff61e 	bne	r3,r2,182628 <altera_avalon_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
  182650:	0005883a 	mov	r2,zero
}
  182654:	e037883a 	mov	sp,fp
  182658:	df000017 	ldw	fp,0(sp)
  18265c:	dec00104 	addi	sp,sp,4
  182660:	f800283a 	ret

00182664 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  182664:	defffe04 	addi	sp,sp,-8
  182668:	dfc00115 	stw	ra,4(sp)
  18266c:	df000015 	stw	fp,0(sp)
  182670:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  182674:	00800674 	movhi	r2,25
  182678:	10aa8504 	addi	r2,r2,-21996
  18267c:	10800017 	ldw	r2,0(r2)
  182680:	10000526 	beq	r2,zero,182698 <alt_get_errno+0x34>
  182684:	00800674 	movhi	r2,25
  182688:	10aa8504 	addi	r2,r2,-21996
  18268c:	10800017 	ldw	r2,0(r2)
  182690:	103ee83a 	callr	r2
  182694:	00000206 	br	1826a0 <alt_get_errno+0x3c>
  182698:	00800674 	movhi	r2,25
  18269c:	10b15a04 	addi	r2,r2,-15000
}
  1826a0:	e037883a 	mov	sp,fp
  1826a4:	dfc00117 	ldw	ra,4(sp)
  1826a8:	df000017 	ldw	fp,0(sp)
  1826ac:	dec00204 	addi	sp,sp,8
  1826b0:	f800283a 	ret

001826b4 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
  1826b4:	defff104 	addi	sp,sp,-60
  1826b8:	dfc00e15 	stw	ra,56(sp)
  1826bc:	df000d15 	stw	fp,52(sp)
  1826c0:	df000d04 	addi	fp,sp,52
  1826c4:	e13ffc15 	stw	r4,-16(fp)
  1826c8:	e17ffd15 	stw	r5,-12(fp)
  1826cc:	e1bffe15 	stw	r6,-8(fp)
  1826d0:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u32         next;
  alt_u8          read_would_block = 0;
  1826d4:	e03ff305 	stb	zero,-52(fp)
  int             count = 0;
  1826d8:	e03ff415 	stw	zero,-48(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
  1826dc:	e0bfff17 	ldw	r2,-4(fp)
  1826e0:	1090000c 	andi	r2,r2,16384
  1826e4:	1005003a 	cmpeq	r2,r2,zero
  1826e8:	10803fcc 	andi	r2,r2,255
  1826ec:	e0bff515 	stw	r2,-44(fp)
  /*
   * Calculate which slot in the circular buffer is the next one to read
   * data from.
   */

  next = (sp->rx_start + 1) & ALT_AVALON_UART_BUF_MSK;
  1826f0:	e0bffc17 	ldw	r2,-16(fp)
  1826f4:	10800217 	ldw	r2,8(r2)
  1826f8:	10800044 	addi	r2,r2,1
  1826fc:	10800fcc 	andi	r2,r2,63
  182700:	e0bff615 	stw	r2,-40(fp)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
  182704:	00001906 	br	18276c <altera_avalon_uart_read+0xb8>
    {
      count++;
  182708:	e0bff417 	ldw	r2,-48(fp)
  18270c:	10800044 	addi	r2,r2,1
  182710:	e0bff415 	stw	r2,-48(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
  182714:	e0bffc17 	ldw	r2,-16(fp)
  182718:	10800217 	ldw	r2,8(r2)
  18271c:	e0fffc17 	ldw	r3,-16(fp)
  182720:	1885883a 	add	r2,r3,r2
  182724:	10800704 	addi	r2,r2,28
  182728:	10800003 	ldbu	r2,0(r2)
  18272c:	1007883a 	mov	r3,r2
  182730:	e0bffd17 	ldw	r2,-12(fp)
  182734:	10c00005 	stb	r3,0(r2)
  182738:	e0bffd17 	ldw	r2,-12(fp)
  18273c:	10800044 	addi	r2,r2,1
  182740:	e0bffd15 	stw	r2,-12(fp)
      
      sp->rx_start = (++sp->rx_start) & ALT_AVALON_UART_BUF_MSK;
  182744:	e0bffc17 	ldw	r2,-16(fp)
  182748:	10800217 	ldw	r2,8(r2)
  18274c:	10c00044 	addi	r3,r2,1
  182750:	e0bffc17 	ldw	r2,-16(fp)
  182754:	10c00215 	stw	r3,8(r2)
  182758:	e0bffc17 	ldw	r2,-16(fp)
  18275c:	10800217 	ldw	r2,8(r2)
  182760:	10c00fcc 	andi	r3,r2,63
  182764:	e0bffc17 	ldw	r2,-16(fp)
  182768:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
  18276c:	e0fff417 	ldw	r3,-48(fp)
  182770:	e0bffe17 	ldw	r2,-8(fp)
  182774:	1880050e 	bge	r3,r2,18278c <altera_avalon_uart_read+0xd8>
  182778:	e0bffc17 	ldw	r2,-16(fp)
  18277c:	10c00217 	ldw	r3,8(r2)
  182780:	e0bffc17 	ldw	r2,-16(fp)
  182784:	10800317 	ldw	r2,12(r2)
  182788:	18bfdf1e 	bne	r3,r2,182708 <altera_avalon_uart_read+0x54>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
  18278c:	e0bff417 	ldw	r2,-48(fp)
  182790:	1000241e 	bne	r2,zero,182824 <altera_avalon_uart_read+0x170>
  182794:	e0bffc17 	ldw	r2,-16(fp)
  182798:	10c00217 	ldw	r3,8(r2)
  18279c:	e0bffc17 	ldw	r2,-16(fp)
  1827a0:	10800317 	ldw	r2,12(r2)
  1827a4:	18801f1e 	bne	r3,r2,182824 <altera_avalon_uart_read+0x170>
    {
      if (!block)
  1827a8:	e0bff517 	ldw	r2,-44(fp)
  1827ac:	1000061e 	bne	r2,zero,1827c8 <altera_avalon_uart_read+0x114>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
  1827b0:	01826640 	call	182664 <alt_get_errno>
  1827b4:	00c002c4 	movi	r3,11
  1827b8:	10c00015 	stw	r3,0(r2)
        read_would_block = 1;
  1827bc:	00800044 	movi	r2,1
  1827c0:	e0bff305 	stb	r2,-52(fp)
        break;
  1827c4:	00001b06 	br	182834 <altera_avalon_uart_read+0x180>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  1827c8:	0005303a 	rdctl	r2,status
  1827cc:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  1827d0:	e0fff817 	ldw	r3,-32(fp)
  1827d4:	00bfff84 	movi	r2,-2
  1827d8:	1884703a 	and	r2,r3,r2
  1827dc:	1001703a 	wrctl	status,r2
  
  return context;
  1827e0:	e0bff817 	ldw	r2,-32(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
  1827e4:	e0bff715 	stw	r2,-36(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  1827e8:	e0bffc17 	ldw	r2,-16(fp)
  1827ec:	10800117 	ldw	r2,4(r2)
  1827f0:	10c02014 	ori	r3,r2,128
  1827f4:	e0bffc17 	ldw	r2,-16(fp)
  1827f8:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  1827fc:	e0bffc17 	ldw	r2,-16(fp)
  182800:	10800017 	ldw	r2,0(r2)
  182804:	10800304 	addi	r2,r2,12
  182808:	e0fffc17 	ldw	r3,-16(fp)
  18280c:	18c00117 	ldw	r3,4(r3)
  182810:	10c00035 	stwio	r3,0(r2)
  182814:	e0bff717 	ldw	r2,-36(fp)
  182818:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  18281c:	e0bff917 	ldw	r2,-28(fp)
  182820:	1001703a 	wrctl	status,r2
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
  182824:	e0bff417 	ldw	r2,-48(fp)
  182828:	1000021e 	bne	r2,zero,182834 <altera_avalon_uart_read+0x180>
  18282c:	e0bffe17 	ldw	r2,-8(fp)
  182830:	103fce1e 	bne	r2,zero,18276c <altera_avalon_uart_read+0xb8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  182834:	0005303a 	rdctl	r2,status
  182838:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  18283c:	e0fffa17 	ldw	r3,-24(fp)
  182840:	00bfff84 	movi	r2,-2
  182844:	1884703a 	and	r2,r3,r2
  182848:	1001703a 	wrctl	status,r2
  
  return context;
  18284c:	e0bffa17 	ldw	r2,-24(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
  182850:	e0bff715 	stw	r2,-36(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  182854:	e0bffc17 	ldw	r2,-16(fp)
  182858:	10800117 	ldw	r2,4(r2)
  18285c:	10c02014 	ori	r3,r2,128
  182860:	e0bffc17 	ldw	r2,-16(fp)
  182864:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  182868:	e0bffc17 	ldw	r2,-16(fp)
  18286c:	10800017 	ldw	r2,0(r2)
  182870:	10800304 	addi	r2,r2,12
  182874:	e0fffc17 	ldw	r3,-16(fp)
  182878:	18c00117 	ldw	r3,4(r3)
  18287c:	10c00035 	stwio	r3,0(r2)
  182880:	e0bff717 	ldw	r2,-36(fp)
  182884:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  182888:	e0bffb17 	ldw	r2,-20(fp)
  18288c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
  182890:	e0bff303 	ldbu	r2,-52(fp)
  182894:	10000226 	beq	r2,zero,1828a0 <altera_avalon_uart_read+0x1ec>
    return -EWOULDBLOCK;
  182898:	00bffd44 	movi	r2,-11
  18289c:	00000106 	br	1828a4 <altera_avalon_uart_read+0x1f0>
  }
  else {
    return count;
  1828a0:	e0bff417 	ldw	r2,-48(fp)
  }
}
  1828a4:	e037883a 	mov	sp,fp
  1828a8:	dfc00117 	ldw	ra,4(sp)
  1828ac:	df000017 	ldw	fp,0(sp)
  1828b0:	dec00204 	addi	sp,sp,8
  1828b4:	f800283a 	ret

001828b8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  1828b8:	defffe04 	addi	sp,sp,-8
  1828bc:	dfc00115 	stw	ra,4(sp)
  1828c0:	df000015 	stw	fp,0(sp)
  1828c4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  1828c8:	00800674 	movhi	r2,25
  1828cc:	10aa8504 	addi	r2,r2,-21996
  1828d0:	10800017 	ldw	r2,0(r2)
  1828d4:	10000526 	beq	r2,zero,1828ec <alt_get_errno+0x34>
  1828d8:	00800674 	movhi	r2,25
  1828dc:	10aa8504 	addi	r2,r2,-21996
  1828e0:	10800017 	ldw	r2,0(r2)
  1828e4:	103ee83a 	callr	r2
  1828e8:	00000206 	br	1828f4 <alt_get_errno+0x3c>
  1828ec:	00800674 	movhi	r2,25
  1828f0:	10b15a04 	addi	r2,r2,-15000
}
  1828f4:	e037883a 	mov	sp,fp
  1828f8:	dfc00117 	ldw	ra,4(sp)
  1828fc:	df000017 	ldw	fp,0(sp)
  182900:	dec00204 	addi	sp,sp,8
  182904:	f800283a 	ret

00182908 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
  182908:	defff204 	addi	sp,sp,-56
  18290c:	dfc00d15 	stw	ra,52(sp)
  182910:	df000c15 	stw	fp,48(sp)
  182914:	df000c04 	addi	fp,sp,48
  182918:	e13ffc15 	stw	r4,-16(fp)
  18291c:	e17ffd15 	stw	r5,-12(fp)
  182920:	e1bffe15 	stw	r6,-8(fp)
  182924:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
  182928:	e0bffe17 	ldw	r2,-8(fp)
  18292c:	e0bff415 	stw	r2,-48(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
  182930:	e0bfff17 	ldw	r2,-4(fp)
  182934:	1090000c 	andi	r2,r2,16384
  182938:	e0bff515 	stw	r2,-44(fp)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
  18293c:	00003b06 	br	182a2c <altera_avalon_uart_write+0x124>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  182940:	e0bffc17 	ldw	r2,-16(fp)
  182944:	10800517 	ldw	r2,20(r2)
  182948:	10800044 	addi	r2,r2,1
  18294c:	10800fcc 	andi	r2,r2,63
  182950:	e0bff615 	stw	r2,-40(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
  182954:	e0bffc17 	ldw	r2,-16(fp)
  182958:	10c00417 	ldw	r3,16(r2)
  18295c:	e0bff617 	ldw	r2,-40(fp)
  182960:	1880211e 	bne	r3,r2,1829e8 <altera_avalon_uart_write+0xe0>
    {
      if (no_block)
  182964:	e0bff517 	ldw	r2,-44(fp)
  182968:	10000426 	beq	r2,zero,18297c <altera_avalon_uart_write+0x74>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
  18296c:	01828b80 	call	1828b8 <alt_get_errno>
  182970:	00c002c4 	movi	r3,11
  182974:	10c00015 	stw	r3,0(r2)
        break;
  182978:	00002e06 	br	182a34 <altera_avalon_uart_write+0x12c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  18297c:	0005303a 	rdctl	r2,status
  182980:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  182984:	e0fff817 	ldw	r3,-32(fp)
  182988:	00bfff84 	movi	r2,-2
  18298c:	1884703a 	and	r2,r3,r2
  182990:	1001703a 	wrctl	status,r2
  
  return context;
  182994:	e0bff817 	ldw	r2,-32(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
  182998:	e0bff715 	stw	r2,-36(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  18299c:	e0bffc17 	ldw	r2,-16(fp)
  1829a0:	10800117 	ldw	r2,4(r2)
  1829a4:	10c11014 	ori	r3,r2,1088
  1829a8:	e0bffc17 	ldw	r2,-16(fp)
  1829ac:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  1829b0:	e0bffc17 	ldw	r2,-16(fp)
  1829b4:	10800017 	ldw	r2,0(r2)
  1829b8:	10800304 	addi	r2,r2,12
  1829bc:	e0fffc17 	ldw	r3,-16(fp)
  1829c0:	18c00117 	ldw	r3,4(r3)
  1829c4:	10c00035 	stwio	r3,0(r2)
  1829c8:	e0bff717 	ldw	r2,-36(fp)
  1829cc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  1829d0:	e0bff917 	ldw	r2,-28(fp)
  1829d4:	1001703a 	wrctl	status,r2
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
  1829d8:	e0bffc17 	ldw	r2,-16(fp)
  1829dc:	10c00417 	ldw	r3,16(r2)
  1829e0:	e0bff617 	ldw	r2,-40(fp)
  1829e4:	18bffc26 	beq	r3,r2,1829d8 <altera_avalon_uart_write+0xd0>
      }
    }

    count--;
  1829e8:	e0bff417 	ldw	r2,-48(fp)
  1829ec:	10bfffc4 	addi	r2,r2,-1
  1829f0:	e0bff415 	stw	r2,-48(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
  1829f4:	e0bffc17 	ldw	r2,-16(fp)
  1829f8:	10800517 	ldw	r2,20(r2)
  1829fc:	e0fffd17 	ldw	r3,-12(fp)
  182a00:	18c00003 	ldbu	r3,0(r3)
  182a04:	e13ffc17 	ldw	r4,-16(fp)
  182a08:	2085883a 	add	r2,r4,r2
  182a0c:	10801704 	addi	r2,r2,92
  182a10:	10c00005 	stb	r3,0(r2)
  182a14:	e0bffd17 	ldw	r2,-12(fp)
  182a18:	10800044 	addi	r2,r2,1
  182a1c:	e0bffd15 	stw	r2,-12(fp)
    sp->tx_end = next;
  182a20:	e0bffc17 	ldw	r2,-16(fp)
  182a24:	e0fff617 	ldw	r3,-40(fp)
  182a28:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
  182a2c:	e0bff417 	ldw	r2,-48(fp)
  182a30:	103fc31e 	bne	r2,zero,182940 <altera_avalon_uart_write+0x38>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  182a34:	0005303a 	rdctl	r2,status
  182a38:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  182a3c:	e0fffa17 	ldw	r3,-24(fp)
  182a40:	00bfff84 	movi	r2,-2
  182a44:	1884703a 	and	r2,r3,r2
  182a48:	1001703a 	wrctl	status,r2
  
  return context;
  182a4c:	e0bffa17 	ldw	r2,-24(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
  182a50:	e0bff715 	stw	r2,-36(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  182a54:	e0bffc17 	ldw	r2,-16(fp)
  182a58:	10800117 	ldw	r2,4(r2)
  182a5c:	10c11014 	ori	r3,r2,1088
  182a60:	e0bffc17 	ldw	r2,-16(fp)
  182a64:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  182a68:	e0bffc17 	ldw	r2,-16(fp)
  182a6c:	10800017 	ldw	r2,0(r2)
  182a70:	10800304 	addi	r2,r2,12
  182a74:	e0fffc17 	ldw	r3,-16(fp)
  182a78:	18c00117 	ldw	r3,4(r3)
  182a7c:	10c00035 	stwio	r3,0(r2)
  182a80:	e0bff717 	ldw	r2,-36(fp)
  182a84:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  182a88:	e0bffb17 	ldw	r2,-20(fp)
  182a8c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
  182a90:	e0fffe17 	ldw	r3,-8(fp)
  182a94:	e0bff417 	ldw	r2,-48(fp)
  182a98:	1885c83a 	sub	r2,r3,r2
}
  182a9c:	e037883a 	mov	sp,fp
  182aa0:	dfc00117 	ldw	ra,4(sp)
  182aa4:	df000017 	ldw	fp,0(sp)
  182aa8:	dec00204 	addi	sp,sp,8
  182aac:	f800283a 	ret

00182ab0 <chThdAddRef>:
 * @return              The same thread pointer passed as parameter
 *                      representing the new reference.
 *
 * @api
 */
Thread *chThdAddRef(Thread *tp) {
  182ab0:	defffc04 	addi	sp,sp,-16
  182ab4:	df000315 	stw	fp,12(sp)
  182ab8:	df000304 	addi	fp,sp,12
  182abc:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  182ac0:	0005303a 	rdctl	r2,status
  182ac4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  182ac8:	e0fffd17 	ldw	r3,-12(fp)
  182acc:	00bfff84 	movi	r2,-2
  182ad0:	1884703a 	and	r2,r3,r2
  182ad4:	1001703a 	wrctl	status,r2

  chSysLock();
  chDbgAssert(tp->p_refs < 255, "chThdAddRef(), #1", "too many references");
  tp->p_refs++;
  182ad8:	e0bfff17 	ldw	r2,-4(fp)
  182adc:	10800783 	ldbu	r2,30(r2)
  182ae0:	10800044 	addi	r2,r2,1
  182ae4:	1007883a 	mov	r3,r2
  182ae8:	e0bfff17 	ldw	r2,-4(fp)
  182aec:	10c00785 	stb	r3,30(r2)
  182af0:	00800044 	movi	r2,1
  182af4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  182af8:	e0bffe17 	ldw	r2,-8(fp)
  182afc:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return tp;
  182b00:	e0bfff17 	ldw	r2,-4(fp)
}
  182b04:	e037883a 	mov	sp,fp
  182b08:	df000017 	ldw	fp,0(sp)
  182b0c:	dec00104 	addi	sp,sp,4
  182b10:	f800283a 	ret

00182b14 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(Thread *tp) {
  182b14:	defffa04 	addi	sp,sp,-24
  182b18:	dfc00515 	stw	ra,20(sp)
  182b1c:	df000415 	stw	fp,16(sp)
  182b20:	df000404 	addi	fp,sp,16
  182b24:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  182b28:	0005303a 	rdctl	r2,status
  182b2c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  182b30:	e0fffd17 	ldw	r3,-12(fp)
  182b34:	00bfff84 	movi	r2,-2
  182b38:	1884703a 	and	r2,r3,r2
  182b3c:	1001703a 	wrctl	status,r2
  trefs_t refs;

  chSysLock();
  chDbgAssert(tp->p_refs > 0, "chThdRelease(), #1", "not referenced");
  refs = --tp->p_refs;
  182b40:	e0bfff17 	ldw	r2,-4(fp)
  182b44:	10800783 	ldbu	r2,30(r2)
  182b48:	10bfffc4 	addi	r2,r2,-1
  182b4c:	1007883a 	mov	r3,r2
  182b50:	e0bfff17 	ldw	r2,-4(fp)
  182b54:	10c00785 	stb	r3,30(r2)
  182b58:	e0bfff17 	ldw	r2,-4(fp)
  182b5c:	10800783 	ldbu	r2,30(r2)
  182b60:	e0bffc05 	stb	r2,-16(fp)
  182b64:	00800044 	movi	r2,1
  182b68:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  182b6c:	e0bffe17 	ldw	r2,-8(fp)
  182b70:	1001703a 	wrctl	status,r2
  chSysUnlock();

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == 0) && (tp->p_state == THD_STATE_FINAL)) {
  182b74:	e0bffc03 	ldbu	r2,-16(fp)
  182b78:	10002b1e 	bne	r2,zero,182c28 <chThdRelease+0x114>
  182b7c:	e0bfff17 	ldw	r2,-4(fp)
  182b80:	10800703 	ldbu	r2,28(r2)
  182b84:	10803fcc 	andi	r2,r2,255
  182b88:	10800398 	cmpnei	r2,r2,14
  182b8c:	1000261e 	bne	r2,zero,182c28 <chThdRelease+0x114>
    switch (tp->p_flags & THD_MEM_MODE_MASK) {
  182b90:	e0bfff17 	ldw	r2,-4(fp)
  182b94:	10800743 	ldbu	r2,29(r2)
  182b98:	10803fcc 	andi	r2,r2,255
  182b9c:	108000cc 	andi	r2,r2,3
  182ba0:	10c00060 	cmpeqi	r3,r2,1
  182ba4:	1800031e 	bne	r3,zero,182bb4 <chThdRelease+0xa0>
  182ba8:	108000a0 	cmpeqi	r2,r2,2
  182bac:	10000e1e 	bne	r2,zero,182be8 <chThdRelease+0xd4>
  182bb0:	00001d06 	br	182c28 <chThdRelease+0x114>
#if CH_USE_HEAP
    case THD_MEM_MODE_HEAP:
#if CH_USE_REGISTRY
      REG_REMOVE(tp);
  182bb4:	e0bfff17 	ldw	r2,-4(fp)
  182bb8:	10800517 	ldw	r2,20(r2)
  182bbc:	e0ffff17 	ldw	r3,-4(fp)
  182bc0:	18c00417 	ldw	r3,16(r3)
  182bc4:	10c00415 	stw	r3,16(r2)
  182bc8:	e0bfff17 	ldw	r2,-4(fp)
  182bcc:	10800417 	ldw	r2,16(r2)
  182bd0:	e0ffff17 	ldw	r3,-4(fp)
  182bd4:	18c00517 	ldw	r3,20(r3)
  182bd8:	10c00515 	stw	r3,20(r2)
#endif
      chHeapFree(tp);
  182bdc:	e13fff17 	ldw	r4,-4(fp)
  182be0:	01830440 	call	183044 <chHeapFree>
      break;
  182be4:	00001006 	br	182c28 <chThdRelease+0x114>
#endif
#if CH_USE_MEMPOOLS
    case THD_MEM_MODE_MEMPOOL:
#if CH_USE_REGISTRY
      REG_REMOVE(tp);
  182be8:	e0bfff17 	ldw	r2,-4(fp)
  182bec:	10800517 	ldw	r2,20(r2)
  182bf0:	e0ffff17 	ldw	r3,-4(fp)
  182bf4:	18c00417 	ldw	r3,16(r3)
  182bf8:	10c00415 	stw	r3,16(r2)
  182bfc:	e0bfff17 	ldw	r2,-4(fp)
  182c00:	10800417 	ldw	r2,16(r2)
  182c04:	e0ffff17 	ldw	r3,-4(fp)
  182c08:	18c00517 	ldw	r3,20(r3)
  182c0c:	10c00515 	stw	r3,20(r2)
#endif
      chPoolFree(tp->p_mpool, tp);
  182c10:	e0bfff17 	ldw	r2,-4(fp)
  182c14:	10801117 	ldw	r2,68(r2)
  182c18:	1009883a 	mov	r4,r2
  182c1c:	e17fff17 	ldw	r5,-4(fp)
  182c20:	01835600 	call	183560 <chPoolFree>
      break;
  182c24:	0001883a 	nop
#endif
    }
  }
}
  182c28:	e037883a 	mov	sp,fp
  182c2c:	dfc00117 	ldw	ra,4(sp)
  182c30:	df000017 	ldw	fp,0(sp)
  182c34:	dec00204 	addi	sp,sp,8
  182c38:	f800283a 	ret

00182c3c <chThdCreateFromHeap>:
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
Thread *chThdCreateFromHeap(MemoryHeap *heapp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
  182c3c:	defff504 	addi	sp,sp,-44
  182c40:	dfc00a15 	stw	ra,40(sp)
  182c44:	df000915 	stw	fp,36(sp)
  182c48:	df000904 	addi	fp,sp,36
  182c4c:	e13ffc15 	stw	r4,-16(fp)
  182c50:	e17ffd15 	stw	r5,-12(fp)
  182c54:	e1bffe15 	stw	r6,-8(fp)
  182c58:	e1ffff15 	stw	r7,-4(fp)
  void *wsp;
  Thread *tp;

  wsp = chHeapAlloc(heapp, size);
  182c5c:	e13ffc17 	ldw	r4,-16(fp)
  182c60:	e17ffd17 	ldw	r5,-12(fp)
  182c64:	0182ea00 	call	182ea0 <chHeapAlloc>
  182c68:	e0bff815 	stw	r2,-32(fp)
  if (wsp == NULL)
  182c6c:	e0bff817 	ldw	r2,-32(fp)
  182c70:	1000021e 	bne	r2,zero,182c7c <chThdCreateFromHeap+0x40>
    return NULL;
  182c74:	0005883a 	mov	r2,zero
  182c78:	00001906 	br	182ce0 <chThdCreateFromHeap+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  182c7c:	0005303a 	rdctl	r2,status
  182c80:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  182c84:	e0fffa17 	ldw	r3,-24(fp)
  182c88:	00bfff84 	movi	r2,-2
  182c8c:	1884703a 	and	r2,r3,r2
  182c90:	1001703a 	wrctl	status,r2
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  
  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  182c94:	e0800217 	ldw	r2,8(fp)
  182c98:	d8800015 	stw	r2,0(sp)
  182c9c:	e13ff817 	ldw	r4,-32(fp)
  182ca0:	e17ffd17 	ldw	r5,-12(fp)
  182ca4:	e1bffe17 	ldw	r6,-8(fp)
  182ca8:	e1ffff17 	ldw	r7,-4(fp)
  182cac:	01807940 	call	180794 <chThdCreateI>
  182cb0:	e0bff915 	stw	r2,-28(fp)
  tp->p_flags = THD_MEM_MODE_HEAP;
  182cb4:	e0bff917 	ldw	r2,-28(fp)
  182cb8:	00c00044 	movi	r3,1
  182cbc:	10c00745 	stb	r3,29(r2)
  chSchWakeupS(tp, RDY_OK);
  182cc0:	e13ff917 	ldw	r4,-28(fp)
  182cc4:	000b883a 	mov	r5,zero
  182cc8:	01840c40 	call	1840c4 <chSchWakeupS>
  182ccc:	00800044 	movi	r2,1
  182cd0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  182cd4:	e0bffb17 	ldw	r2,-20(fp)
  182cd8:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return tp;
  182cdc:	e0bff917 	ldw	r2,-28(fp)
}
  182ce0:	e037883a 	mov	sp,fp
  182ce4:	dfc00117 	ldw	ra,4(sp)
  182ce8:	df000017 	ldw	fp,0(sp)
  182cec:	dec00204 	addi	sp,sp,8
  182cf0:	f800283a 	ret

00182cf4 <chThdCreateFromMemoryPool>:
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
Thread *chThdCreateFromMemoryPool(MemoryPool *mp, tprio_t prio,
                                  tfunc_t pf, void *arg) {
  182cf4:	defff504 	addi	sp,sp,-44
  182cf8:	dfc00a15 	stw	ra,40(sp)
  182cfc:	df000915 	stw	fp,36(sp)
  182d00:	df000904 	addi	fp,sp,36
  182d04:	e13ffc15 	stw	r4,-16(fp)
  182d08:	e17ffd15 	stw	r5,-12(fp)
  182d0c:	e1bffe15 	stw	r6,-8(fp)
  182d10:	e1ffff15 	stw	r7,-4(fp)
  void *wsp;
  Thread *tp;

  chDbgCheck(mp != NULL, "chThdCreateFromMemoryPool");

  wsp = chPoolAlloc(mp);
  182d14:	e13ffc17 	ldw	r4,-16(fp)
  182d18:	01834a80 	call	1834a8 <chPoolAlloc>
  182d1c:	e0bff815 	stw	r2,-32(fp)
  if (wsp == NULL)
  182d20:	e0bff817 	ldw	r2,-32(fp)
  182d24:	1000021e 	bne	r2,zero,182d30 <chThdCreateFromMemoryPool+0x3c>
    return NULL;
  182d28:	0005883a 	mov	r2,zero
  182d2c:	00001e06 	br	182da8 <chThdCreateFromMemoryPool+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  182d30:	0005303a 	rdctl	r2,status
  182d34:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  182d38:	e0fffa17 	ldw	r3,-24(fp)
  182d3c:	00bfff84 	movi	r2,-2
  182d40:	1884703a 	and	r2,r3,r2
  182d44:	1001703a 	wrctl	status,r2
                  (uint8_t *)wsp + mp->mp_object_size,
                  CH_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
  182d48:	e0bffc17 	ldw	r2,-16(fp)
  182d4c:	10800117 	ldw	r2,4(r2)
  182d50:	e0ffff17 	ldw	r3,-4(fp)
  182d54:	d8c00015 	stw	r3,0(sp)
  182d58:	e13ff817 	ldw	r4,-32(fp)
  182d5c:	100b883a 	mov	r5,r2
  182d60:	e1bffd17 	ldw	r6,-12(fp)
  182d64:	e1fffe17 	ldw	r7,-8(fp)
  182d68:	01807940 	call	180794 <chThdCreateI>
  182d6c:	e0bff915 	stw	r2,-28(fp)
  tp->p_flags = THD_MEM_MODE_MEMPOOL;
  182d70:	e0bff917 	ldw	r2,-28(fp)
  182d74:	00c00084 	movi	r3,2
  182d78:	10c00745 	stb	r3,29(r2)
  tp->p_mpool = mp;
  182d7c:	e0bff917 	ldw	r2,-28(fp)
  182d80:	e0fffc17 	ldw	r3,-16(fp)
  182d84:	10c01115 	stw	r3,68(r2)
  chSchWakeupS(tp, RDY_OK);
  182d88:	e13ff917 	ldw	r4,-28(fp)
  182d8c:	000b883a 	mov	r5,zero
  182d90:	01840c40 	call	1840c4 <chSchWakeupS>
  182d94:	00800044 	movi	r2,1
  182d98:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  182d9c:	e0bffb17 	ldw	r2,-20(fp)
  182da0:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return tp;
  182da4:	e0bff917 	ldw	r2,-28(fp)
}
  182da8:	e037883a 	mov	sp,fp
  182dac:	dfc00117 	ldw	ra,4(sp)
  182db0:	df000017 	ldw	fp,0(sp)
  182db4:	dec00204 	addi	sp,sp,8
  182db8:	f800283a 	ret

00182dbc <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
  182dbc:	defffe04 	addi	sp,sp,-8
  182dc0:	dfc00115 	stw	ra,4(sp)
  182dc4:	df000015 	stw	fp,0(sp)
  182dc8:	d839883a 	mov	fp,sp
  default_heap.h_provider = chCoreAlloc;
  182dcc:	00800674 	movhi	r2,25
  182dd0:	10b15e04 	addi	r2,r2,-14984
  182dd4:	00c00634 	movhi	r3,24
  182dd8:	18ccb304 	addi	r3,r3,13004
  182ddc:	10c00015 	stw	r3,0(r2)
  default_heap.h_free.h.u.next = (union heap_header *)NULL;
  182de0:	00800674 	movhi	r2,25
  182de4:	10b15e04 	addi	r2,r2,-14984
  182de8:	10000115 	stw	zero,4(r2)
  default_heap.h_free.h.size = 0;
  182dec:	00800674 	movhi	r2,25
  182df0:	10b15e04 	addi	r2,r2,-14984
  182df4:	10000215 	stw	zero,8(r2)
#if CH_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxInit(&default_heap.h_mtx);
  182df8:	01000674 	movhi	r4,25
  182dfc:	21316104 	addi	r4,r4,-14972
  182e00:	01836f00 	call	1836f0 <chMtxInit>
#else
  chSemInit(&default_heap.h_sem, 1);
#endif
}
  182e04:	e037883a 	mov	sp,fp
  182e08:	dfc00117 	ldw	ra,4(sp)
  182e0c:	df000017 	ldw	fp,0(sp)
  182e10:	dec00204 	addi	sp,sp,8
  182e14:	f800283a 	ret

00182e18 <chHeapInit>:
 * @param[in] buf       heap buffer base
 * @param[in] size      heap size
 *
 * @init
 */
void chHeapInit(MemoryHeap *heapp, void *buf, size_t size) {
  182e18:	defffa04 	addi	sp,sp,-24
  182e1c:	dfc00515 	stw	ra,20(sp)
  182e20:	df000415 	stw	fp,16(sp)
  182e24:	df000404 	addi	fp,sp,16
  182e28:	e13ffd15 	stw	r4,-12(fp)
  182e2c:	e17ffe15 	stw	r5,-8(fp)
  182e30:	e1bfff15 	stw	r6,-4(fp)
  union heap_header *hp;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size), "chHeapInit");
  182e34:	e0bffe17 	ldw	r2,-8(fp)
  182e38:	108000cc 	andi	r2,r2,3
  182e3c:	1000001e 	bne	r2,zero,182e40 <chHeapInit+0x28>

  heapp->h_provider = (memgetfunc_t)NULL;
  182e40:	e0bffd17 	ldw	r2,-12(fp)
  182e44:	10000015 	stw	zero,0(r2)
  heapp->h_free.h.u.next = hp = buf;
  182e48:	e0bffe17 	ldw	r2,-8(fp)
  182e4c:	e0bffc15 	stw	r2,-16(fp)
  182e50:	e0bffd17 	ldw	r2,-12(fp)
  182e54:	e0fffc17 	ldw	r3,-16(fp)
  182e58:	10c00115 	stw	r3,4(r2)
  heapp->h_free.h.size = 0;
  182e5c:	e0bffd17 	ldw	r2,-12(fp)
  182e60:	10000215 	stw	zero,8(r2)
  hp->h.u.next = NULL;
  182e64:	e0bffc17 	ldw	r2,-16(fp)
  182e68:	10000015 	stw	zero,0(r2)
  hp->h.size = size - sizeof(union heap_header);
  182e6c:	e0bfff17 	ldw	r2,-4(fp)
  182e70:	10fffe04 	addi	r3,r2,-8
  182e74:	e0bffc17 	ldw	r2,-16(fp)
  182e78:	10c00115 	stw	r3,4(r2)
#if CH_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxInit(&heapp->h_mtx);
  182e7c:	e0bffd17 	ldw	r2,-12(fp)
  182e80:	10800304 	addi	r2,r2,12
  182e84:	1009883a 	mov	r4,r2
  182e88:	01836f00 	call	1836f0 <chMtxInit>
#else
  chSemInit(&heapp->h_sem, 1);
#endif
}
  182e8c:	e037883a 	mov	sp,fp
  182e90:	dfc00117 	ldw	ra,4(sp)
  182e94:	df000017 	ldw	fp,0(sp)
  182e98:	dec00204 	addi	sp,sp,8
  182e9c:	f800283a 	ret

00182ea0 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(MemoryHeap *heapp, size_t size) {
  182ea0:	defff904 	addi	sp,sp,-28
  182ea4:	dfc00615 	stw	ra,24(sp)
  182ea8:	df000515 	stw	fp,20(sp)
  182eac:	df000504 	addi	fp,sp,20
  182eb0:	e13ffe15 	stw	r4,-8(fp)
  182eb4:	e17fff15 	stw	r5,-4(fp)
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL)
  182eb8:	e0bffe17 	ldw	r2,-8(fp)
  182ebc:	1000031e 	bne	r2,zero,182ecc <chHeapAlloc+0x2c>
    heapp = &default_heap;
  182ec0:	00800674 	movhi	r2,25
  182ec4:	10b15e04 	addi	r2,r2,-14984
  182ec8:	e0bffe15 	stw	r2,-8(fp)

  size = MEM_ALIGN_NEXT(size);
  182ecc:	e0bfff17 	ldw	r2,-4(fp)
  182ed0:	10c000c4 	addi	r3,r2,3
  182ed4:	00bfff04 	movi	r2,-4
  182ed8:	1884703a 	and	r2,r3,r2
  182edc:	e0bfff15 	stw	r2,-4(fp)
  qp = &heapp->h_free;
  182ee0:	e0bffe17 	ldw	r2,-8(fp)
  182ee4:	10800104 	addi	r2,r2,4
  182ee8:	e0bffb15 	stw	r2,-20(fp)
  H_LOCK(heapp);
  182eec:	e0bffe17 	ldw	r2,-8(fp)
  182ef0:	10800304 	addi	r2,r2,12
  182ef4:	1009883a 	mov	r4,r2
  182ef8:	01837340 	call	183734 <chMtxLock>

  while (qp->h.u.next != NULL) {
  182efc:	00003006 	br	182fc0 <chHeapAlloc+0x120>
    hp = qp->h.u.next;
  182f00:	e0bffb17 	ldw	r2,-20(fp)
  182f04:	10800017 	ldw	r2,0(r2)
  182f08:	e0bffc15 	stw	r2,-16(fp)
    if (hp->h.size >= size) {
  182f0c:	e0bffc17 	ldw	r2,-16(fp)
  182f10:	10c00117 	ldw	r3,4(r2)
  182f14:	e0bfff17 	ldw	r2,-4(fp)
  182f18:	18802736 	bltu	r3,r2,182fb8 <chHeapAlloc+0x118>
      if (hp->h.size < size + sizeof(union heap_header)) {
  182f1c:	e0bffc17 	ldw	r2,-16(fp)
  182f20:	10c00117 	ldw	r3,4(r2)
  182f24:	e0bfff17 	ldw	r2,-4(fp)
  182f28:	10800204 	addi	r2,r2,8
  182f2c:	1880052e 	bgeu	r3,r2,182f44 <chHeapAlloc+0xa4>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
  182f30:	e0bffc17 	ldw	r2,-16(fp)
  182f34:	10c00017 	ldw	r3,0(r2)
  182f38:	e0bffb17 	ldw	r2,-20(fp)
  182f3c:	10c00015 	stw	r3,0(r2)
  182f40:	00001606 	br	182f9c <chHeapAlloc+0xfc>
      }
      else {
        /* Block bigger enough, must split it.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
  182f44:	e0bfff17 	ldw	r2,-4(fp)
  182f48:	10800204 	addi	r2,r2,8
  182f4c:	e0fffc17 	ldw	r3,-16(fp)
  182f50:	1885883a 	add	r2,r3,r2
  182f54:	e0bffd15 	stw	r2,-12(fp)
        fp->h.u.next = hp->h.u.next;
  182f58:	e0bffc17 	ldw	r2,-16(fp)
  182f5c:	10c00017 	ldw	r3,0(r2)
  182f60:	e0bffd17 	ldw	r2,-12(fp)
  182f64:	10c00015 	stw	r3,0(r2)
        fp->h.size = hp->h.size - sizeof(union heap_header) - size;
  182f68:	e0bffc17 	ldw	r2,-16(fp)
  182f6c:	10c00117 	ldw	r3,4(r2)
  182f70:	e0bfff17 	ldw	r2,-4(fp)
  182f74:	1885c83a 	sub	r2,r3,r2
  182f78:	10fffe04 	addi	r3,r2,-8
  182f7c:	e0bffd17 	ldw	r2,-12(fp)
  182f80:	10c00115 	stw	r3,4(r2)
        qp->h.u.next = fp;
  182f84:	e0bffb17 	ldw	r2,-20(fp)
  182f88:	e0fffd17 	ldw	r3,-12(fp)
  182f8c:	10c00015 	stw	r3,0(r2)
        hp->h.size = size;
  182f90:	e0bffc17 	ldw	r2,-16(fp)
  182f94:	e0ffff17 	ldw	r3,-4(fp)
  182f98:	10c00115 	stw	r3,4(r2)
      }
      hp->h.u.heap = heapp;
  182f9c:	e0bffc17 	ldw	r2,-16(fp)
  182fa0:	e0fffe17 	ldw	r3,-8(fp)
  182fa4:	10c00015 	stw	r3,0(r2)

      H_UNLOCK(heapp);
  182fa8:	01839c00 	call	1839c0 <chMtxUnlock>
      return (void *)(hp + 1);
  182fac:	e0bffc17 	ldw	r2,-16(fp)
  182fb0:	10800204 	addi	r2,r2,8
  182fb4:	00001e06 	br	183030 <chHeapAlloc+0x190>
    }
    qp = hp;
  182fb8:	e0bffc17 	ldw	r2,-16(fp)
  182fbc:	e0bffb15 	stw	r2,-20(fp)

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;
  H_LOCK(heapp);

  while (qp->h.u.next != NULL) {
  182fc0:	e0bffb17 	ldw	r2,-20(fp)
  182fc4:	10800017 	ldw	r2,0(r2)
  182fc8:	103fcd1e 	bne	r2,zero,182f00 <chHeapAlloc+0x60>
      return (void *)(hp + 1);
    }
    qp = hp;
  }

  H_UNLOCK(heapp);
  182fcc:	01839c00 	call	1839c0 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider) {
  182fd0:	e0bffe17 	ldw	r2,-8(fp)
  182fd4:	10800017 	ldw	r2,0(r2)
  182fd8:	10001426 	beq	r2,zero,18302c <chHeapAlloc+0x18c>
    hp = heapp->h_provider(size + sizeof(union heap_header));
  182fdc:	e0bffe17 	ldw	r2,-8(fp)
  182fe0:	10c00017 	ldw	r3,0(r2)
  182fe4:	e0bfff17 	ldw	r2,-4(fp)
  182fe8:	10800204 	addi	r2,r2,8
  182fec:	1009883a 	mov	r4,r2
  182ff0:	183ee83a 	callr	r3
  182ff4:	e0bffc15 	stw	r2,-16(fp)
    if (hp != NULL) {
  182ff8:	e0bffc17 	ldw	r2,-16(fp)
  182ffc:	10000b26 	beq	r2,zero,18302c <chHeapAlloc+0x18c>
      hp->h.u.heap = heapp;
  183000:	e0bffc17 	ldw	r2,-16(fp)
  183004:	e0fffe17 	ldw	r3,-8(fp)
  183008:	10c00015 	stw	r3,0(r2)
      hp->h.size = size;
  18300c:	e0bffc17 	ldw	r2,-16(fp)
  183010:	e0ffff17 	ldw	r3,-4(fp)
  183014:	10c00115 	stw	r3,4(r2)
      hp++;
  183018:	e0bffc17 	ldw	r2,-16(fp)
  18301c:	10800204 	addi	r2,r2,8
  183020:	e0bffc15 	stw	r2,-16(fp)
      return (void *)hp;
  183024:	e0bffc17 	ldw	r2,-16(fp)
  183028:	00000106 	br	183030 <chHeapAlloc+0x190>
    }
  }
  return NULL;
  18302c:	0005883a 	mov	r2,zero
}
  183030:	e037883a 	mov	sp,fp
  183034:	dfc00117 	ldw	ra,4(sp)
  183038:	df000017 	ldw	fp,0(sp)
  18303c:	dec00204 	addi	sp,sp,8
  183040:	f800283a 	ret

00183044 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
  183044:	defffa04 	addi	sp,sp,-24
  183048:	dfc00515 	stw	ra,20(sp)
  18304c:	df000415 	stw	fp,16(sp)
  183050:	df000404 	addi	fp,sp,16
  183054:	e13fff15 	stw	r4,-4(fp)
  union heap_header *qp, *hp;
  MemoryHeap *heapp;

  chDbgCheck(p != NULL, "chHeapFree");

  hp = (union heap_header *)p - 1;
  183058:	e0bfff17 	ldw	r2,-4(fp)
  18305c:	10bffe04 	addi	r2,r2,-8
  183060:	e0bffd15 	stw	r2,-12(fp)
  heapp = hp->h.u.heap;
  183064:	e0bffd17 	ldw	r2,-12(fp)
  183068:	10800017 	ldw	r2,0(r2)
  18306c:	e0bffe15 	stw	r2,-8(fp)
  qp = &heapp->h_free;
  183070:	e0bffe17 	ldw	r2,-8(fp)
  183074:	10800104 	addi	r2,r2,4
  183078:	e0bffc15 	stw	r2,-16(fp)
  H_LOCK(heapp);
  18307c:	e0bffe17 	ldw	r2,-8(fp)
  183080:	10800304 	addi	r2,r2,12
  183084:	1009883a 	mov	r4,r2
  183088:	01837340 	call	183734 <chMtxLock>

  while (TRUE) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)),
  18308c:	e0fffd17 	ldw	r3,-12(fp)
  183090:	e0bffc17 	ldw	r2,-16(fp)
  183094:	18800036 	bltu	r3,r2,183098 <chHeapFree+0x54>
                "chHeapFree(), #1",
                "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
  183098:	e0bffe17 	ldw	r2,-8(fp)
  18309c:	10c00104 	addi	r3,r2,4
  1830a0:	e0bffc17 	ldw	r2,-16(fp)
  1830a4:	18800326 	beq	r3,r2,1830b4 <chHeapFree+0x70>
  1830a8:	e0bffd17 	ldw	r2,-12(fp)
  1830ac:	e0fffc17 	ldw	r3,-16(fp)
  1830b0:	1880382e 	bgeu	r3,r2,183194 <chHeapFree+0x150>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
  1830b4:	e0bffc17 	ldw	r2,-16(fp)
  1830b8:	10800017 	ldw	r2,0(r2)
  while (TRUE) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)),
                "chHeapFree(), #1",
                "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
  1830bc:	10000426 	beq	r2,zero,1830d0 <chHeapFree+0x8c>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
  1830c0:	e0bffc17 	ldw	r2,-16(fp)
  1830c4:	10800017 	ldw	r2,0(r2)
  1830c8:	e0fffd17 	ldw	r3,-12(fp)
  1830cc:	1880312e 	bgeu	r3,r2,183194 <chHeapFree+0x150>
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
  1830d0:	e0bffc17 	ldw	r2,-16(fp)
  1830d4:	10c00017 	ldw	r3,0(r2)
  1830d8:	e0bffd17 	ldw	r2,-12(fp)
  1830dc:	10c00015 	stw	r3,0(r2)
      qp->h.u.next = hp;
  1830e0:	e0bffc17 	ldw	r2,-16(fp)
  1830e4:	e0fffd17 	ldw	r3,-12(fp)
  1830e8:	10c00015 	stw	r3,0(r2)
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
  1830ec:	e0bffd17 	ldw	r2,-12(fp)
  1830f0:	10800117 	ldw	r2,4(r2)
  1830f4:	10800204 	addi	r2,r2,8
  1830f8:	e0fffd17 	ldw	r3,-12(fp)
  1830fc:	1887883a 	add	r3,r3,r2
  183100:	e0bffd17 	ldw	r2,-12(fp)
  183104:	10800017 	ldw	r2,0(r2)
  183108:	18800e1e 	bne	r3,r2,183144 <chHeapFree+0x100>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
  18310c:	e0bffd17 	ldw	r2,-12(fp)
  183110:	10c00117 	ldw	r3,4(r2)
  183114:	e0bffd17 	ldw	r2,-12(fp)
  183118:	10800017 	ldw	r2,0(r2)
  18311c:	10800117 	ldw	r2,4(r2)
  183120:	1885883a 	add	r2,r3,r2
  183124:	10c00204 	addi	r3,r2,8
  183128:	e0bffd17 	ldw	r2,-12(fp)
  18312c:	10c00115 	stw	r3,4(r2)
        hp->h.u.next = hp->h.u.next->h.u.next;
  183130:	e0bffd17 	ldw	r2,-12(fp)
  183134:	10800017 	ldw	r2,0(r2)
  183138:	10c00017 	ldw	r3,0(r2)
  18313c:	e0bffd17 	ldw	r2,-12(fp)
  183140:	10c00015 	stw	r3,0(r2)
      }
      if ((LIMIT(qp) == hp)) {
  183144:	e0bffc17 	ldw	r2,-16(fp)
  183148:	10800117 	ldw	r2,4(r2)
  18314c:	10800204 	addi	r2,r2,8
  183150:	e0fffc17 	ldw	r3,-16(fp)
  183154:	1887883a 	add	r3,r3,r2
  183158:	e0bffd17 	ldw	r2,-12(fp)
  18315c:	1880111e 	bne	r3,r2,1831a4 <chHeapFree+0x160>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
  183160:	e0bffc17 	ldw	r2,-16(fp)
  183164:	10c00117 	ldw	r3,4(r2)
  183168:	e0bffd17 	ldw	r2,-12(fp)
  18316c:	10800117 	ldw	r2,4(r2)
  183170:	1885883a 	add	r2,r3,r2
  183174:	10c00204 	addi	r3,r2,8
  183178:	e0bffc17 	ldw	r2,-16(fp)
  18317c:	10c00115 	stw	r3,4(r2)
        qp->h.u.next = hp->h.u.next;
  183180:	e0bffd17 	ldw	r2,-12(fp)
  183184:	10c00017 	ldw	r3,0(r2)
  183188:	e0bffc17 	ldw	r2,-16(fp)
  18318c:	10c00015 	stw	r3,0(r2)
      }
      break;
  183190:	00000406 	br	1831a4 <chHeapFree+0x160>
    }
    qp = qp->h.u.next;
  183194:	e0bffc17 	ldw	r2,-16(fp)
  183198:	10800017 	ldw	r2,0(r2)
  18319c:	e0bffc15 	stw	r2,-16(fp)
  }
  1831a0:	003fba06 	br	18308c <chHeapFree+0x48>
      if ((LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
        qp->h.u.next = hp->h.u.next;
      }
      break;
  1831a4:	0001883a 	nop
    }
    qp = qp->h.u.next;
  }

  H_UNLOCK(heapp);
  1831a8:	01839c00 	call	1839c0 <chMtxUnlock>
  return;
  1831ac:	0001883a 	nop
}
  1831b0:	e037883a 	mov	sp,fp
  1831b4:	dfc00117 	ldw	ra,4(sp)
  1831b8:	df000017 	ldw	fp,0(sp)
  1831bc:	dec00204 	addi	sp,sp,8
  1831c0:	f800283a 	ret

001831c4 <chHeapStatus>:
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(MemoryHeap *heapp, size_t *sizep) {
  1831c4:	defff904 	addi	sp,sp,-28
  1831c8:	dfc00615 	stw	ra,24(sp)
  1831cc:	df000515 	stw	fp,20(sp)
  1831d0:	df000504 	addi	fp,sp,20
  1831d4:	e13ffe15 	stw	r4,-8(fp)
  1831d8:	e17fff15 	stw	r5,-4(fp)
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL)
  1831dc:	e0bffe17 	ldw	r2,-8(fp)
  1831e0:	1000031e 	bne	r2,zero,1831f0 <chHeapStatus+0x2c>
    heapp = &default_heap;
  1831e4:	00800674 	movhi	r2,25
  1831e8:	10b15e04 	addi	r2,r2,-14984
  1831ec:	e0bffe15 	stw	r2,-8(fp)

  H_LOCK(heapp);
  1831f0:	e0bffe17 	ldw	r2,-8(fp)
  1831f4:	10800304 	addi	r2,r2,12
  1831f8:	1009883a 	mov	r4,r2
  1831fc:	01837340 	call	183734 <chMtxLock>

  sz = 0;
  183200:	e03ffd15 	stw	zero,-12(fp)
  for (n = 0, qp = &heapp->h_free; qp->h.u.next; n++, qp = qp->h.u.next)
  183204:	e03ffc15 	stw	zero,-16(fp)
  183208:	e0bffe17 	ldw	r2,-8(fp)
  18320c:	10800104 	addi	r2,r2,4
  183210:	e0bffb15 	stw	r2,-20(fp)
  183214:	00000c06 	br	183248 <chHeapStatus+0x84>
    sz += qp->h.u.next->h.size;
  183218:	e0bffb17 	ldw	r2,-20(fp)
  18321c:	10800017 	ldw	r2,0(r2)
  183220:	10800117 	ldw	r2,4(r2)
  183224:	e0fffd17 	ldw	r3,-12(fp)
  183228:	1885883a 	add	r2,r3,r2
  18322c:	e0bffd15 	stw	r2,-12(fp)
    heapp = &default_heap;

  H_LOCK(heapp);

  sz = 0;
  for (n = 0, qp = &heapp->h_free; qp->h.u.next; n++, qp = qp->h.u.next)
  183230:	e0bffc17 	ldw	r2,-16(fp)
  183234:	10800044 	addi	r2,r2,1
  183238:	e0bffc15 	stw	r2,-16(fp)
  18323c:	e0bffb17 	ldw	r2,-20(fp)
  183240:	10800017 	ldw	r2,0(r2)
  183244:	e0bffb15 	stw	r2,-20(fp)
  183248:	e0bffb17 	ldw	r2,-20(fp)
  18324c:	10800017 	ldw	r2,0(r2)
  183250:	103ff11e 	bne	r2,zero,183218 <chHeapStatus+0x54>
    sz += qp->h.u.next->h.size;
  if (sizep)
  183254:	e0bfff17 	ldw	r2,-4(fp)
  183258:	10000326 	beq	r2,zero,183268 <chHeapStatus+0xa4>
    *sizep = sz;
  18325c:	e0bfff17 	ldw	r2,-4(fp)
  183260:	e0fffd17 	ldw	r3,-12(fp)
  183264:	10c00015 	stw	r3,0(r2)

  H_UNLOCK(heapp);
  183268:	01839c00 	call	1839c0 <chMtxUnlock>
  return n;
  18326c:	e0bffc17 	ldw	r2,-16(fp)
}
  183270:	e037883a 	mov	sp,fp
  183274:	dfc00117 	ldw	ra,4(sp)
  183278:	df000017 	ldw	fp,0(sp)
  18327c:	dec00204 	addi	sp,sp,8
  183280:	f800283a 	ret

00183284 <_core_init>:
/**
 * @brief   Low level memory manager initialization.
 *
 * @notapi
 */
void _core_init(void) {
  183284:	deffff04 	addi	sp,sp,-4
  183288:	df000015 	stw	fp,0(sp)
  18328c:	d839883a 	mov	fp,sp
#if CH_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
  183290:	00800674 	movhi	r2,25
  183294:	10b2a504 	addi	r2,r2,-13676
  183298:	10c000c4 	addi	r3,r2,3
  18329c:	00bfff04 	movi	r2,-4
  1832a0:	1884703a 	and	r2,r3,r2
  1832a4:	d0a6d515 	stw	r2,-25772(gp)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
  1832a8:	00c00834 	movhi	r3,32
  1832ac:	18c00004 	addi	r3,r3,0
  1832b0:	00bfff04 	movi	r2,-4
  1832b4:	1884703a 	and	r2,r3,r2
  1832b8:	d0a6d615 	stw	r2,-25768(gp)
#else
  static stkalign_t buffer[MEM_ALIGN_NEXT(CH_MEMCORE_SIZE)/MEM_ALIGN_SIZE];
  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_MEMCORE_SIZE)/MEM_ALIGN_SIZE];
#endif
}
  1832bc:	e037883a 	mov	sp,fp
  1832c0:	df000017 	ldw	fp,0(sp)
  1832c4:	dec00104 	addi	sp,sp,4
  1832c8:	f800283a 	ret

001832cc <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
  1832cc:	defffa04 	addi	sp,sp,-24
  1832d0:	dfc00515 	stw	ra,20(sp)
  1832d4:	df000415 	stw	fp,16(sp)
  1832d8:	df000404 	addi	fp,sp,16
  1832dc:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  1832e0:	0005303a 	rdctl	r2,status
  1832e4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  1832e8:	e0fffd17 	ldw	r3,-12(fp)
  1832ec:	00bfff84 	movi	r2,-2
  1832f0:	1884703a 	and	r2,r3,r2
  1832f4:	1001703a 	wrctl	status,r2
  void *p;

  chSysLock();
  p = chCoreAllocI(size);
  1832f8:	e13fff17 	ldw	r4,-4(fp)
  1832fc:	018332c0 	call	18332c <chCoreAllocI>
  183300:	e0bffc15 	stw	r2,-16(fp)
  183304:	00800044 	movi	r2,1
  183308:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  18330c:	e0bffe17 	ldw	r2,-8(fp)
  183310:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return p;
  183314:	e0bffc17 	ldw	r2,-16(fp)
}
  183318:	e037883a 	mov	sp,fp
  18331c:	dfc00117 	ldw	ra,4(sp)
  183320:	df000017 	ldw	fp,0(sp)
  183324:	dec00204 	addi	sp,sp,8
  183328:	f800283a 	ret

0018332c <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
  18332c:	defffd04 	addi	sp,sp,-12
  183330:	df000215 	stw	fp,8(sp)
  183334:	df000204 	addi	fp,sp,8
  183338:	e13fff15 	stw	r4,-4(fp)
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  18333c:	e0bfff17 	ldw	r2,-4(fp)
  183340:	10c000c4 	addi	r3,r2,3
  183344:	00bfff04 	movi	r2,-4
  183348:	1884703a 	and	r2,r3,r2
  18334c:	e0bfff15 	stw	r2,-4(fp)
  if ((size_t)(endmem - nextmem) < size)
  183350:	d0a6d617 	ldw	r2,-25768(gp)
  183354:	1007883a 	mov	r3,r2
  183358:	d0a6d517 	ldw	r2,-25772(gp)
  18335c:	1885c83a 	sub	r2,r3,r2
  183360:	1007883a 	mov	r3,r2
  183364:	e0bfff17 	ldw	r2,-4(fp)
  183368:	1880022e 	bgeu	r3,r2,183374 <chCoreAllocI+0x48>
    return NULL;
  18336c:	0005883a 	mov	r2,zero
  183370:	00000706 	br	183390 <chCoreAllocI+0x64>
  p = nextmem;
  183374:	d0a6d517 	ldw	r2,-25772(gp)
  183378:	e0bffe15 	stw	r2,-8(fp)
  nextmem += size;
  18337c:	d0e6d517 	ldw	r3,-25772(gp)
  183380:	e0bfff17 	ldw	r2,-4(fp)
  183384:	1885883a 	add	r2,r3,r2
  183388:	d0a6d515 	stw	r2,-25772(gp)
  return p;
  18338c:	e0bffe17 	ldw	r2,-8(fp)
}
  183390:	e037883a 	mov	sp,fp
  183394:	df000017 	ldw	fp,0(sp)
  183398:	dec00104 	addi	sp,sp,4
  18339c:	f800283a 	ret

001833a0 <chCoreStatus>:
 *
 * @return              The size, in bytes, of the free core memory.
 *
 * @api
 */
size_t chCoreStatus(void) {
  1833a0:	deffff04 	addi	sp,sp,-4
  1833a4:	df000015 	stw	fp,0(sp)
  1833a8:	d839883a 	mov	fp,sp

  return (size_t)(endmem - nextmem);
  1833ac:	d0a6d617 	ldw	r2,-25768(gp)
  1833b0:	1007883a 	mov	r3,r2
  1833b4:	d0a6d517 	ldw	r2,-25772(gp)
  1833b8:	1885c83a 	sub	r2,r3,r2
}
  1833bc:	e037883a 	mov	sp,fp
  1833c0:	df000017 	ldw	fp,0(sp)
  1833c4:	dec00104 	addi	sp,sp,4
  1833c8:	f800283a 	ret

001833cc <chPoolInit>:
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolInit(MemoryPool *mp, size_t size, memgetfunc_t provider) {
  1833cc:	defffc04 	addi	sp,sp,-16
  1833d0:	df000315 	stw	fp,12(sp)
  1833d4:	df000304 	addi	fp,sp,12
  1833d8:	e13ffd15 	stw	r4,-12(fp)
  1833dc:	e17ffe15 	stw	r5,-8(fp)
  1833e0:	e1bfff15 	stw	r6,-4(fp)

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)), "chPoolInit");
  1833e4:	e0bffd17 	ldw	r2,-12(fp)
  1833e8:	10000026 	beq	r2,zero,1833ec <chPoolInit+0x20>

  mp->mp_next = NULL;
  1833ec:	e0bffd17 	ldw	r2,-12(fp)
  1833f0:	10000015 	stw	zero,0(r2)
  mp->mp_object_size = MEM_ALIGN_NEXT(size);
  1833f4:	e0bffe17 	ldw	r2,-8(fp)
  1833f8:	10c000c4 	addi	r3,r2,3
  1833fc:	00bfff04 	movi	r2,-4
  183400:	1886703a 	and	r3,r3,r2
  183404:	e0bffd17 	ldw	r2,-12(fp)
  183408:	10c00115 	stw	r3,4(r2)
  mp->mp_provider = provider;
  18340c:	e0bffd17 	ldw	r2,-12(fp)
  183410:	e0ffff17 	ldw	r3,-4(fp)
  183414:	10c00215 	stw	r3,8(r2)
}
  183418:	e037883a 	mov	sp,fp
  18341c:	df000017 	ldw	fp,0(sp)
  183420:	dec00104 	addi	sp,sp,4
  183424:	f800283a 	ret

00183428 <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(MemoryPool *mp) {
  183428:	defffc04 	addi	sp,sp,-16
  18342c:	dfc00315 	stw	ra,12(sp)
  183430:	df000215 	stw	fp,8(sp)
  183434:	df000204 	addi	fp,sp,8
  183438:	e13fff15 	stw	r4,-4(fp)
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL, "chPoolAllocI");

  if ((objp = mp->mp_next) != NULL)
  18343c:	e0bfff17 	ldw	r2,-4(fp)
  183440:	10800017 	ldw	r2,0(r2)
  183444:	e0bffe15 	stw	r2,-8(fp)
  183448:	e0bffe17 	ldw	r2,-8(fp)
  18344c:	10000626 	beq	r2,zero,183468 <chPoolAllocI+0x40>
    mp->mp_next = mp->mp_next->ph_next;
  183450:	e0bfff17 	ldw	r2,-4(fp)
  183454:	10800017 	ldw	r2,0(r2)
  183458:	10c00017 	ldw	r3,0(r2)
  18345c:	e0bfff17 	ldw	r2,-4(fp)
  183460:	10c00015 	stw	r3,0(r2)
  183464:	00000a06 	br	183490 <chPoolAllocI+0x68>
  else if (mp->mp_provider != NULL)
  183468:	e0bfff17 	ldw	r2,-4(fp)
  18346c:	10800217 	ldw	r2,8(r2)
  183470:	10000726 	beq	r2,zero,183490 <chPoolAllocI+0x68>
    objp = mp->mp_provider(mp->mp_object_size);
  183474:	e0bfff17 	ldw	r2,-4(fp)
  183478:	10c00217 	ldw	r3,8(r2)
  18347c:	e0bfff17 	ldw	r2,-4(fp)
  183480:	10800117 	ldw	r2,4(r2)
  183484:	1009883a 	mov	r4,r2
  183488:	183ee83a 	callr	r3
  18348c:	e0bffe15 	stw	r2,-8(fp)
  return objp;
  183490:	e0bffe17 	ldw	r2,-8(fp)
}
  183494:	e037883a 	mov	sp,fp
  183498:	dfc00117 	ldw	ra,4(sp)
  18349c:	df000017 	ldw	fp,0(sp)
  1834a0:	dec00204 	addi	sp,sp,8
  1834a4:	f800283a 	ret

001834a8 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(MemoryPool *mp) {
  1834a8:	defffa04 	addi	sp,sp,-24
  1834ac:	dfc00515 	stw	ra,20(sp)
  1834b0:	df000415 	stw	fp,16(sp)
  1834b4:	df000404 	addi	fp,sp,16
  1834b8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  1834bc:	0005303a 	rdctl	r2,status
  1834c0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  1834c4:	e0fffd17 	ldw	r3,-12(fp)
  1834c8:	00bfff84 	movi	r2,-2
  1834cc:	1884703a 	and	r2,r3,r2
  1834d0:	1001703a 	wrctl	status,r2
  void *objp;

  chSysLock();
  objp = chPoolAllocI(mp);
  1834d4:	e13fff17 	ldw	r4,-4(fp)
  1834d8:	01834280 	call	183428 <chPoolAllocI>
  1834dc:	e0bffc15 	stw	r2,-16(fp)
  1834e0:	00800044 	movi	r2,1
  1834e4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  1834e8:	e0bffe17 	ldw	r2,-8(fp)
  1834ec:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return objp;
  1834f0:	e0bffc17 	ldw	r2,-16(fp)
}
  1834f4:	e037883a 	mov	sp,fp
  1834f8:	dfc00117 	ldw	ra,4(sp)
  1834fc:	df000017 	ldw	fp,0(sp)
  183500:	dec00204 	addi	sp,sp,8
  183504:	f800283a 	ret

00183508 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p MemoryPool structure
 * @param[in] objp      the pointer to the object to be released or added
 *
 * @iclass
 */
void chPoolFreeI(MemoryPool *mp, void *objp) {
  183508:	defffc04 	addi	sp,sp,-16
  18350c:	df000315 	stw	fp,12(sp)
  183510:	df000304 	addi	fp,sp,12
  183514:	e13ffe15 	stw	r4,-8(fp)
  183518:	e17fff15 	stw	r5,-4(fp)
  struct pool_header *php = objp;
  18351c:	e0bfff17 	ldw	r2,-4(fp)
  183520:	e0bffd15 	stw	r2,-12(fp)

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL) && MEM_IS_ALIGNED(objp),
  183524:	e0bffe17 	ldw	r2,-8(fp)
  183528:	10000226 	beq	r2,zero,183534 <chPoolFreeI+0x2c>
  18352c:	e0bfff17 	ldw	r2,-4(fp)
  183530:	10000026 	beq	r2,zero,183534 <chPoolFreeI+0x2c>
             "chPoolFreeI");

  php->ph_next = mp->mp_next;
  183534:	e0bffe17 	ldw	r2,-8(fp)
  183538:	10c00017 	ldw	r3,0(r2)
  18353c:	e0bffd17 	ldw	r2,-12(fp)
  183540:	10c00015 	stw	r3,0(r2)
  mp->mp_next = php;
  183544:	e0bffe17 	ldw	r2,-8(fp)
  183548:	e0fffd17 	ldw	r3,-12(fp)
  18354c:	10c00015 	stw	r3,0(r2)
}
  183550:	e037883a 	mov	sp,fp
  183554:	df000017 	ldw	fp,0(sp)
  183558:	dec00104 	addi	sp,sp,4
  18355c:	f800283a 	ret

00183560 <chPoolFree>:
 * @param[in] mp        pointer to a @p MemoryPool structure
 * @param[in] objp      the pointer to the object to be released or added
 *
 * @api
 */
void chPoolFree(MemoryPool *mp, void *objp) {
  183560:	defffa04 	addi	sp,sp,-24
  183564:	dfc00515 	stw	ra,20(sp)
  183568:	df000415 	stw	fp,16(sp)
  18356c:	df000404 	addi	fp,sp,16
  183570:	e13ffe15 	stw	r4,-8(fp)
  183574:	e17fff15 	stw	r5,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  183578:	0005303a 	rdctl	r2,status
  18357c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  183580:	e0fffc17 	ldw	r3,-16(fp)
  183584:	00bfff84 	movi	r2,-2
  183588:	1884703a 	and	r2,r3,r2
  18358c:	1001703a 	wrctl	status,r2

  chSysLock();
  chPoolFreeI(mp, objp);
  183590:	e13ffe17 	ldw	r4,-8(fp)
  183594:	e17fff17 	ldw	r5,-4(fp)
  183598:	01835080 	call	183508 <chPoolFreeI>
  18359c:	00800044 	movi	r2,1
  1835a0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  1835a4:	e0bffd17 	ldw	r2,-12(fp)
  1835a8:	1001703a 	wrctl	status,r2
  chSysUnlock();
}
  1835ac:	e037883a 	mov	sp,fp
  1835b0:	dfc00117 	ldw	ra,4(sp)
  1835b4:	df000017 	ldw	fp,0(sp)
  1835b8:	dec00204 	addi	sp,sp,8
  1835bc:	f800283a 	ret

001835c0 <prio_insert>:
#define _CHINLINE_H_

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {
  1835c0:	defffc04 	addi	sp,sp,-16
  1835c4:	df000315 	stw	fp,12(sp)
  1835c8:	df000304 	addi	fp,sp,12
  1835cc:	e13ffe15 	stw	r4,-8(fp)
  1835d0:	e17fff15 	stw	r5,-4(fp)

  Thread *cp = (Thread *)tqp;
  1835d4:	e0bfff17 	ldw	r2,-4(fp)
  1835d8:	e0bffd15 	stw	r2,-12(fp)
  do {
    cp = cp->p_next;
  1835dc:	e0bffd17 	ldw	r2,-12(fp)
  1835e0:	10800017 	ldw	r2,0(r2)
  1835e4:	e0bffd15 	stw	r2,-12(fp)
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
  1835e8:	e0fffd17 	ldw	r3,-12(fp)
  1835ec:	e0bfff17 	ldw	r2,-4(fp)
  1835f0:	18800526 	beq	r3,r2,183608 <prio_insert+0x48>
  1835f4:	e0bffd17 	ldw	r2,-12(fp)
  1835f8:	10c00217 	ldw	r3,8(r2)
  1835fc:	e0bffe17 	ldw	r2,-8(fp)
  183600:	10800217 	ldw	r2,8(r2)
  183604:	18bff52e 	bgeu	r3,r2,1835dc <prio_insert+0x1c>
  tp->p_next = cp;
  183608:	e0bffe17 	ldw	r2,-8(fp)
  18360c:	e0fffd17 	ldw	r3,-12(fp)
  183610:	10c00015 	stw	r3,0(r2)
  tp->p_prev = cp->p_prev;
  183614:	e0bffd17 	ldw	r2,-12(fp)
  183618:	10c00117 	ldw	r3,4(r2)
  18361c:	e0bffe17 	ldw	r2,-8(fp)
  183620:	10c00115 	stw	r3,4(r2)
  tp->p_prev->p_next = cp->p_prev = tp;
  183624:	e0bffe17 	ldw	r2,-8(fp)
  183628:	10800117 	ldw	r2,4(r2)
  18362c:	e0fffd17 	ldw	r3,-12(fp)
  183630:	e13ffe17 	ldw	r4,-8(fp)
  183634:	19000115 	stw	r4,4(r3)
  183638:	e0fffd17 	ldw	r3,-12(fp)
  18363c:	18c00117 	ldw	r3,4(r3)
  183640:	10c00015 	stw	r3,0(r2)
}
  183644:	e037883a 	mov	sp,fp
  183648:	df000017 	ldw	fp,0(sp)
  18364c:	dec00104 	addi	sp,sp,4
  183650:	f800283a 	ret

00183654 <fifo_remove>:
  tp->p_next = (Thread *)tqp;
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  183654:	defffd04 	addi	sp,sp,-12
  183658:	df000215 	stw	fp,8(sp)
  18365c:	df000204 	addi	fp,sp,8
  183660:	e13fff15 	stw	r4,-4(fp)
  Thread *tp = tqp->p_next;
  183664:	e0bfff17 	ldw	r2,-4(fp)
  183668:	10800017 	ldw	r2,0(r2)
  18366c:	e0bffe15 	stw	r2,-8(fp)

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
  183670:	e0bffe17 	ldw	r2,-8(fp)
  183674:	10c00017 	ldw	r3,0(r2)
  183678:	e0bfff17 	ldw	r2,-4(fp)
  18367c:	10c00015 	stw	r3,0(r2)
  183680:	e0bfff17 	ldw	r2,-4(fp)
  183684:	10800017 	ldw	r2,0(r2)
  183688:	e0ffff17 	ldw	r3,-4(fp)
  18368c:	10c00115 	stw	r3,4(r2)
  return tp;
  183690:	e0bffe17 	ldw	r2,-8(fp)
}
  183694:	e037883a 	mov	sp,fp
  183698:	df000017 	ldw	fp,0(sp)
  18369c:	dec00104 	addi	sp,sp,4
  1836a0:	f800283a 	ret

001836a4 <dequeue>:

  (tqp->p_prev = tp->p_prev)->p_next = (Thread *)tqp;
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {
  1836a4:	defffe04 	addi	sp,sp,-8
  1836a8:	df000115 	stw	fp,4(sp)
  1836ac:	df000104 	addi	fp,sp,4
  1836b0:	e13fff15 	stw	r4,-4(fp)

  tp->p_prev->p_next = tp->p_next;
  1836b4:	e0bfff17 	ldw	r2,-4(fp)
  1836b8:	10800117 	ldw	r2,4(r2)
  1836bc:	e0ffff17 	ldw	r3,-4(fp)
  1836c0:	18c00017 	ldw	r3,0(r3)
  1836c4:	10c00015 	stw	r3,0(r2)
  tp->p_next->p_prev = tp->p_prev;
  1836c8:	e0bfff17 	ldw	r2,-4(fp)
  1836cc:	10800017 	ldw	r2,0(r2)
  1836d0:	e0ffff17 	ldw	r3,-4(fp)
  1836d4:	18c00117 	ldw	r3,4(r3)
  1836d8:	10c00115 	stw	r3,4(r2)
  return tp;
  1836dc:	e0bfff17 	ldw	r2,-4(fp)
}
  1836e0:	e037883a 	mov	sp,fp
  1836e4:	df000017 	ldw	fp,0(sp)
  1836e8:	dec00104 	addi	sp,sp,4
  1836ec:	f800283a 	ret

001836f0 <chMtxInit>:
 *
 * @param[out] mp       pointer to a @p Mutex structure
 *
 * @init
 */
void chMtxInit(Mutex *mp) {
  1836f0:	defffe04 	addi	sp,sp,-8
  1836f4:	df000115 	stw	fp,4(sp)
  1836f8:	df000104 	addi	fp,sp,4
  1836fc:	e13fff15 	stw	r4,-4(fp)

  chDbgCheck(mp != NULL, "chMtxInit");

  queue_init(&mp->m_queue);
  183700:	e0ffff17 	ldw	r3,-4(fp)
  183704:	e0bfff17 	ldw	r2,-4(fp)
  183708:	10c00115 	stw	r3,4(r2)
  18370c:	e0bfff17 	ldw	r2,-4(fp)
  183710:	10c00117 	ldw	r3,4(r2)
  183714:	e0bfff17 	ldw	r2,-4(fp)
  183718:	10c00015 	stw	r3,0(r2)
  mp->m_owner = NULL;
  18371c:	e0bfff17 	ldw	r2,-4(fp)
  183720:	10000215 	stw	zero,8(r2)
}
  183724:	e037883a 	mov	sp,fp
  183728:	df000017 	ldw	fp,0(sp)
  18372c:	dec00104 	addi	sp,sp,4
  183730:	f800283a 	ret

00183734 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p Mutex structure
 *
 * @api
 */
void chMtxLock(Mutex *mp) {
  183734:	defffb04 	addi	sp,sp,-20
  183738:	dfc00415 	stw	ra,16(sp)
  18373c:	df000315 	stw	fp,12(sp)
  183740:	df000304 	addi	fp,sp,12
  183744:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  183748:	0005303a 	rdctl	r2,status
  18374c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  183750:	e0fffd17 	ldw	r3,-12(fp)
  183754:	00bfff84 	movi	r2,-2
  183758:	1884703a 	and	r2,r3,r2
  18375c:	1001703a 	wrctl	status,r2

  chSysLock();

  chMtxLockS(mp);
  183760:	e13fff17 	ldw	r4,-4(fp)
  183764:	018378c0 	call	18378c <chMtxLockS>
  183768:	00800044 	movi	r2,1
  18376c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  183770:	e0bffe17 	ldw	r2,-8(fp)
  183774:	1001703a 	wrctl	status,r2

  chSysUnlock();
}
  183778:	e037883a 	mov	sp,fp
  18377c:	dfc00117 	ldw	ra,4(sp)
  183780:	df000017 	ldw	fp,0(sp)
  183784:	dec00204 	addi	sp,sp,8
  183788:	f800283a 	ret

0018378c <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p Mutex structure
 *
 * @sclass
 */
void chMtxLockS(Mutex *mp) {
  18378c:	defffb04 	addi	sp,sp,-20
  183790:	dfc00415 	stw	ra,16(sp)
  183794:	df000315 	stw	fp,12(sp)
  183798:	df000304 	addi	fp,sp,12
  18379c:	e13fff15 	stw	r4,-4(fp)
  Thread *ctp = currp;
  1837a0:	00800674 	movhi	r2,25
  1837a4:	10b18704 	addi	r2,r2,-14820
  1837a8:	10800717 	ldw	r2,28(r2)
  1837ac:	e0bffe15 	stw	r2,-8(fp)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxLockS");

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
  1837b0:	e0bfff17 	ldw	r2,-4(fp)
  1837b4:	10800217 	ldw	r2,8(r2)
  1837b8:	10003c26 	beq	r2,zero,1838ac <chMtxLockS+0x120>
    /* Priority inheritance protocol; explores the thread-mutex dependencies
       boosting the priority of all the affected threads to equal the priority
       of the running thread requesting the mutex.*/
    Thread *tp = mp->m_owner;
  1837bc:	e0bfff17 	ldw	r2,-4(fp)
  1837c0:	10800217 	ldw	r2,8(r2)
  1837c4:	e0bffd15 	stw	r2,-12(fp)
    /* Does the running thread have higher priority than the mutex
       owning thread? */
    while (tp->p_prio < ctp->p_prio) {
  1837c8:	00002906 	br	183870 <chMtxLockS+0xe4>
      /* Make priority of thread tp match the running thread's priority.*/
      tp->p_prio = ctp->p_prio;
  1837cc:	e0bffe17 	ldw	r2,-8(fp)
  1837d0:	10c00217 	ldw	r3,8(r2)
  1837d4:	e0bffd17 	ldw	r2,-12(fp)
  1837d8:	10c00215 	stw	r3,8(r2)
      /* The following states need priority queues reordering.*/
      switch (tp->p_state) {
  1837dc:	e0bffd17 	ldw	r2,-12(fp)
  1837e0:	10800703 	ldbu	r2,28(r2)
  1837e4:	10803fcc 	andi	r2,r2,255
  1837e8:	10c00120 	cmpeqi	r3,r2,4
  1837ec:	1800041e 	bne	r3,zero,183800 <chMtxLockS+0x74>
  1837f0:	10c00160 	cmpeqi	r3,r2,5
  1837f4:	18000f1e 	bne	r3,zero,183834 <chMtxLockS+0xa8>
  1837f8:	10001726 	beq	r2,zero,183858 <chMtxLockS+0xcc>
  1837fc:	00001b06 	br	18386c <chMtxLockS+0xe0>
      case THD_STATE_WTMTX:
        /* Re-enqueues the mutex owner with its new priority.*/
        prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
  183800:	e13ffd17 	ldw	r4,-12(fp)
  183804:	01836a40 	call	1836a4 <dequeue>
  183808:	1007883a 	mov	r3,r2
  18380c:	e0bffd17 	ldw	r2,-12(fp)
  183810:	10800917 	ldw	r2,36(r2)
  183814:	1809883a 	mov	r4,r3
  183818:	100b883a 	mov	r5,r2
  18381c:	01835c00 	call	1835c0 <prio_insert>
        tp = ((Mutex *)tp->p_u.wtobjp)->m_owner;
  183820:	e0bffd17 	ldw	r2,-12(fp)
  183824:	10800917 	ldw	r2,36(r2)
  183828:	10800217 	ldw	r2,8(r2)
  18382c:	e0bffd15 	stw	r2,-12(fp)
        continue;
  183830:	00000f06 	br	183870 <chMtxLockS+0xe4>
#endif
#if CH_USE_MESSAGES && CH_USE_MESSAGES_PRIORITY
      case THD_STATE_SNDMSGQ:
#endif
        /* Re-enqueues tp with its new priority on the queue.*/
        prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
  183834:	e13ffd17 	ldw	r4,-12(fp)
  183838:	01836a40 	call	1836a4 <dequeue>
  18383c:	1007883a 	mov	r3,r2
  183840:	e0bffd17 	ldw	r2,-12(fp)
  183844:	10800917 	ldw	r2,36(r2)
  183848:	1809883a 	mov	r4,r3
  18384c:	100b883a 	mov	r5,r2
  183850:	01835c00 	call	1835c0 <prio_insert>
        break;
  183854:	00000506 	br	18386c <chMtxLockS+0xe0>
#if CH_DBG_ENABLE_ASSERTS
        /* Prevents an assertion in chSchReadyI().*/
        tp->p_state = THD_STATE_CURRENT;
#endif
        /* Re-enqueues tp with its new priority on the ready list.*/
        chSchReadyI(dequeue(tp));
  183858:	e13ffd17 	ldw	r4,-12(fp)
  18385c:	01836a40 	call	1836a4 <dequeue>
  183860:	1009883a 	mov	r4,r2
  183864:	0183e580 	call	183e58 <chSchReadyI>
        break;
  183868:	0001883a 	nop
      }
      break;
  18386c:	00000506 	br	183884 <chMtxLockS+0xf8>
       boosting the priority of all the affected threads to equal the priority
       of the running thread requesting the mutex.*/
    Thread *tp = mp->m_owner;
    /* Does the running thread have higher priority than the mutex
       owning thread? */
    while (tp->p_prio < ctp->p_prio) {
  183870:	e0bffd17 	ldw	r2,-12(fp)
  183874:	10c00217 	ldw	r3,8(r2)
  183878:	e0bffe17 	ldw	r2,-8(fp)
  18387c:	10800217 	ldw	r2,8(r2)
  183880:	18bfd236 	bltu	r3,r2,1837cc <chMtxLockS+0x40>
        break;
      }
      break;
    }
    /* Sleep on the mutex.*/
    prio_insert(ctp, &mp->m_queue);
  183884:	e0bfff17 	ldw	r2,-4(fp)
  183888:	e13ffe17 	ldw	r4,-8(fp)
  18388c:	100b883a 	mov	r5,r2
  183890:	01835c00 	call	1835c0 <prio_insert>
    ctp->p_u.wtobjp = mp;
  183894:	e0bffe17 	ldw	r2,-8(fp)
  183898:	e0ffff17 	ldw	r3,-4(fp)
  18389c:	10c00915 	stw	r3,36(r2)
    chSchGoSleepS(THD_STATE_WTMTX);
  1838a0:	01000104 	movi	r4,4
  1838a4:	0183eec0 	call	183eec <chSchGoSleepS>
  1838a8:	00000a06 	br	1838d4 <chMtxLockS+0x148>
    chDbgAssert(mp->m_owner == ctp, "chMtxLockS(), #1", "not owner");
    chDbgAssert(ctp->p_mtxlist == mp, "chMtxLockS(), #2", "not owned");
  }
  else {
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
  1838ac:	e0bfff17 	ldw	r2,-4(fp)
  1838b0:	e0fffe17 	ldw	r3,-8(fp)
  1838b4:	10c00215 	stw	r3,8(r2)
    mp->m_next = ctp->p_mtxlist;
  1838b8:	e0bffe17 	ldw	r2,-8(fp)
  1838bc:	10c00f17 	ldw	r3,60(r2)
  1838c0:	e0bfff17 	ldw	r2,-4(fp)
  1838c4:	10c00315 	stw	r3,12(r2)
    ctp->p_mtxlist = mp;
  1838c8:	e0bffe17 	ldw	r2,-8(fp)
  1838cc:	e0ffff17 	ldw	r3,-4(fp)
  1838d0:	10c00f15 	stw	r3,60(r2)
  }
}
  1838d4:	e037883a 	mov	sp,fp
  1838d8:	dfc00117 	ldw	ra,4(sp)
  1838dc:	df000017 	ldw	fp,0(sp)
  1838e0:	dec00204 	addi	sp,sp,8
  1838e4:	f800283a 	ret

001838e8 <chMtxTryLock>:
 * @retval TRUE         if the mutex has been successfully acquired
 * @retval FALSE        if the lock attempt failed.
 *
 * @api
 */
bool_t chMtxTryLock(Mutex *mp) {
  1838e8:	defffa04 	addi	sp,sp,-24
  1838ec:	dfc00515 	stw	ra,20(sp)
  1838f0:	df000415 	stw	fp,16(sp)
  1838f4:	df000404 	addi	fp,sp,16
  1838f8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  1838fc:	0005303a 	rdctl	r2,status
  183900:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  183904:	e0fffd17 	ldw	r3,-12(fp)
  183908:	00bfff84 	movi	r2,-2
  18390c:	1884703a 	and	r2,r3,r2
  183910:	1001703a 	wrctl	status,r2
  bool_t b;

  chSysLock();

  b = chMtxTryLockS(mp);
  183914:	e13fff17 	ldw	r4,-4(fp)
  183918:	01839480 	call	183948 <chMtxTryLockS>
  18391c:	e0bffc15 	stw	r2,-16(fp)
  183920:	00800044 	movi	r2,1
  183924:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  183928:	e0bffe17 	ldw	r2,-8(fp)
  18392c:	1001703a 	wrctl	status,r2

  chSysUnlock();
  return b;
  183930:	e0bffc17 	ldw	r2,-16(fp)
}
  183934:	e037883a 	mov	sp,fp
  183938:	dfc00117 	ldw	ra,4(sp)
  18393c:	df000017 	ldw	fp,0(sp)
  183940:	dec00204 	addi	sp,sp,8
  183944:	f800283a 	ret

00183948 <chMtxTryLockS>:
 * @retval TRUE         if the mutex has been successfully acquired
 * @retval FALSE        if the lock attempt failed.
 *
 * @sclass
 */
bool_t chMtxTryLockS(Mutex *mp) {
  183948:	defffe04 	addi	sp,sp,-8
  18394c:	df000115 	stw	fp,4(sp)
  183950:	df000104 	addi	fp,sp,4
  183954:	e13fff15 	stw	r4,-4(fp)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxTryLockS");

  if (mp->m_owner != NULL)
  183958:	e0bfff17 	ldw	r2,-4(fp)
  18395c:	10800217 	ldw	r2,8(r2)
  183960:	10000226 	beq	r2,zero,18396c <chMtxTryLockS+0x24>
    return FALSE;
  183964:	0005883a 	mov	r2,zero
  183968:	00001106 	br	1839b0 <chMtxTryLockS+0x68>
  mp->m_owner = currp;
  18396c:	00800674 	movhi	r2,25
  183970:	10b18704 	addi	r2,r2,-14820
  183974:	10c00717 	ldw	r3,28(r2)
  183978:	e0bfff17 	ldw	r2,-4(fp)
  18397c:	10c00215 	stw	r3,8(r2)
  mp->m_next = currp->p_mtxlist;
  183980:	00800674 	movhi	r2,25
  183984:	10b18704 	addi	r2,r2,-14820
  183988:	10800717 	ldw	r2,28(r2)
  18398c:	10c00f17 	ldw	r3,60(r2)
  183990:	e0bfff17 	ldw	r2,-4(fp)
  183994:	10c00315 	stw	r3,12(r2)
  currp->p_mtxlist = mp;
  183998:	00800674 	movhi	r2,25
  18399c:	10b18704 	addi	r2,r2,-14820
  1839a0:	10800717 	ldw	r2,28(r2)
  1839a4:	e0ffff17 	ldw	r3,-4(fp)
  1839a8:	10c00f15 	stw	r3,60(r2)
  return TRUE;
  1839ac:	00800044 	movi	r2,1
}
  1839b0:	e037883a 	mov	sp,fp
  1839b4:	df000017 	ldw	fp,0(sp)
  1839b8:	dec00104 	addi	sp,sp,4
  1839bc:	f800283a 	ret

001839c0 <chMtxUnlock>:
 *
 * @return              A pointer to the unlocked mutex.
 *
 * @api
 */
Mutex *chMtxUnlock(void) {
  1839c0:	defff704 	addi	sp,sp,-36
  1839c4:	dfc00815 	stw	ra,32(sp)
  1839c8:	df000715 	stw	fp,28(sp)
  1839cc:	df000704 	addi	fp,sp,28
  Thread *ctp = currp;
  1839d0:	00800674 	movhi	r2,25
  1839d4:	10b18704 	addi	r2,r2,-14820
  1839d8:	10800717 	ldw	r2,28(r2)
  1839dc:	e0bffb15 	stw	r2,-20(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  1839e0:	0005303a 	rdctl	r2,status
  1839e4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  1839e8:	e0fffe17 	ldw	r3,-8(fp)
  1839ec:	00bfff84 	movi	r2,-2
  1839f0:	1884703a 	and	r2,r3,r2
  1839f4:	1001703a 	wrctl	status,r2
  chDbgAssert(ctp->p_mtxlist->m_owner == ctp,
              "chMtxUnlock(), #2",
              "ownership failure");
  /* Removes the top Mutex from the Thread's owned mutexes list and mark it
     as not owned.*/
  ump = ctp->p_mtxlist;
  1839f8:	e0bffb17 	ldw	r2,-20(fp)
  1839fc:	10800f17 	ldw	r2,60(r2)
  183a00:	e0bffc15 	stw	r2,-16(fp)
  ctp->p_mtxlist = ump->m_next;
  183a04:	e0bffc17 	ldw	r2,-16(fp)
  183a08:	10c00317 	ldw	r3,12(r2)
  183a0c:	e0bffb17 	ldw	r2,-20(fp)
  183a10:	10c00f15 	stw	r3,60(r2)
  /* If a thread is waiting on the mutex then the fun part begins.*/
  if (chMtxQueueNotEmptyS(ump)) {
  183a14:	e0bffc17 	ldw	r2,-16(fp)
  183a18:	10c00017 	ldw	r3,0(r2)
  183a1c:	e0bffc17 	ldw	r2,-16(fp)
  183a20:	18802e26 	beq	r3,r2,183adc <chMtxUnlock+0x11c>
    Thread *tp;

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
  183a24:	e0bffb17 	ldw	r2,-20(fp)
  183a28:	10801017 	ldw	r2,64(r2)
  183a2c:	e0bffa15 	stw	r2,-24(fp)
    mp = ctp->p_mtxlist;
  183a30:	e0bffb17 	ldw	r2,-20(fp)
  183a34:	10800f17 	ldw	r2,60(r2)
  183a38:	e0bff915 	stw	r2,-28(fp)
    while (mp != NULL) {
  183a3c:	00001006 	br	183a80 <chMtxUnlock+0xc0>
      /* If the highest priority thread waiting in the mutexes list has a
         greater priority than the current thread base priority then the final
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
  183a40:	e0bff917 	ldw	r2,-28(fp)
  183a44:	10c00017 	ldw	r3,0(r2)
  183a48:	e0bff917 	ldw	r2,-28(fp)
  183a4c:	18800926 	beq	r3,r2,183a74 <chMtxUnlock+0xb4>
  183a50:	e0bff917 	ldw	r2,-28(fp)
  183a54:	10800017 	ldw	r2,0(r2)
  183a58:	10800217 	ldw	r2,8(r2)
  183a5c:	e0fffa17 	ldw	r3,-24(fp)
  183a60:	1880042e 	bgeu	r3,r2,183a74 <chMtxUnlock+0xb4>
        newprio = mp->m_queue.p_next->p_prio;
  183a64:	e0bff917 	ldw	r2,-28(fp)
  183a68:	10800017 	ldw	r2,0(r2)
  183a6c:	10800217 	ldw	r2,8(r2)
  183a70:	e0bffa15 	stw	r2,-24(fp)
      mp = mp->m_next;
  183a74:	e0bff917 	ldw	r2,-28(fp)
  183a78:	10800317 	ldw	r2,12(r2)
  183a7c:	e0bff915 	stw	r2,-28(fp)

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
  183a80:	e0bff917 	ldw	r2,-28(fp)
  183a84:	103fee1e 	bne	r2,zero,183a40 <chMtxUnlock+0x80>
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
    }
    /* Assigns to the current thread the highest priority among all the
       waiting threads.*/
    ctp->p_prio = newprio;
  183a88:	e0bffb17 	ldw	r2,-20(fp)
  183a8c:	e0fffa17 	ldw	r3,-24(fp)
  183a90:	10c00215 	stw	r3,8(r2)
    /* Awakens the highest priority thread waiting for the unlocked mutex and
       assigns the mutex to it.*/
    tp = fifo_remove(&ump->m_queue);
  183a94:	e0bffc17 	ldw	r2,-16(fp)
  183a98:	1009883a 	mov	r4,r2
  183a9c:	01836540 	call	183654 <fifo_remove>
  183aa0:	e0bffd15 	stw	r2,-12(fp)
    ump->m_owner = tp;
  183aa4:	e0bffc17 	ldw	r2,-16(fp)
  183aa8:	e0fffd17 	ldw	r3,-12(fp)
  183aac:	10c00215 	stw	r3,8(r2)
    ump->m_next = tp->p_mtxlist;
  183ab0:	e0bffd17 	ldw	r2,-12(fp)
  183ab4:	10c00f17 	ldw	r3,60(r2)
  183ab8:	e0bffc17 	ldw	r2,-16(fp)
  183abc:	10c00315 	stw	r3,12(r2)
    tp->p_mtxlist = ump;
  183ac0:	e0bffd17 	ldw	r2,-12(fp)
  183ac4:	e0fffc17 	ldw	r3,-16(fp)
  183ac8:	10c00f15 	stw	r3,60(r2)
    chSchWakeupS(tp, RDY_OK);
  183acc:	e13ffd17 	ldw	r4,-12(fp)
  183ad0:	000b883a 	mov	r5,zero
  183ad4:	01840c40 	call	1840c4 <chSchWakeupS>
  183ad8:	00000206 	br	183ae4 <chMtxUnlock+0x124>
  }
  else
    ump->m_owner = NULL;
  183adc:	e0bffc17 	ldw	r2,-16(fp)
  183ae0:	10000215 	stw	zero,8(r2)
  183ae4:	00800044 	movi	r2,1
  183ae8:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  183aec:	e0bfff17 	ldw	r2,-4(fp)
  183af0:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return ump;
  183af4:	e0bffc17 	ldw	r2,-16(fp)
}
  183af8:	e037883a 	mov	sp,fp
  183afc:	dfc00117 	ldw	ra,4(sp)
  183b00:	df000017 	ldw	fp,0(sp)
  183b04:	dec00204 	addi	sp,sp,8
  183b08:	f800283a 	ret

00183b0c <chMtxUnlockS>:
 *
 * @return              A pointer to the unlocked mutex.
 *
 * @sclass
 */
Mutex *chMtxUnlockS(void) {
  183b0c:	defff904 	addi	sp,sp,-28
  183b10:	dfc00615 	stw	ra,24(sp)
  183b14:	df000515 	stw	fp,20(sp)
  183b18:	df000504 	addi	fp,sp,20
  Thread *ctp = currp;
  183b1c:	00800674 	movhi	r2,25
  183b20:	10b18704 	addi	r2,r2,-14820
  183b24:	10800717 	ldw	r2,28(r2)
  183b28:	e0bffd15 	stw	r2,-12(fp)
              "chMtxUnlockS(), #2",
              "ownership failure");

  /* Removes the top Mutex from the owned mutexes list and marks it as not
     owned.*/
  ump = ctp->p_mtxlist;
  183b2c:	e0bffd17 	ldw	r2,-12(fp)
  183b30:	10800f17 	ldw	r2,60(r2)
  183b34:	e0bffe15 	stw	r2,-8(fp)
  ctp->p_mtxlist = ump->m_next;
  183b38:	e0bffe17 	ldw	r2,-8(fp)
  183b3c:	10c00317 	ldw	r3,12(r2)
  183b40:	e0bffd17 	ldw	r2,-12(fp)
  183b44:	10c00f15 	stw	r3,60(r2)
  /* If a thread is waiting on the mutex then the fun part begins.*/
  if (chMtxQueueNotEmptyS(ump)) {
  183b48:	e0bffe17 	ldw	r2,-8(fp)
  183b4c:	10c00017 	ldw	r3,0(r2)
  183b50:	e0bffe17 	ldw	r2,-8(fp)
  183b54:	18802d26 	beq	r3,r2,183c0c <chMtxUnlockS+0x100>
    Thread *tp;

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
  183b58:	e0bffd17 	ldw	r2,-12(fp)
  183b5c:	10801017 	ldw	r2,64(r2)
  183b60:	e0bffc15 	stw	r2,-16(fp)
    mp = ctp->p_mtxlist;
  183b64:	e0bffd17 	ldw	r2,-12(fp)
  183b68:	10800f17 	ldw	r2,60(r2)
  183b6c:	e0bffb15 	stw	r2,-20(fp)
    while (mp != NULL) {
  183b70:	00001006 	br	183bb4 <chMtxUnlockS+0xa8>
      /* If the highest priority thread waiting in the mutexes list has a
         greater priority than the current thread base priority then the final
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
  183b74:	e0bffb17 	ldw	r2,-20(fp)
  183b78:	10c00017 	ldw	r3,0(r2)
  183b7c:	e0bffb17 	ldw	r2,-20(fp)
  183b80:	18800926 	beq	r3,r2,183ba8 <chMtxUnlockS+0x9c>
  183b84:	e0bffb17 	ldw	r2,-20(fp)
  183b88:	10800017 	ldw	r2,0(r2)
  183b8c:	10800217 	ldw	r2,8(r2)
  183b90:	e0fffc17 	ldw	r3,-16(fp)
  183b94:	1880042e 	bgeu	r3,r2,183ba8 <chMtxUnlockS+0x9c>
        newprio = mp->m_queue.p_next->p_prio;
  183b98:	e0bffb17 	ldw	r2,-20(fp)
  183b9c:	10800017 	ldw	r2,0(r2)
  183ba0:	10800217 	ldw	r2,8(r2)
  183ba4:	e0bffc15 	stw	r2,-16(fp)
      mp = mp->m_next;
  183ba8:	e0bffb17 	ldw	r2,-20(fp)
  183bac:	10800317 	ldw	r2,12(r2)
  183bb0:	e0bffb15 	stw	r2,-20(fp)

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
  183bb4:	e0bffb17 	ldw	r2,-20(fp)
  183bb8:	103fee1e 	bne	r2,zero,183b74 <chMtxUnlockS+0x68>
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
    }
    ctp->p_prio = newprio;
  183bbc:	e0bffd17 	ldw	r2,-12(fp)
  183bc0:	e0fffc17 	ldw	r3,-16(fp)
  183bc4:	10c00215 	stw	r3,8(r2)
    /* Awakens the highest priority thread waiting for the unlocked mutex and
       assigns the mutex to it.*/
    tp = fifo_remove(&ump->m_queue);
  183bc8:	e0bffe17 	ldw	r2,-8(fp)
  183bcc:	1009883a 	mov	r4,r2
  183bd0:	01836540 	call	183654 <fifo_remove>
  183bd4:	e0bfff15 	stw	r2,-4(fp)
    ump->m_owner = tp;
  183bd8:	e0bffe17 	ldw	r2,-8(fp)
  183bdc:	e0ffff17 	ldw	r3,-4(fp)
  183be0:	10c00215 	stw	r3,8(r2)
    ump->m_next = tp->p_mtxlist;
  183be4:	e0bfff17 	ldw	r2,-4(fp)
  183be8:	10c00f17 	ldw	r3,60(r2)
  183bec:	e0bffe17 	ldw	r2,-8(fp)
  183bf0:	10c00315 	stw	r3,12(r2)
    tp->p_mtxlist = ump;
  183bf4:	e0bfff17 	ldw	r2,-4(fp)
  183bf8:	e0fffe17 	ldw	r3,-8(fp)
  183bfc:	10c00f15 	stw	r3,60(r2)
    chSchReadyI(tp);
  183c00:	e13fff17 	ldw	r4,-4(fp)
  183c04:	0183e580 	call	183e58 <chSchReadyI>
  183c08:	00000206 	br	183c14 <chMtxUnlockS+0x108>
  }
  else
    ump->m_owner = NULL;
  183c0c:	e0bffe17 	ldw	r2,-8(fp)
  183c10:	10000215 	stw	zero,8(r2)
  return ump;
  183c14:	e0bffe17 	ldw	r2,-8(fp)
}
  183c18:	e037883a 	mov	sp,fp
  183c1c:	dfc00117 	ldw	ra,4(sp)
  183c20:	df000017 	ldw	fp,0(sp)
  183c24:	dec00204 	addi	sp,sp,8
  183c28:	f800283a 	ret

00183c2c <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
  183c2c:	defff904 	addi	sp,sp,-28
  183c30:	dfc00615 	stw	ra,24(sp)
  183c34:	df000515 	stw	fp,20(sp)
  183c38:	df000504 	addi	fp,sp,20
  Thread *ctp = currp;
  183c3c:	00800674 	movhi	r2,25
  183c40:	10b18704 	addi	r2,r2,-14820
  183c44:	10800717 	ldw	r2,28(r2)
  183c48:	e0bffb15 	stw	r2,-20(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  183c4c:	0005303a 	rdctl	r2,status
  183c50:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  183c54:	e0fffe17 	ldw	r3,-8(fp)
  183c58:	00bfff84 	movi	r2,-2
  183c5c:	1884703a 	and	r2,r3,r2
  183c60:	1001703a 	wrctl	status,r2

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
  183c64:	e0bffb17 	ldw	r2,-20(fp)
  183c68:	10800f17 	ldw	r2,60(r2)
  183c6c:	10002626 	beq	r2,zero,183d08 <chMtxUnlockAll+0xdc>
    do {
      Mutex *ump = ctp->p_mtxlist;
  183c70:	e0bffb17 	ldw	r2,-20(fp)
  183c74:	10800f17 	ldw	r2,60(r2)
  183c78:	e0bffc15 	stw	r2,-16(fp)
      ctp->p_mtxlist = ump->m_next;
  183c7c:	e0bffc17 	ldw	r2,-16(fp)
  183c80:	10c00317 	ldw	r3,12(r2)
  183c84:	e0bffb17 	ldw	r2,-20(fp)
  183c88:	10c00f15 	stw	r3,60(r2)
      if (chMtxQueueNotEmptyS(ump)) {
  183c8c:	e0bffc17 	ldw	r2,-16(fp)
  183c90:	10c00017 	ldw	r3,0(r2)
  183c94:	e0bffc17 	ldw	r2,-16(fp)
  183c98:	18801126 	beq	r3,r2,183ce0 <chMtxUnlockAll+0xb4>
        Thread *tp = fifo_remove(&ump->m_queue);
  183c9c:	e0bffc17 	ldw	r2,-16(fp)
  183ca0:	1009883a 	mov	r4,r2
  183ca4:	01836540 	call	183654 <fifo_remove>
  183ca8:	e0bffd15 	stw	r2,-12(fp)
        ump->m_owner = tp;
  183cac:	e0bffc17 	ldw	r2,-16(fp)
  183cb0:	e0fffd17 	ldw	r3,-12(fp)
  183cb4:	10c00215 	stw	r3,8(r2)
        ump->m_next = tp->p_mtxlist;
  183cb8:	e0bffd17 	ldw	r2,-12(fp)
  183cbc:	10c00f17 	ldw	r3,60(r2)
  183cc0:	e0bffc17 	ldw	r2,-16(fp)
  183cc4:	10c00315 	stw	r3,12(r2)
        tp->p_mtxlist = ump;
  183cc8:	e0bffd17 	ldw	r2,-12(fp)
  183ccc:	e0fffc17 	ldw	r3,-16(fp)
  183cd0:	10c00f15 	stw	r3,60(r2)
        chSchReadyI(tp);
  183cd4:	e13ffd17 	ldw	r4,-12(fp)
  183cd8:	0183e580 	call	183e58 <chSchReadyI>
  183cdc:	00000206 	br	183ce8 <chMtxUnlockAll+0xbc>
      }
      else
        ump->m_owner = NULL;
  183ce0:	e0bffc17 	ldw	r2,-16(fp)
  183ce4:	10000215 	stw	zero,8(r2)
    } while (ctp->p_mtxlist != NULL);
  183ce8:	e0bffb17 	ldw	r2,-20(fp)
  183cec:	10800f17 	ldw	r2,60(r2)
  183cf0:	103fdf1e 	bne	r2,zero,183c70 <chMtxUnlockAll+0x44>
    ctp->p_prio = ctp->p_realprio;
  183cf4:	e0bffb17 	ldw	r2,-20(fp)
  183cf8:	10c01017 	ldw	r3,64(r2)
  183cfc:	e0bffb17 	ldw	r2,-20(fp)
  183d00:	10c00215 	stw	r3,8(r2)
    chSchRescheduleS();
  183d04:	01841740 	call	184174 <chSchRescheduleS>
  183d08:	00800044 	movi	r2,1
  183d0c:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  183d10:	e0bfff17 	ldw	r2,-4(fp)
  183d14:	1001703a 	wrctl	status,r2
  }
  chSysUnlock();
}
  183d18:	e037883a 	mov	sp,fp
  183d1c:	dfc00117 	ldw	ra,4(sp)
  183d20:	df000017 	ldw	fp,0(sp)
  183d24:	dec00204 	addi	sp,sp,8
  183d28:	f800283a 	ret

00183d2c <fifo_remove>:
  tp->p_next = (Thread *)tqp;
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  183d2c:	defffd04 	addi	sp,sp,-12
  183d30:	df000215 	stw	fp,8(sp)
  183d34:	df000204 	addi	fp,sp,8
  183d38:	e13fff15 	stw	r4,-4(fp)
  Thread *tp = tqp->p_next;
  183d3c:	e0bfff17 	ldw	r2,-4(fp)
  183d40:	10800017 	ldw	r2,0(r2)
  183d44:	e0bffe15 	stw	r2,-8(fp)

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
  183d48:	e0bffe17 	ldw	r2,-8(fp)
  183d4c:	10c00017 	ldw	r3,0(r2)
  183d50:	e0bfff17 	ldw	r2,-4(fp)
  183d54:	10c00015 	stw	r3,0(r2)
  183d58:	e0bfff17 	ldw	r2,-4(fp)
  183d5c:	10800017 	ldw	r2,0(r2)
  183d60:	e0ffff17 	ldw	r3,-4(fp)
  183d64:	10c00115 	stw	r3,4(r2)
  return tp;
  183d68:	e0bffe17 	ldw	r2,-8(fp)
}
  183d6c:	e037883a 	mov	sp,fp
  183d70:	df000017 	ldw	fp,0(sp)
  183d74:	dec00104 	addi	sp,sp,4
  183d78:	f800283a 	ret

00183d7c <dequeue>:

  (tqp->p_prev = tp->p_prev)->p_next = (Thread *)tqp;
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {
  183d7c:	defffe04 	addi	sp,sp,-8
  183d80:	df000115 	stw	fp,4(sp)
  183d84:	df000104 	addi	fp,sp,4
  183d88:	e13fff15 	stw	r4,-4(fp)

  tp->p_prev->p_next = tp->p_next;
  183d8c:	e0bfff17 	ldw	r2,-4(fp)
  183d90:	10800117 	ldw	r2,4(r2)
  183d94:	e0ffff17 	ldw	r3,-4(fp)
  183d98:	18c00017 	ldw	r3,0(r3)
  183d9c:	10c00015 	stw	r3,0(r2)
  tp->p_next->p_prev = tp->p_prev;
  183da0:	e0bfff17 	ldw	r2,-4(fp)
  183da4:	10800017 	ldw	r2,0(r2)
  183da8:	e0ffff17 	ldw	r3,-4(fp)
  183dac:	18c00117 	ldw	r3,4(r3)
  183db0:	10c00115 	stw	r3,4(r2)
  return tp;
  183db4:	e0bfff17 	ldw	r2,-4(fp)
}
  183db8:	e037883a 	mov	sp,fp
  183dbc:	df000017 	ldw	fp,0(sp)
  183dc0:	dec00104 	addi	sp,sp,4
  183dc4:	f800283a 	ret

00183dc8 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
  183dc8:	deffff04 	addi	sp,sp,-4
  183dcc:	df000015 	stw	fp,0(sp)
  183dd0:	d839883a 	mov	fp,sp

  queue_init(&rlist.r_queue);
  183dd4:	00800674 	movhi	r2,25
  183dd8:	10b18704 	addi	r2,r2,-14820
  183ddc:	00c00674 	movhi	r3,25
  183de0:	18f18704 	addi	r3,r3,-14820
  183de4:	10c00115 	stw	r3,4(r2)
  183de8:	00800674 	movhi	r2,25
  183dec:	10b18704 	addi	r2,r2,-14820
  183df0:	10c00117 	ldw	r3,4(r2)
  183df4:	00800674 	movhi	r2,25
  183df8:	10b18704 	addi	r2,r2,-14820
  183dfc:	10c00015 	stw	r3,0(r2)
  rlist.r_prio = NOPRIO;
  183e00:	00800674 	movhi	r2,25
  183e04:	10b18704 	addi	r2,r2,-14820
  183e08:	10000215 	stw	zero,8(r2)
#if CH_TIME_QUANTUM > 0
  rlist.r_preempt = CH_TIME_QUANTUM;
  183e0c:	00800674 	movhi	r2,25
  183e10:	10b18704 	addi	r2,r2,-14820
  183e14:	00c00504 	movi	r3,20
  183e18:	10c00615 	stw	r3,24(r2)
#endif
#if CH_USE_REGISTRY
  rlist.r_newer = rlist.r_older = (Thread *)&rlist;
  183e1c:	00800674 	movhi	r2,25
  183e20:	10b18704 	addi	r2,r2,-14820
  183e24:	00c00674 	movhi	r3,25
  183e28:	18f18704 	addi	r3,r3,-14820
  183e2c:	10c00515 	stw	r3,20(r2)
  183e30:	00800674 	movhi	r2,25
  183e34:	10b18704 	addi	r2,r2,-14820
  183e38:	10c00517 	ldw	r3,20(r2)
  183e3c:	00800674 	movhi	r2,25
  183e40:	10b18704 	addi	r2,r2,-14820
  183e44:	10c00415 	stw	r3,16(r2)
#endif
}
  183e48:	e037883a 	mov	sp,fp
  183e4c:	df000017 	ldw	fp,0(sp)
  183e50:	dec00104 	addi	sp,sp,4
  183e54:	f800283a 	ret

00183e58 <chSchReadyI>:
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
  183e58:	defffd04 	addi	sp,sp,-12
  183e5c:	df000215 	stw	fp,8(sp)
  183e60:	df000204 	addi	fp,sp,8
  183e64:	e13fff15 	stw	r4,-4(fp)
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
  183e68:	e0bfff17 	ldw	r2,-4(fp)
  183e6c:	10000705 	stb	zero,28(r2)
  cp = (Thread *)&rlist.r_queue;
  183e70:	00800674 	movhi	r2,25
  183e74:	10b18704 	addi	r2,r2,-14820
  183e78:	e0bffe15 	stw	r2,-8(fp)
  do {
    cp = cp->p_next;
  183e7c:	e0bffe17 	ldw	r2,-8(fp)
  183e80:	10800017 	ldw	r2,0(r2)
  183e84:	e0bffe15 	stw	r2,-8(fp)
  } while (cp->p_prio >= tp->p_prio);
  183e88:	e0bffe17 	ldw	r2,-8(fp)
  183e8c:	10c00217 	ldw	r3,8(r2)
  183e90:	e0bfff17 	ldw	r2,-4(fp)
  183e94:	10800217 	ldw	r2,8(r2)
  183e98:	18bff82e 	bgeu	r3,r2,183e7c <chSchReadyI+0x24>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  183e9c:	e0bfff17 	ldw	r2,-4(fp)
  183ea0:	e0fffe17 	ldw	r3,-8(fp)
  183ea4:	10c00015 	stw	r3,0(r2)
  tp->p_prev = cp->p_prev;
  183ea8:	e0bffe17 	ldw	r2,-8(fp)
  183eac:	10c00117 	ldw	r3,4(r2)
  183eb0:	e0bfff17 	ldw	r2,-4(fp)
  183eb4:	10c00115 	stw	r3,4(r2)
  tp->p_prev->p_next = cp->p_prev = tp;
  183eb8:	e0bfff17 	ldw	r2,-4(fp)
  183ebc:	10800117 	ldw	r2,4(r2)
  183ec0:	e0fffe17 	ldw	r3,-8(fp)
  183ec4:	e13fff17 	ldw	r4,-4(fp)
  183ec8:	19000115 	stw	r4,4(r3)
  183ecc:	e0fffe17 	ldw	r3,-8(fp)
  183ed0:	18c00117 	ldw	r3,4(r3)
  183ed4:	10c00015 	stw	r3,0(r2)
  return tp;
  183ed8:	e0bfff17 	ldw	r2,-4(fp)
}
  183edc:	e037883a 	mov	sp,fp
  183ee0:	df000017 	ldw	fp,0(sp)
  183ee4:	dec00104 	addi	sp,sp,4
  183ee8:	f800283a 	ret

00183eec <chSchGoSleepS>:
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_GOSLEEPS) || defined(__DOXYGEN__)
void chSchGoSleepS(tstate_t newstate) {
  183eec:	defffc04 	addi	sp,sp,-16
  183ef0:	dfc00315 	stw	ra,12(sp)
  183ef4:	df000215 	stw	fp,8(sp)
  183ef8:	df000204 	addi	fp,sp,8
  183efc:	2005883a 	mov	r2,r4
  183f00:	e0bfff05 	stb	r2,-4(fp)
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
  183f04:	00800674 	movhi	r2,25
  183f08:	10b18704 	addi	r2,r2,-14820
  183f0c:	10800717 	ldw	r2,28(r2)
  183f10:	e0bffe15 	stw	r2,-8(fp)
  183f14:	e0bffe17 	ldw	r2,-8(fp)
  183f18:	e0ffff03 	ldbu	r3,-4(fp)
  183f1c:	10c00705 	stb	r3,28(r2)
#if CH_TIME_QUANTUM > 0
  rlist.r_preempt = CH_TIME_QUANTUM;
  183f20:	00800674 	movhi	r2,25
  183f24:	10b18704 	addi	r2,r2,-14820
  183f28:	00c00504 	movi	r3,20
  183f2c:	10c00615 	stw	r3,24(r2)
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
  183f30:	01000674 	movhi	r4,25
  183f34:	21318704 	addi	r4,r4,-14820
  183f38:	0183d2c0 	call	183d2c <fifo_remove>
  183f3c:	00c00674 	movhi	r3,25
  183f40:	18f18704 	addi	r3,r3,-14820
  183f44:	18800715 	stw	r2,28(r3)
  currp->p_state = THD_STATE_CURRENT;
  183f48:	00800674 	movhi	r2,25
  183f4c:	10b18704 	addi	r2,r2,-14820
  183f50:	10800717 	ldw	r2,28(r2)
  183f54:	00c00044 	movi	r3,1
  183f58:	10c00705 	stb	r3,28(r2)
  chSysSwitch(currp, otp);
  183f5c:	00800674 	movhi	r2,25
  183f60:	10b18704 	addi	r2,r2,-14820
  183f64:	10800717 	ldw	r2,28(r2)
  183f68:	1009883a 	mov	r4,r2
  183f6c:	e17ffe17 	ldw	r5,-8(fp)
  183f70:	01810a00 	call	1810a0 <port_switch>
}
  183f74:	e037883a 	mov	sp,fp
  183f78:	dfc00117 	ldw	ra,4(sp)
  183f7c:	df000017 	ldw	fp,0(sp)
  183f80:	dec00204 	addi	sp,sp,8
  183f84:	f800283a 	ret

00183f88 <wakeup>:

#if !defined(PORT_OPTIMIZED_GOSLEEPTIMEOUTS) || defined(__DOXYGEN__)
/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
  183f88:	defffc04 	addi	sp,sp,-16
  183f8c:	dfc00315 	stw	ra,12(sp)
  183f90:	df000215 	stw	fp,8(sp)
  183f94:	df000204 	addi	fp,sp,8
  183f98:	e13fff15 	stw	r4,-4(fp)
  Thread *tp = (Thread *)p;
  183f9c:	e0bfff17 	ldw	r2,-4(fp)
  183fa0:	e0bffe15 	stw	r2,-8(fp)

  switch (tp->p_state) {
  183fa4:	e0bffe17 	ldw	r2,-8(fp)
  183fa8:	10800703 	ldbu	r2,28(r2)
  183fac:	10803fcc 	andi	r2,r2,255
  183fb0:	10c000e0 	cmpeqi	r3,r2,3
  183fb4:	1800091e 	bne	r3,zero,183fdc <wakeup+0x54>
  183fb8:	10c00108 	cmpgei	r3,r2,4
  183fbc:	1800021e 	bne	r3,zero,183fc8 <wakeup+0x40>
  183fc0:	10001326 	beq	r2,zero,184010 <wakeup+0x88>
  183fc4:	00000c06 	br	183ff8 <wakeup+0x70>
  183fc8:	10c00160 	cmpeqi	r3,r2,5
  183fcc:	1800081e 	bne	r3,zero,183ff0 <wakeup+0x68>
  183fd0:	10800360 	cmpeqi	r2,r2,13
  183fd4:	1000061e 	bne	r2,zero,183ff0 <wakeup+0x68>
  183fd8:	00000706 	br	183ff8 <wakeup+0x70>
    return;
#if CH_USE_SEMAPHORES || CH_USE_QUEUES ||                                   \
    (CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT)
#if CH_USE_SEMAPHORES
  case THD_STATE_WTSEM:
    chSemFastSignalI((Semaphore *)tp->p_u.wtobjp);
  183fdc:	e0bffe17 	ldw	r2,-8(fp)
  183fe0:	10800917 	ldw	r2,36(r2)
  183fe4:	10c00217 	ldw	r3,8(r2)
  183fe8:	18c00044 	addi	r3,r3,1
  183fec:	10c00215 	stw	r3,8(r2)
#endif
#if CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT
  case THD_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    dequeue(tp);
  183ff0:	e13ffe17 	ldw	r4,-8(fp)
  183ff4:	0183d7c0 	call	183d7c <dequeue>
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
  183ff8:	e0bffe17 	ldw	r2,-8(fp)
  183ffc:	00ffffc4 	movi	r3,-1
  184000:	10c00915 	stw	r3,36(r2)
  chSchReadyI(tp);
  184004:	e13ffe17 	ldw	r4,-8(fp)
  184008:	0183e580 	call	183e58 <chSchReadyI>
  18400c:	00000106 	br	184014 <wakeup+0x8c>

  switch (tp->p_state) {
  case THD_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    return;
  184010:	0001883a 	nop
    dequeue(tp);
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
  chSchReadyI(tp);
}
  184014:	e037883a 	mov	sp,fp
  184018:	dfc00117 	ldw	ra,4(sp)
  18401c:	df000017 	ldw	fp,0(sp)
  184020:	dec00204 	addi	sp,sp,8
  184024:	f800283a 	ret

00184028 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval RDY_TIMEOUT if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
  184028:	defff704 	addi	sp,sp,-36
  18402c:	dfc00815 	stw	ra,32(sp)
  184030:	df000715 	stw	fp,28(sp)
  184034:	df000704 	addi	fp,sp,28
  184038:	2005883a 	mov	r2,r4
  18403c:	e17fff15 	stw	r5,-4(fp)
  184040:	e0bffe05 	stb	r2,-8(fp)

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
  184044:	e0bfff17 	ldw	r2,-4(fp)
  184048:	10bfffe0 	cmpeqi	r2,r2,-1
  18404c:	1000111e 	bne	r2,zero,184094 <chSchGoSleepTimeoutS+0x6c>
    VirtualTimer vt;

    chVTSetI(&vt, time, wakeup, currp);
  184050:	00800674 	movhi	r2,25
  184054:	10b18704 	addi	r2,r2,-14820
  184058:	10800717 	ldw	r2,28(r2)
  18405c:	e13ff904 	addi	r4,fp,-28
  184060:	e17fff17 	ldw	r5,-4(fp)
  184064:	01800634 	movhi	r6,24
  184068:	318fe204 	addi	r6,r6,16264
  18406c:	100f883a 	mov	r7,r2
  184070:	0180e6c0 	call	180e6c <chVTSetI>
    chSchGoSleepS(newstate);
  184074:	e0bffe03 	ldbu	r2,-8(fp)
  184078:	1009883a 	mov	r4,r2
  18407c:	0183eec0 	call	183eec <chSchGoSleepS>
    if (chVTIsArmedI(&vt))
  184080:	e0bffc17 	ldw	r2,-16(fp)
  184084:	10000626 	beq	r2,zero,1840a0 <chSchGoSleepTimeoutS+0x78>
      chVTResetI(&vt);
  184088:	e13ff904 	addi	r4,fp,-28
  18408c:	0180f780 	call	180f78 <chVTResetI>
  184090:	00000306 	br	1840a0 <chSchGoSleepTimeoutS+0x78>
  }
  else
    chSchGoSleepS(newstate);
  184094:	e0bffe03 	ldbu	r2,-8(fp)
  184098:	1009883a 	mov	r4,r2
  18409c:	0183eec0 	call	183eec <chSchGoSleepS>
  return currp->p_u.rdymsg;
  1840a0:	00800674 	movhi	r2,25
  1840a4:	10b18704 	addi	r2,r2,-14820
  1840a8:	10800717 	ldw	r2,28(r2)
  1840ac:	10800917 	ldw	r2,36(r2)
}
  1840b0:	e037883a 	mov	sp,fp
  1840b4:	dfc00117 	ldw	ra,4(sp)
  1840b8:	df000017 	ldw	fp,0(sp)
  1840bc:	dec00204 	addi	sp,sp,8
  1840c0:	f800283a 	ret

001840c4 <chSchWakeupS>:
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
  1840c4:	defffb04 	addi	sp,sp,-20
  1840c8:	dfc00415 	stw	ra,16(sp)
  1840cc:	df000315 	stw	fp,12(sp)
  1840d0:	df000304 	addi	fp,sp,12
  1840d4:	e13ffe15 	stw	r4,-8(fp)
  1840d8:	e17fff15 	stw	r5,-4(fp)

  chDbgCheckClassS();

  ntp->p_u.rdymsg = msg;
  1840dc:	e0bffe17 	ldw	r2,-8(fp)
  1840e0:	e0ffff17 	ldw	r3,-4(fp)
  1840e4:	10c00915 	stw	r3,36(r2)
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
  1840e8:	e0bffe17 	ldw	r2,-8(fp)
  1840ec:	10800217 	ldw	r2,8(r2)
  1840f0:	00c00674 	movhi	r3,25
  1840f4:	18f18704 	addi	r3,r3,-14820
  1840f8:	18c00717 	ldw	r3,28(r3)
  1840fc:	18c00217 	ldw	r3,8(r3)
  184100:	18800336 	bltu	r3,r2,184110 <chSchWakeupS+0x4c>
    chSchReadyI(ntp);
  184104:	e13ffe17 	ldw	r4,-8(fp)
  184108:	0183e580 	call	183e58 <chSchReadyI>
  18410c:	00001406 	br	184160 <chSchWakeupS+0x9c>
  else {
    Thread *otp = chSchReadyI(currp);
  184110:	00800674 	movhi	r2,25
  184114:	10b18704 	addi	r2,r2,-14820
  184118:	10800717 	ldw	r2,28(r2)
  18411c:	1009883a 	mov	r4,r2
  184120:	0183e580 	call	183e58 <chSchReadyI>
  184124:	e0bffd15 	stw	r2,-12(fp)
#if CH_TIME_QUANTUM > 0
    rlist.r_preempt = CH_TIME_QUANTUM;
  184128:	00800674 	movhi	r2,25
  18412c:	10b18704 	addi	r2,r2,-14820
  184130:	00c00504 	movi	r3,20
  184134:	10c00615 	stw	r3,24(r2)
#endif
    setcurrp(ntp);
  184138:	00800674 	movhi	r2,25
  18413c:	10b18704 	addi	r2,r2,-14820
  184140:	e0fffe17 	ldw	r3,-8(fp)
  184144:	10c00715 	stw	r3,28(r2)
    ntp->p_state = THD_STATE_CURRENT;
  184148:	e0bffe17 	ldw	r2,-8(fp)
  18414c:	00c00044 	movi	r3,1
  184150:	10c00705 	stb	r3,28(r2)
    chSysSwitch(ntp, otp);
  184154:	e13ffe17 	ldw	r4,-8(fp)
  184158:	e17ffd17 	ldw	r5,-12(fp)
  18415c:	01810a00 	call	1810a0 <port_switch>
  }
}
  184160:	e037883a 	mov	sp,fp
  184164:	dfc00117 	ldw	ra,4(sp)
  184168:	df000017 	ldw	fp,0(sp)
  18416c:	dec00204 	addi	sp,sp,8
  184170:	f800283a 	ret

00184174 <chSchRescheduleS>:
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_RESCHEDULES) || defined(__DOXYGEN__)
void chSchRescheduleS(void) {
  184174:	defffe04 	addi	sp,sp,-8
  184178:	dfc00115 	stw	ra,4(sp)
  18417c:	df000015 	stw	fp,0(sp)
  184180:	d839883a 	mov	fp,sp

  chDbgCheckClassS();

  if (chSchIsRescRequiredI())
  184184:	00800674 	movhi	r2,25
  184188:	10b18704 	addi	r2,r2,-14820
  18418c:	10800017 	ldw	r2,0(r2)
  184190:	10800217 	ldw	r2,8(r2)
  184194:	00c00674 	movhi	r3,25
  184198:	18f18704 	addi	r3,r3,-14820
  18419c:	18c00717 	ldw	r3,28(r3)
  1841a0:	18c00217 	ldw	r3,8(r3)
  1841a4:	1880012e 	bgeu	r3,r2,1841ac <chSchRescheduleS+0x38>
    chSchDoReschedule();
  1841a8:	01842380 	call	184238 <chSchDoReschedule>
}
  1841ac:	e037883a 	mov	sp,fp
  1841b0:	dfc00117 	ldw	ra,4(sp)
  1841b4:	df000017 	ldw	fp,0(sp)
  1841b8:	dec00204 	addi	sp,sp,8
  1841bc:	f800283a 	ret

001841c0 <chSchIsPreemptionRequired>:
 * @retval FALSE        if preemption is not required.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_ISPREEMPTIONREQUIRED) || defined(__DOXYGEN__)
bool_t chSchIsPreemptionRequired(void) {
  1841c0:	defffd04 	addi	sp,sp,-12
  1841c4:	df000215 	stw	fp,8(sp)
  1841c8:	df000204 	addi	fp,sp,8
  tprio_t p1 = firstprio(&rlist.r_queue);
  1841cc:	00800674 	movhi	r2,25
  1841d0:	10b18704 	addi	r2,r2,-14820
  1841d4:	10800017 	ldw	r2,0(r2)
  1841d8:	10800217 	ldw	r2,8(r2)
  1841dc:	e0bffe15 	stw	r2,-8(fp)
  tprio_t p2 = currp->p_prio;
  1841e0:	00800674 	movhi	r2,25
  1841e4:	10b18704 	addi	r2,r2,-14820
  1841e8:	10800717 	ldw	r2,28(r2)
  1841ec:	10800217 	ldw	r2,8(r2)
  1841f0:	e0bfff15 	stw	r2,-4(fp)
#if CH_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return rlist.r_preempt ? p1 > p2 : p1 >= p2;
  1841f4:	00800674 	movhi	r2,25
  1841f8:	10b18704 	addi	r2,r2,-14820
  1841fc:	10800617 	ldw	r2,24(r2)
  184200:	10000526 	beq	r2,zero,184218 <chSchIsPreemptionRequired+0x58>
  184204:	e0bffe17 	ldw	r2,-8(fp)
  184208:	e0ffff17 	ldw	r3,-4(fp)
  18420c:	1885803a 	cmpltu	r2,r3,r2
  184210:	10803fcc 	andi	r2,r2,255
  184214:	00000406 	br	184228 <chSchIsPreemptionRequired+0x68>
  184218:	e0fffe17 	ldw	r3,-8(fp)
  18421c:	e0bfff17 	ldw	r2,-4(fp)
  184220:	1885403a 	cmpgeu	r2,r3,r2
  184224:	10803fcc 	andi	r2,r2,255
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
  184228:	e037883a 	mov	sp,fp
  18422c:	df000017 	ldw	fp,0(sp)
  184230:	dec00104 	addi	sp,sp,4
  184234:	f800283a 	ret

00184238 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULE) || defined(__DOXYGEN__)
void chSchDoReschedule(void) {
  184238:	defffd04 	addi	sp,sp,-12
  18423c:	dfc00215 	stw	ra,8(sp)
  184240:	df000115 	stw	fp,4(sp)
  184244:	df000104 	addi	fp,sp,4
  Thread *otp;

#if CH_TIME_QUANTUM > 0
  rlist.r_preempt = CH_TIME_QUANTUM;
  184248:	00800674 	movhi	r2,25
  18424c:	10b18704 	addi	r2,r2,-14820
  184250:	00c00504 	movi	r3,20
  184254:	10c00615 	stw	r3,24(r2)
#endif
  otp = currp;
  184258:	00800674 	movhi	r2,25
  18425c:	10b18704 	addi	r2,r2,-14820
  184260:	10800717 	ldw	r2,28(r2)
  184264:	e0bfff15 	stw	r2,-4(fp)
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
  184268:	01000674 	movhi	r4,25
  18426c:	21318704 	addi	r4,r4,-14820
  184270:	0183d2c0 	call	183d2c <fifo_remove>
  184274:	00c00674 	movhi	r3,25
  184278:	18f18704 	addi	r3,r3,-14820
  18427c:	18800715 	stw	r2,28(r3)
  currp->p_state = THD_STATE_CURRENT;
  184280:	00800674 	movhi	r2,25
  184284:	10b18704 	addi	r2,r2,-14820
  184288:	10800717 	ldw	r2,28(r2)
  18428c:	00c00044 	movi	r3,1
  184290:	10c00705 	stb	r3,28(r2)
  chSchReadyI(otp);
  184294:	e13fff17 	ldw	r4,-4(fp)
  184298:	0183e580 	call	183e58 <chSchReadyI>
  chSysSwitch(currp, otp);
  18429c:	00800674 	movhi	r2,25
  1842a0:	10b18704 	addi	r2,r2,-14820
  1842a4:	10800717 	ldw	r2,28(r2)
  1842a8:	1009883a 	mov	r4,r2
  1842ac:	e17fff17 	ldw	r5,-4(fp)
  1842b0:	01810a00 	call	1810a0 <port_switch>
}
  1842b4:	e037883a 	mov	sp,fp
  1842b8:	dfc00117 	ldw	ra,4(sp)
  1842bc:	df000017 	ldw	fp,0(sp)
  1842c0:	dec00204 	addi	sp,sp,8
  1842c4:	f800283a 	ret

001842c8 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p the thread parameter, unused in this scenario
 */
void _idle_thread(void *p) {
  1842c8:	defffe04 	addi	sp,sp,-8
  1842cc:	df000115 	stw	fp,4(sp)
  1842d0:	df000104 	addi	fp,sp,4
  1842d4:	e13fff15 	stw	r4,-4(fp)

  (void)p;
  chRegSetThreadName("idle");
  1842d8:	00800674 	movhi	r2,25
  1842dc:	10b18704 	addi	r2,r2,-14820
  1842e0:	10800717 	ldw	r2,28(r2)
  1842e4:	00c00674 	movhi	r3,25
  1842e8:	18e3bf04 	addi	r3,r3,-28932
  1842ec:	10c00615 	stw	r3,24(r2)
  while (TRUE) {
    port_wait_for_interrupt();
  1842f0:	0001883a 	nop
    IDLE_LOOP_HOOK();
  }
  1842f4:	003ffe06 	br	1842f0 <_idle_thread+0x28>

001842f8 <chSysInit>:
 * @note    This function has special, architecture-dependent, requirements,
 *          see the notes into the various port reference manuals.
 *
 * @special
 */
void chSysInit(void) {
  1842f8:	defffc04 	addi	sp,sp,-16
  1842fc:	dfc00315 	stw	ra,12(sp)
  184300:	df000215 	stw	fp,8(sp)
  184304:	df000204 	addi	fp,sp,8
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
  _scheduler_init();
  184308:	0183dc80 	call	183dc8 <_scheduler_init>
  _vt_init();
  18430c:	0180e080 	call	180e08 <_vt_init>
#if CH_USE_MEMCORE
  _core_init();
  184310:	01832840 	call	183284 <_core_init>
#endif
#if CH_USE_HEAP
  _heap_init();
  184314:	0182dbc0 	call	182dbc <_heap_init>
#if CH_DBG_ENABLE_TRACE
  _trace_init();
#endif

  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&mainthread, NORMALPRIO));
  184318:	01000674 	movhi	r4,25
  18431c:	21316504 	addi	r4,r4,-14956
  184320:	01401004 	movi	r5,64
  184324:	01806980 	call	180698 <_thread_init>
  184328:	00c00674 	movhi	r3,25
  18432c:	18f18704 	addi	r3,r3,-14820
  184330:	18800715 	stw	r2,28(r3)
  currp->p_state = THD_STATE_CURRENT;
  184334:	00800674 	movhi	r2,25
  184338:	10b18704 	addi	r2,r2,-14820
  18433c:	10800717 	ldw	r2,28(r2)
  184340:	00c00044 	movi	r3,1
  184344:	10c00705 	stb	r3,28(r2)
  184348:	00800044 	movi	r2,1
  18434c:	e0bfff15 	stw	r2,-4(fp)
  184350:	e0bfff17 	ldw	r2,-4(fp)
  184354:	1001703a 	wrctl	status,r2
#endif
  chSysEnable();

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
  184358:	00800674 	movhi	r2,25
  18435c:	10b18704 	addi	r2,r2,-14820
  184360:	10800717 	ldw	r2,28(r2)
  184364:	00c00674 	movhi	r3,25
  184368:	18e3c404 	addi	r3,r3,-28912
  18436c:	10c00615 	stw	r3,24(r2)

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
  184370:	d8000015 	stw	zero,0(sp)
  184374:	01000674 	movhi	r4,25
  184378:	21318f04 	addi	r4,r4,-14788
  18437c:	01407204 	movi	r5,456
  184380:	01800044 	movi	r6,1
  184384:	01c00634 	movhi	r7,24
  184388:	39d0b204 	addi	r7,r7,17096
  18438c:	01808fc0 	call	1808fc <chThdCreateStatic>
                    (tfunc_t)_idle_thread, NULL);
#endif
}
  184390:	e037883a 	mov	sp,fp
  184394:	dfc00117 	ldw	ra,4(sp)
  184398:	df000017 	ldw	fp,0(sp)
  18439c:	dec00204 	addi	sp,sp,8
  1843a0:	f800283a 	ret

001843a4 <chSysTimerHandlerI>:
 *          and, together with the @p CH_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
  1843a4:	defffc04 	addi	sp,sp,-16
  1843a8:	dfc00315 	stw	ra,12(sp)
  1843ac:	df000215 	stw	fp,8(sp)
  1843b0:	df000204 	addi	fp,sp,8

  chDbgCheckClassI();

#if CH_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (rlist.r_preempt > 0)
  1843b4:	00800674 	movhi	r2,25
  1843b8:	10b18704 	addi	r2,r2,-14820
  1843bc:	10800617 	ldw	r2,24(r2)
  1843c0:	0080070e 	bge	zero,r2,1843e0 <chSysTimerHandlerI+0x3c>
    /* Decrement remaining quantum.*/
    rlist.r_preempt--;
  1843c4:	00800674 	movhi	r2,25
  1843c8:	10b18704 	addi	r2,r2,-14820
  1843cc:	10800617 	ldw	r2,24(r2)
  1843d0:	10ffffc4 	addi	r3,r2,-1
  1843d4:	00800674 	movhi	r2,25
  1843d8:	10b18704 	addi	r2,r2,-14820
  1843dc:	10c00615 	stw	r3,24(r2)
#endif
#if CH_DBG_THREADS_PROFILING
  currp->p_time++;
  1843e0:	00800674 	movhi	r2,25
  1843e4:	10b18704 	addi	r2,r2,-14820
  1843e8:	10800717 	ldw	r2,28(r2)
  1843ec:	10c00817 	ldw	r3,32(r2)
  1843f0:	18c00044 	addi	r3,r3,1
  1843f4:	10c00815 	stw	r3,32(r2)
#endif
  chVTDoTickI();
  1843f8:	00800674 	movhi	r2,25
  1843fc:	10b18304 	addi	r2,r2,-14836
  184400:	10800317 	ldw	r2,12(r2)
  184404:	10c00044 	addi	r3,r2,1
  184408:	00800674 	movhi	r2,25
  18440c:	10b18304 	addi	r2,r2,-14836
  184410:	10c00315 	stw	r3,12(r2)
  184414:	00800674 	movhi	r2,25
  184418:	10b18304 	addi	r2,r2,-14836
  18441c:	10c00017 	ldw	r3,0(r2)
  184420:	00800674 	movhi	r2,25
  184424:	10b18304 	addi	r2,r2,-14836
  184428:	18802226 	beq	r3,r2,1844b4 <chSysTimerHandlerI+0x110>
  18442c:	00800674 	movhi	r2,25
  184430:	10b18304 	addi	r2,r2,-14836
  184434:	10800017 	ldw	r2,0(r2)
  184438:	10c00217 	ldw	r3,8(r2)
  18443c:	18ffffc4 	addi	r3,r3,-1
  184440:	10c00215 	stw	r3,8(r2)
  184444:	00001406 	br	184498 <chSysTimerHandlerI+0xf4>
  184448:	e0bffe17 	ldw	r2,-8(fp)
  18444c:	10800317 	ldw	r2,12(r2)
  184450:	e0bfff15 	stw	r2,-4(fp)
  184454:	e0bffe17 	ldw	r2,-8(fp)
  184458:	10000315 	stw	zero,12(r2)
  18445c:	e0bffe17 	ldw	r2,-8(fp)
  184460:	10800017 	ldw	r2,0(r2)
  184464:	00c00674 	movhi	r3,25
  184468:	18f18304 	addi	r3,r3,-14836
  18446c:	10c00115 	stw	r3,4(r2)
  184470:	e0bffe17 	ldw	r2,-8(fp)
  184474:	10c00017 	ldw	r3,0(r2)
  184478:	00800674 	movhi	r2,25
  18447c:	10b18304 	addi	r2,r2,-14836
  184480:	10c00015 	stw	r3,0(r2)
  184484:	e0bffe17 	ldw	r2,-8(fp)
  184488:	10800417 	ldw	r2,16(r2)
  18448c:	e0ffff17 	ldw	r3,-4(fp)
  184490:	1009883a 	mov	r4,r2
  184494:	183ee83a 	callr	r3
  184498:	00800674 	movhi	r2,25
  18449c:	10b18304 	addi	r2,r2,-14836
  1844a0:	10800017 	ldw	r2,0(r2)
  1844a4:	e0bffe15 	stw	r2,-8(fp)
  1844a8:	e0bffe17 	ldw	r2,-8(fp)
  1844ac:	10800217 	ldw	r2,8(r2)
  1844b0:	103fe526 	beq	r2,zero,184448 <chSysTimerHandlerI+0xa4>
#if defined(SYSTEM_TICK_EVENT_HOOK)
  SYSTEM_TICK_EVENT_HOOK();
#endif
}
  1844b4:	e037883a 	mov	sp,fp
  1844b8:	dfc00117 	ldw	ra,4(sp)
  1844bc:	df000017 	ldw	fp,0(sp)
  1844c0:	dec00204 	addi	sp,sp,8
  1844c4:	f800283a 	ret

001844c8 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
  1844c8:	defff504 	addi	sp,sp,-44
  1844cc:	df000a15 	stw	fp,40(sp)
  1844d0:	df000a04 	addi	fp,sp,40
  1844d4:	e13ffc15 	stw	r4,-16(fp)
  1844d8:	e17ffd15 	stw	r5,-12(fp)
  1844dc:	e1bffe15 	stw	r6,-8(fp)
  1844e0:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
  1844e4:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  1844e8:	00800674 	movhi	r2,25
  1844ec:	10b15804 	addi	r2,r2,-15008
  1844f0:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
  1844f4:	10003f26 	beq	r2,zero,1845f4 <alt_alarm_start+0x12c>
  {
    if (alarm)
  1844f8:	e0bffc17 	ldw	r2,-16(fp)
  1844fc:	10003b26 	beq	r2,zero,1845ec <alt_alarm_start+0x124>
    {
      alarm->callback = callback;
  184500:	e0bffc17 	ldw	r2,-16(fp)
  184504:	e0fffe17 	ldw	r3,-8(fp)
  184508:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
  18450c:	e0bffc17 	ldw	r2,-16(fp)
  184510:	e0ffff17 	ldw	r3,-4(fp)
  184514:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  184518:	0005303a 	rdctl	r2,status
  18451c:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  184520:	e0fff817 	ldw	r3,-32(fp)
  184524:	00bfff84 	movi	r2,-2
  184528:	1884703a 	and	r2,r3,r2
  18452c:	1001703a 	wrctl	status,r2
  
  return context;
  184530:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
  184534:	e0bff715 	stw	r2,-36(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
  184538:	00800674 	movhi	r2,25
  18453c:	10b15904 	addi	r2,r2,-15004
  184540:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
  184544:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
  184548:	e0fffd17 	ldw	r3,-12(fp)
  18454c:	e0bff617 	ldw	r2,-40(fp)
  184550:	1885883a 	add	r2,r3,r2
  184554:	10c00044 	addi	r3,r2,1
  184558:	e0bffc17 	ldw	r2,-16(fp)
  18455c:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
  184560:	e0bffc17 	ldw	r2,-16(fp)
  184564:	10c00217 	ldw	r3,8(r2)
  184568:	e0bff617 	ldw	r2,-40(fp)
  18456c:	1880042e 	bgeu	r3,r2,184580 <alt_alarm_start+0xb8>
      {
        alarm->rollover = 1;
  184570:	e0bffc17 	ldw	r2,-16(fp)
  184574:	00c00044 	movi	r3,1
  184578:	10c00405 	stb	r3,16(r2)
  18457c:	00000206 	br	184588 <alt_alarm_start+0xc0>
      }
      else
      {
        alarm->rollover = 0;
  184580:	e0bffc17 	ldw	r2,-16(fp)
  184584:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
  184588:	e0bffc17 	ldw	r2,-16(fp)
  18458c:	00c00674 	movhi	r3,25
  184590:	18ea8704 	addi	r3,r3,-21988
  184594:	e0fff915 	stw	r3,-28(fp)
  184598:	e0bffa15 	stw	r2,-24(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  18459c:	e0bffa17 	ldw	r2,-24(fp)
  1845a0:	e0fff917 	ldw	r3,-28(fp)
  1845a4:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  1845a8:	e0bff917 	ldw	r2,-28(fp)
  1845ac:	10c00017 	ldw	r3,0(r2)
  1845b0:	e0bffa17 	ldw	r2,-24(fp)
  1845b4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  1845b8:	e0bff917 	ldw	r2,-28(fp)
  1845bc:	10800017 	ldw	r2,0(r2)
  1845c0:	e0fffa17 	ldw	r3,-24(fp)
  1845c4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  1845c8:	e0bff917 	ldw	r2,-28(fp)
  1845cc:	e0fffa17 	ldw	r3,-24(fp)
  1845d0:	10c00015 	stw	r3,0(r2)
  1845d4:	e0bff717 	ldw	r2,-36(fp)
  1845d8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  1845dc:	e0bffb17 	ldw	r2,-20(fp)
  1845e0:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
  1845e4:	0005883a 	mov	r2,zero
  1845e8:	00000306 	br	1845f8 <alt_alarm_start+0x130>
    }
    else
    {
      return -EINVAL;
  1845ec:	00bffa84 	movi	r2,-22
  1845f0:	00000106 	br	1845f8 <alt_alarm_start+0x130>
    }
  }
  else
  {
    return -ENOTSUP;
  1845f4:	00bfde84 	movi	r2,-134
  }
}
  1845f8:	e037883a 	mov	sp,fp
  1845fc:	df000017 	ldw	fp,0(sp)
  184600:	dec00104 	addi	sp,sp,4
  184604:	f800283a 	ret

00184608 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  184608:	defffe04 	addi	sp,sp,-8
  18460c:	dfc00115 	stw	ra,4(sp)
  184610:	df000015 	stw	fp,0(sp)
  184614:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  184618:	00800674 	movhi	r2,25
  18461c:	10aa8504 	addi	r2,r2,-21996
  184620:	10800017 	ldw	r2,0(r2)
  184624:	10000526 	beq	r2,zero,18463c <alt_get_errno+0x34>
  184628:	00800674 	movhi	r2,25
  18462c:	10aa8504 	addi	r2,r2,-21996
  184630:	10800017 	ldw	r2,0(r2)
  184634:	103ee83a 	callr	r2
  184638:	00000206 	br	184644 <alt_get_errno+0x3c>
  18463c:	00800674 	movhi	r2,25
  184640:	10b15a04 	addi	r2,r2,-15000
}
  184644:	e037883a 	mov	sp,fp
  184648:	dfc00117 	ldw	ra,4(sp)
  18464c:	df000017 	ldw	fp,0(sp)
  184650:	dec00204 	addi	sp,sp,8
  184654:	f800283a 	ret

00184658 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
  184658:	defffb04 	addi	sp,sp,-20
  18465c:	dfc00415 	stw	ra,16(sp)
  184660:	df000315 	stw	fp,12(sp)
  184664:	df000304 	addi	fp,sp,12
  184668:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
  18466c:	e0bfff17 	ldw	r2,-4(fp)
  184670:	10000716 	blt	r2,zero,184690 <close+0x38>
  184674:	e13fff17 	ldw	r4,-4(fp)
  184678:	01400304 	movi	r5,12
  18467c:	01805f00 	call	1805f0 <__mulsi3>
  184680:	00c00674 	movhi	r3,25
  184684:	18e81e04 	addi	r3,r3,-24456
  184688:	10c5883a 	add	r2,r2,r3
  18468c:	00000106 	br	184694 <close+0x3c>
  184690:	0005883a 	mov	r2,zero
  184694:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
  184698:	e0bffd17 	ldw	r2,-12(fp)
  18469c:	10001826 	beq	r2,zero,184700 <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
  1846a0:	e0bffd17 	ldw	r2,-12(fp)
  1846a4:	10800017 	ldw	r2,0(r2)
  1846a8:	10800417 	ldw	r2,16(r2)
  1846ac:	10000626 	beq	r2,zero,1846c8 <close+0x70>
  1846b0:	e0bffd17 	ldw	r2,-12(fp)
  1846b4:	10800017 	ldw	r2,0(r2)
  1846b8:	10800417 	ldw	r2,16(r2)
  1846bc:	e13ffd17 	ldw	r4,-12(fp)
  1846c0:	103ee83a 	callr	r2
  1846c4:	00000106 	br	1846cc <close+0x74>
  1846c8:	0005883a 	mov	r2,zero
  1846cc:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
  1846d0:	e13fff17 	ldw	r4,-4(fp)
  1846d4:	0184fe80 	call	184fe8 <alt_release_fd>
    if (rval < 0)
  1846d8:	e0bffe17 	ldw	r2,-8(fp)
  1846dc:	1000060e 	bge	r2,zero,1846f8 <close+0xa0>
    {
      ALT_ERRNO = -rval;
  1846e0:	01846080 	call	184608 <alt_get_errno>
  1846e4:	e0fffe17 	ldw	r3,-8(fp)
  1846e8:	00c7c83a 	sub	r3,zero,r3
  1846ec:	10c00015 	stw	r3,0(r2)
      return -1;
  1846f0:	00bfffc4 	movi	r2,-1
  1846f4:	00000606 	br	184710 <close+0xb8>
    }
    return 0;
  1846f8:	0005883a 	mov	r2,zero
  1846fc:	00000406 	br	184710 <close+0xb8>
  }
  else
  {
    ALT_ERRNO = EBADFD;
  184700:	01846080 	call	184608 <alt_get_errno>
  184704:	00c01444 	movi	r3,81
  184708:	10c00015 	stw	r3,0(r2)
    return -1;
  18470c:	00bfffc4 	movi	r2,-1
  }
}
  184710:	e037883a 	mov	sp,fp
  184714:	dfc00117 	ldw	ra,4(sp)
  184718:	df000017 	ldw	fp,0(sp)
  18471c:	dec00204 	addi	sp,sp,8
  184720:	f800283a 	ret

00184724 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  184724:	deffff04 	addi	sp,sp,-4
  184728:	df000015 	stw	fp,0(sp)
  18472c:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
  184730:	e037883a 	mov	sp,fp
  184734:	df000017 	ldw	fp,0(sp)
  184738:	dec00104 	addi	sp,sp,4
  18473c:	f800283a 	ret

00184740 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  184740:	defffc04 	addi	sp,sp,-16
  184744:	df000315 	stw	fp,12(sp)
  184748:	df000304 	addi	fp,sp,12
  18474c:	e13ffd15 	stw	r4,-12(fp)
  184750:	e17ffe15 	stw	r5,-8(fp)
  184754:	e1bfff15 	stw	r6,-4(fp)
  return len;
  184758:	e0bfff17 	ldw	r2,-4(fp)
}
  18475c:	e037883a 	mov	sp,fp
  184760:	df000017 	ldw	fp,0(sp)
  184764:	dec00104 	addi	sp,sp,4
  184768:	f800283a 	ret

0018476c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  18476c:	defffe04 	addi	sp,sp,-8
  184770:	dfc00115 	stw	ra,4(sp)
  184774:	df000015 	stw	fp,0(sp)
  184778:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  18477c:	00800674 	movhi	r2,25
  184780:	10aa8504 	addi	r2,r2,-21996
  184784:	10800017 	ldw	r2,0(r2)
  184788:	10000526 	beq	r2,zero,1847a0 <alt_get_errno+0x34>
  18478c:	00800674 	movhi	r2,25
  184790:	10aa8504 	addi	r2,r2,-21996
  184794:	10800017 	ldw	r2,0(r2)
  184798:	103ee83a 	callr	r2
  18479c:	00000206 	br	1847a8 <alt_get_errno+0x3c>
  1847a0:	00800674 	movhi	r2,25
  1847a4:	10b15a04 	addi	r2,r2,-15000
}
  1847a8:	e037883a 	mov	sp,fp
  1847ac:	dfc00117 	ldw	ra,4(sp)
  1847b0:	df000017 	ldw	fp,0(sp)
  1847b4:	dec00204 	addi	sp,sp,8
  1847b8:	f800283a 	ret

001847bc <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  1847bc:	defffa04 	addi	sp,sp,-24
  1847c0:	dfc00515 	stw	ra,20(sp)
  1847c4:	df000415 	stw	fp,16(sp)
  1847c8:	df000404 	addi	fp,sp,16
  1847cc:	e13ffe15 	stw	r4,-8(fp)
  1847d0:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  1847d4:	e0bffe17 	ldw	r2,-8(fp)
  1847d8:	10000326 	beq	r2,zero,1847e8 <alt_dev_llist_insert+0x2c>
  1847dc:	e0bffe17 	ldw	r2,-8(fp)
  1847e0:	10800217 	ldw	r2,8(r2)
  1847e4:	1000051e 	bne	r2,zero,1847fc <alt_dev_llist_insert+0x40>
  {
    ALT_ERRNO = EINVAL;
  1847e8:	018476c0 	call	18476c <alt_get_errno>
  1847ec:	00c00584 	movi	r3,22
  1847f0:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
  1847f4:	00bffa84 	movi	r2,-22
  1847f8:	00001306 	br	184848 <alt_dev_llist_insert+0x8c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
  1847fc:	e0bffe17 	ldw	r2,-8(fp)
  184800:	e0ffff17 	ldw	r3,-4(fp)
  184804:	e0fffc15 	stw	r3,-16(fp)
  184808:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  18480c:	e0bffd17 	ldw	r2,-12(fp)
  184810:	e0fffc17 	ldw	r3,-16(fp)
  184814:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  184818:	e0bffc17 	ldw	r2,-16(fp)
  18481c:	10c00017 	ldw	r3,0(r2)
  184820:	e0bffd17 	ldw	r2,-12(fp)
  184824:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  184828:	e0bffc17 	ldw	r2,-16(fp)
  18482c:	10800017 	ldw	r2,0(r2)
  184830:	e0fffd17 	ldw	r3,-12(fp)
  184834:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  184838:	e0bffc17 	ldw	r2,-16(fp)
  18483c:	e0fffd17 	ldw	r3,-12(fp)
  184840:	10c00015 	stw	r3,0(r2)

  return 0;  
  184844:	0005883a 	mov	r2,zero
}
  184848:	e037883a 	mov	sp,fp
  18484c:	dfc00117 	ldw	ra,4(sp)
  184850:	df000017 	ldw	fp,0(sp)
  184854:	dec00204 	addi	sp,sp,8
  184858:	f800283a 	ret

0018485c <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
  18485c:	defffd04 	addi	sp,sp,-12
  184860:	dfc00215 	stw	ra,8(sp)
  184864:	df000115 	stw	fp,4(sp)
  184868:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  18486c:	00800674 	movhi	r2,25
  184870:	10a39b04 	addi	r2,r2,-29076
  184874:	e0bfff15 	stw	r2,-4(fp)
  184878:	00000606 	br	184894 <_do_ctors+0x38>
        (*ctor) (); 
  18487c:	e0bfff17 	ldw	r2,-4(fp)
  184880:	10800017 	ldw	r2,0(r2)
  184884:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  184888:	e0bfff17 	ldw	r2,-4(fp)
  18488c:	10bfff04 	addi	r2,r2,-4
  184890:	e0bfff15 	stw	r2,-4(fp)
  184894:	e0ffff17 	ldw	r3,-4(fp)
  184898:	00800674 	movhi	r2,25
  18489c:	10a39c04 	addi	r2,r2,-29072
  1848a0:	18bff62e 	bgeu	r3,r2,18487c <_do_ctors+0x20>
        (*ctor) (); 
}
  1848a4:	e037883a 	mov	sp,fp
  1848a8:	dfc00117 	ldw	ra,4(sp)
  1848ac:	df000017 	ldw	fp,0(sp)
  1848b0:	dec00204 	addi	sp,sp,8
  1848b4:	f800283a 	ret

001848b8 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
  1848b8:	defffd04 	addi	sp,sp,-12
  1848bc:	dfc00215 	stw	ra,8(sp)
  1848c0:	df000115 	stw	fp,4(sp)
  1848c4:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  1848c8:	00800674 	movhi	r2,25
  1848cc:	10a39b04 	addi	r2,r2,-29076
  1848d0:	e0bfff15 	stw	r2,-4(fp)
  1848d4:	00000606 	br	1848f0 <_do_dtors+0x38>
        (*dtor) (); 
  1848d8:	e0bfff17 	ldw	r2,-4(fp)
  1848dc:	10800017 	ldw	r2,0(r2)
  1848e0:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  1848e4:	e0bfff17 	ldw	r2,-4(fp)
  1848e8:	10bfff04 	addi	r2,r2,-4
  1848ec:	e0bfff15 	stw	r2,-4(fp)
  1848f0:	e0ffff17 	ldw	r3,-4(fp)
  1848f4:	00800674 	movhi	r2,25
  1848f8:	10a39c04 	addi	r2,r2,-29072
  1848fc:	18bff62e 	bgeu	r3,r2,1848d8 <_do_dtors+0x20>
        (*dtor) (); 
}
  184900:	e037883a 	mov	sp,fp
  184904:	dfc00117 	ldw	ra,4(sp)
  184908:	df000017 	ldw	fp,0(sp)
  18490c:	dec00204 	addi	sp,sp,8
  184910:	f800283a 	ret

00184914 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  184914:	deffff04 	addi	sp,sp,-4
  184918:	df000015 	stw	fp,0(sp)
  18491c:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
  184920:	e037883a 	mov	sp,fp
  184924:	df000017 	ldw	fp,0(sp)
  184928:	dec00104 	addi	sp,sp,4
  18492c:	f800283a 	ret

00184930 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  184930:	defff904 	addi	sp,sp,-28
  184934:	dfc00615 	stw	ra,24(sp)
  184938:	df000515 	stw	fp,20(sp)
  18493c:	df000504 	addi	fp,sp,20
  184940:	e13ffc15 	stw	r4,-16(fp)
  184944:	e17ffd15 	stw	r5,-12(fp)
  184948:	e1bffe15 	stw	r6,-8(fp)
  18494c:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  184950:	e0800217 	ldw	r2,8(fp)
  184954:	d8800015 	stw	r2,0(sp)
  184958:	e13ffc17 	ldw	r4,-16(fp)
  18495c:	e17ffd17 	ldw	r5,-12(fp)
  184960:	e1bffe17 	ldw	r6,-8(fp)
  184964:	e1ffff17 	ldw	r7,-4(fp)
  184968:	0184b080 	call	184b08 <alt_iic_isr_register>
}  
  18496c:	e037883a 	mov	sp,fp
  184970:	dfc00117 	ldw	ra,4(sp)
  184974:	df000017 	ldw	fp,0(sp)
  184978:	dec00204 	addi	sp,sp,8
  18497c:	f800283a 	ret

00184980 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
  184980:	defff904 	addi	sp,sp,-28
  184984:	df000615 	stw	fp,24(sp)
  184988:	df000604 	addi	fp,sp,24
  18498c:	e13ffe15 	stw	r4,-8(fp)
  184990:	e17fff15 	stw	r5,-4(fp)
  184994:	e0bfff17 	ldw	r2,-4(fp)
  184998:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  18499c:	0005303a 	rdctl	r2,status
  1849a0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  1849a4:	e0fffb17 	ldw	r3,-20(fp)
  1849a8:	00bfff84 	movi	r2,-2
  1849ac:	1884703a 	and	r2,r3,r2
  1849b0:	1001703a 	wrctl	status,r2
  
  return context;
  1849b4:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  1849b8:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
  1849bc:	e0bffa17 	ldw	r2,-24(fp)
  1849c0:	00c00044 	movi	r3,1
  1849c4:	1884983a 	sll	r2,r3,r2
  1849c8:	1007883a 	mov	r3,r2
  1849cc:	00800674 	movhi	r2,25
  1849d0:	10b15704 	addi	r2,r2,-15012
  1849d4:	10800017 	ldw	r2,0(r2)
  1849d8:	1886b03a 	or	r3,r3,r2
  1849dc:	00800674 	movhi	r2,25
  1849e0:	10b15704 	addi	r2,r2,-15012
  1849e4:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  1849e8:	00800674 	movhi	r2,25
  1849ec:	10b15704 	addi	r2,r2,-15012
  1849f0:	10800017 	ldw	r2,0(r2)
  1849f4:	100170fa 	wrctl	ienable,r2
  1849f8:	e0bffc17 	ldw	r2,-16(fp)
  1849fc:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  184a00:	e0bffd17 	ldw	r2,-12(fp)
  184a04:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  184a08:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
  184a0c:	e037883a 	mov	sp,fp
  184a10:	df000017 	ldw	fp,0(sp)
  184a14:	dec00104 	addi	sp,sp,4
  184a18:	f800283a 	ret

00184a1c <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
  184a1c:	defff904 	addi	sp,sp,-28
  184a20:	df000615 	stw	fp,24(sp)
  184a24:	df000604 	addi	fp,sp,24
  184a28:	e13ffe15 	stw	r4,-8(fp)
  184a2c:	e17fff15 	stw	r5,-4(fp)
  184a30:	e0bfff17 	ldw	r2,-4(fp)
  184a34:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  184a38:	0005303a 	rdctl	r2,status
  184a3c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  184a40:	e0fffb17 	ldw	r3,-20(fp)
  184a44:	00bfff84 	movi	r2,-2
  184a48:	1884703a 	and	r2,r3,r2
  184a4c:	1001703a 	wrctl	status,r2
  
  return context;
  184a50:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  184a54:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
  184a58:	e0bffa17 	ldw	r2,-24(fp)
  184a5c:	00c00044 	movi	r3,1
  184a60:	1884983a 	sll	r2,r3,r2
  184a64:	0084303a 	nor	r2,zero,r2
  184a68:	1007883a 	mov	r3,r2
  184a6c:	00800674 	movhi	r2,25
  184a70:	10b15704 	addi	r2,r2,-15012
  184a74:	10800017 	ldw	r2,0(r2)
  184a78:	1886703a 	and	r3,r3,r2
  184a7c:	00800674 	movhi	r2,25
  184a80:	10b15704 	addi	r2,r2,-15012
  184a84:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  184a88:	00800674 	movhi	r2,25
  184a8c:	10b15704 	addi	r2,r2,-15012
  184a90:	10800017 	ldw	r2,0(r2)
  184a94:	100170fa 	wrctl	ienable,r2
  184a98:	e0bffc17 	ldw	r2,-16(fp)
  184a9c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  184aa0:	e0bffd17 	ldw	r2,-12(fp)
  184aa4:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  184aa8:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
  184aac:	e037883a 	mov	sp,fp
  184ab0:	df000017 	ldw	fp,0(sp)
  184ab4:	dec00104 	addi	sp,sp,4
  184ab8:	f800283a 	ret

00184abc <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
  184abc:	defffc04 	addi	sp,sp,-16
  184ac0:	df000315 	stw	fp,12(sp)
  184ac4:	df000304 	addi	fp,sp,12
  184ac8:	e13ffe15 	stw	r4,-8(fp)
  184acc:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  184ad0:	000530fa 	rdctl	r2,ienable
  184ad4:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
  184ad8:	e0bfff17 	ldw	r2,-4(fp)
  184adc:	00c00044 	movi	r3,1
  184ae0:	1884983a 	sll	r2,r3,r2
  184ae4:	1007883a 	mov	r3,r2
  184ae8:	e0bffd17 	ldw	r2,-12(fp)
  184aec:	1884703a 	and	r2,r3,r2
  184af0:	1004c03a 	cmpne	r2,r2,zero
  184af4:	10803fcc 	andi	r2,r2,255
}
  184af8:	e037883a 	mov	sp,fp
  184afc:	df000017 	ldw	fp,0(sp)
  184b00:	dec00104 	addi	sp,sp,4
  184b04:	f800283a 	ret

00184b08 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  184b08:	defff504 	addi	sp,sp,-44
  184b0c:	dfc00a15 	stw	ra,40(sp)
  184b10:	df000915 	stw	fp,36(sp)
  184b14:	df000904 	addi	fp,sp,36
  184b18:	e13ffc15 	stw	r4,-16(fp)
  184b1c:	e17ffd15 	stw	r5,-12(fp)
  184b20:	e1bffe15 	stw	r6,-8(fp)
  184b24:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
  184b28:	00bffa84 	movi	r2,-22
  184b2c:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  184b30:	e0bffd17 	ldw	r2,-12(fp)
  184b34:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
  184b38:	e0bff817 	ldw	r2,-32(fp)
  184b3c:	10800808 	cmpgei	r2,r2,32
  184b40:	1000271e 	bne	r2,zero,184be0 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  184b44:	0005303a 	rdctl	r2,status
  184b48:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  184b4c:	e0fffa17 	ldw	r3,-24(fp)
  184b50:	00bfff84 	movi	r2,-2
  184b54:	1884703a 	and	r2,r3,r2
  184b58:	1001703a 	wrctl	status,r2
  
  return context;
  184b5c:	e0bffa17 	ldw	r2,-24(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
  184b60:	e0bff915 	stw	r2,-28(fp)

    alt_irq[id].handler = isr;
  184b64:	00c00674 	movhi	r3,25
  184b68:	18f20104 	addi	r3,r3,-14332
  184b6c:	e0bff817 	ldw	r2,-32(fp)
  184b70:	100490fa 	slli	r2,r2,3
  184b74:	1885883a 	add	r2,r3,r2
  184b78:	e0fffe17 	ldw	r3,-8(fp)
  184b7c:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
  184b80:	00c00674 	movhi	r3,25
  184b84:	18f20104 	addi	r3,r3,-14332
  184b88:	e0bff817 	ldw	r2,-32(fp)
  184b8c:	100490fa 	slli	r2,r2,3
  184b90:	1885883a 	add	r2,r3,r2
  184b94:	10800104 	addi	r2,r2,4
  184b98:	e0ffff17 	ldw	r3,-4(fp)
  184b9c:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  184ba0:	e0bffe17 	ldw	r2,-8(fp)
  184ba4:	10000526 	beq	r2,zero,184bbc <alt_iic_isr_register+0xb4>
  184ba8:	e0bff817 	ldw	r2,-32(fp)
  184bac:	e13ffc17 	ldw	r4,-16(fp)
  184bb0:	100b883a 	mov	r5,r2
  184bb4:	01849800 	call	184980 <alt_ic_irq_enable>
  184bb8:	00000406 	br	184bcc <alt_iic_isr_register+0xc4>
  184bbc:	e0bff817 	ldw	r2,-32(fp)
  184bc0:	e13ffc17 	ldw	r4,-16(fp)
  184bc4:	100b883a 	mov	r5,r2
  184bc8:	0184a1c0 	call	184a1c <alt_ic_irq_disable>
  184bcc:	e0bff715 	stw	r2,-36(fp)
  184bd0:	e0bff917 	ldw	r2,-28(fp)
  184bd4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  184bd8:	e0bffb17 	ldw	r2,-20(fp)
  184bdc:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
  184be0:	e0bff717 	ldw	r2,-36(fp)
}
  184be4:	e037883a 	mov	sp,fp
  184be8:	dfc00117 	ldw	ra,4(sp)
  184bec:	df000017 	ldw	fp,0(sp)
  184bf0:	dec00204 	addi	sp,sp,8
  184bf4:	f800283a 	ret

00184bf8 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
  184bf8:	defff804 	addi	sp,sp,-32
  184bfc:	dfc00715 	stw	ra,28(sp)
  184c00:	df000615 	stw	fp,24(sp)
  184c04:	dc000515 	stw	r16,20(sp)
  184c08:	df000504 	addi	fp,sp,20
  184c0c:	e13ffc15 	stw	r4,-16(fp)
  184c10:	e17ffd15 	stw	r5,-12(fp)
  184c14:	e1bffe15 	stw	r6,-8(fp)
  184c18:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
  184c1c:	e13ffd17 	ldw	r4,-12(fp)
  184c20:	e17ffe17 	ldw	r5,-8(fp)
  184c24:	e1bfff17 	ldw	r6,-4(fp)
  184c28:	0184e900 	call	184e90 <open>
  184c2c:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
  184c30:	e0bffb17 	ldw	r2,-20(fp)
  184c34:	10002216 	blt	r2,zero,184cc0 <alt_open_fd+0xc8>
  {
    fd->dev      = alt_fd_list[old].dev;
  184c38:	04000674 	movhi	r16,25
  184c3c:	84281e04 	addi	r16,r16,-24456
  184c40:	e0bffb17 	ldw	r2,-20(fp)
  184c44:	1009883a 	mov	r4,r2
  184c48:	01400304 	movi	r5,12
  184c4c:	01805f00 	call	1805f0 <__mulsi3>
  184c50:	8085883a 	add	r2,r16,r2
  184c54:	10c00017 	ldw	r3,0(r2)
  184c58:	e0bffc17 	ldw	r2,-16(fp)
  184c5c:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
  184c60:	04000674 	movhi	r16,25
  184c64:	84281e04 	addi	r16,r16,-24456
  184c68:	e0bffb17 	ldw	r2,-20(fp)
  184c6c:	1009883a 	mov	r4,r2
  184c70:	01400304 	movi	r5,12
  184c74:	01805f00 	call	1805f0 <__mulsi3>
  184c78:	8085883a 	add	r2,r16,r2
  184c7c:	10800104 	addi	r2,r2,4
  184c80:	10c00017 	ldw	r3,0(r2)
  184c84:	e0bffc17 	ldw	r2,-16(fp)
  184c88:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
  184c8c:	04000674 	movhi	r16,25
  184c90:	84281e04 	addi	r16,r16,-24456
  184c94:	e0bffb17 	ldw	r2,-20(fp)
  184c98:	1009883a 	mov	r4,r2
  184c9c:	01400304 	movi	r5,12
  184ca0:	01805f00 	call	1805f0 <__mulsi3>
  184ca4:	8085883a 	add	r2,r16,r2
  184ca8:	10800204 	addi	r2,r2,8
  184cac:	10c00017 	ldw	r3,0(r2)
  184cb0:	e0bffc17 	ldw	r2,-16(fp)
  184cb4:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
  184cb8:	e13ffb17 	ldw	r4,-20(fp)
  184cbc:	0184fe80 	call	184fe8 <alt_release_fd>
  }
} 
  184cc0:	e037883a 	mov	sp,fp
  184cc4:	dfc00217 	ldw	ra,8(sp)
  184cc8:	df000117 	ldw	fp,4(sp)
  184ccc:	dc000017 	ldw	r16,0(sp)
  184cd0:	dec00304 	addi	sp,sp,12
  184cd4:	f800283a 	ret

00184cd8 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
  184cd8:	defffb04 	addi	sp,sp,-20
  184cdc:	dfc00415 	stw	ra,16(sp)
  184ce0:	df000315 	stw	fp,12(sp)
  184ce4:	df000304 	addi	fp,sp,12
  184ce8:	e13ffd15 	stw	r4,-12(fp)
  184cec:	e17ffe15 	stw	r5,-8(fp)
  184cf0:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
  184cf4:	01000674 	movhi	r4,25
  184cf8:	21282104 	addi	r4,r4,-24444
  184cfc:	e17ffd17 	ldw	r5,-12(fp)
  184d00:	01800044 	movi	r6,1
  184d04:	01c07fc4 	movi	r7,511
  184d08:	0184bf80 	call	184bf8 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
  184d0c:	01000674 	movhi	r4,25
  184d10:	21281e04 	addi	r4,r4,-24456
  184d14:	e17ffe17 	ldw	r5,-8(fp)
  184d18:	000d883a 	mov	r6,zero
  184d1c:	01c07fc4 	movi	r7,511
  184d20:	0184bf80 	call	184bf8 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
  184d24:	01000674 	movhi	r4,25
  184d28:	21282404 	addi	r4,r4,-24432
  184d2c:	e17fff17 	ldw	r5,-4(fp)
  184d30:	01800044 	movi	r6,1
  184d34:	01c07fc4 	movi	r7,511
  184d38:	0184bf80 	call	184bf8 <alt_open_fd>
}  
  184d3c:	e037883a 	mov	sp,fp
  184d40:	dfc00117 	ldw	ra,4(sp)
  184d44:	df000017 	ldw	fp,0(sp)
  184d48:	dec00204 	addi	sp,sp,8
  184d4c:	f800283a 	ret

00184d50 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  184d50:	defffe04 	addi	sp,sp,-8
  184d54:	dfc00115 	stw	ra,4(sp)
  184d58:	df000015 	stw	fp,0(sp)
  184d5c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  184d60:	00800674 	movhi	r2,25
  184d64:	10aa8504 	addi	r2,r2,-21996
  184d68:	10800017 	ldw	r2,0(r2)
  184d6c:	10000526 	beq	r2,zero,184d84 <alt_get_errno+0x34>
  184d70:	00800674 	movhi	r2,25
  184d74:	10aa8504 	addi	r2,r2,-21996
  184d78:	10800017 	ldw	r2,0(r2)
  184d7c:	103ee83a 	callr	r2
  184d80:	00000206 	br	184d8c <alt_get_errno+0x3c>
  184d84:	00800674 	movhi	r2,25
  184d88:	10b15a04 	addi	r2,r2,-15000
}
  184d8c:	e037883a 	mov	sp,fp
  184d90:	dfc00117 	ldw	ra,4(sp)
  184d94:	df000017 	ldw	fp,0(sp)
  184d98:	dec00204 	addi	sp,sp,8
  184d9c:	f800283a 	ret

00184da0 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
  184da0:	defffb04 	addi	sp,sp,-20
  184da4:	dfc00415 	stw	ra,16(sp)
  184da8:	df000315 	stw	fp,12(sp)
  184dac:	dc000215 	stw	r16,8(sp)
  184db0:	df000204 	addi	fp,sp,8
  184db4:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
  184db8:	e0bfff17 	ldw	r2,-4(fp)
  184dbc:	10800217 	ldw	r2,8(r2)
  184dc0:	10d00034 	orhi	r3,r2,16384
  184dc4:	e0bfff17 	ldw	r2,-4(fp)
  184dc8:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  184dcc:	e03ffe15 	stw	zero,-8(fp)
  184dd0:	00002206 	br	184e5c <alt_file_locked+0xbc>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  184dd4:	04000674 	movhi	r16,25
  184dd8:	84281e04 	addi	r16,r16,-24456
  184ddc:	e0bffe17 	ldw	r2,-8(fp)
  184de0:	1009883a 	mov	r4,r2
  184de4:	01400304 	movi	r5,12
  184de8:	01805f00 	call	1805f0 <__mulsi3>
  184dec:	8085883a 	add	r2,r16,r2
  184df0:	10c00017 	ldw	r3,0(r2)
  184df4:	e0bfff17 	ldw	r2,-4(fp)
  184df8:	10800017 	ldw	r2,0(r2)
  184dfc:	1880141e 	bne	r3,r2,184e50 <alt_file_locked+0xb0>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  184e00:	04000674 	movhi	r16,25
  184e04:	84281e04 	addi	r16,r16,-24456
  184e08:	e0bffe17 	ldw	r2,-8(fp)
  184e0c:	1009883a 	mov	r4,r2
  184e10:	01400304 	movi	r5,12
  184e14:	01805f00 	call	1805f0 <__mulsi3>
  184e18:	8085883a 	add	r2,r16,r2
  184e1c:	10800204 	addi	r2,r2,8
  184e20:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  184e24:	10000a0e 	bge	r2,zero,184e50 <alt_file_locked+0xb0>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
  184e28:	e13ffe17 	ldw	r4,-8(fp)
  184e2c:	01400304 	movi	r5,12
  184e30:	01805f00 	call	1805f0 <__mulsi3>
  184e34:	00c00674 	movhi	r3,25
  184e38:	18e81e04 	addi	r3,r3,-24456
  184e3c:	10c7883a 	add	r3,r2,r3
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  184e40:	e0bfff17 	ldw	r2,-4(fp)
  184e44:	18800226 	beq	r3,r2,184e50 <alt_file_locked+0xb0>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
  184e48:	00bffcc4 	movi	r2,-13
  184e4c:	00000a06 	br	184e78 <alt_file_locked+0xd8>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  184e50:	e0bffe17 	ldw	r2,-8(fp)
  184e54:	10800044 	addi	r2,r2,1
  184e58:	e0bffe15 	stw	r2,-8(fp)
  184e5c:	00800674 	movhi	r2,25
  184e60:	10aa8404 	addi	r2,r2,-22000
  184e64:	10800017 	ldw	r2,0(r2)
  184e68:	1007883a 	mov	r3,r2
  184e6c:	e0bffe17 	ldw	r2,-8(fp)
  184e70:	18bfd82e 	bgeu	r3,r2,184dd4 <alt_file_locked+0x34>
    }
  }
  
  /* The device is not locked */
 
  return 0;
  184e74:	0005883a 	mov	r2,zero
}
  184e78:	e037883a 	mov	sp,fp
  184e7c:	dfc00217 	ldw	ra,8(sp)
  184e80:	df000117 	ldw	fp,4(sp)
  184e84:	dc000017 	ldw	r16,0(sp)
  184e88:	dec00304 	addi	sp,sp,12
  184e8c:	f800283a 	ret

00184e90 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
  184e90:	defff604 	addi	sp,sp,-40
  184e94:	dfc00915 	stw	ra,36(sp)
  184e98:	df000815 	stw	fp,32(sp)
  184e9c:	df000804 	addi	fp,sp,32
  184ea0:	e13ffd15 	stw	r4,-12(fp)
  184ea4:	e17ffe15 	stw	r5,-8(fp)
  184ea8:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
  184eac:	00bfffc4 	movi	r2,-1
  184eb0:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
  184eb4:	00bffb44 	movi	r2,-19
  184eb8:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
  184ebc:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
  184ec0:	e13ffd17 	ldw	r4,-12(fp)
  184ec4:	01400674 	movhi	r5,25
  184ec8:	296a8204 	addi	r5,r5,-22008
  184ecc:	018537c0 	call	18537c <alt_find_dev>
  184ed0:	e0bff815 	stw	r2,-32(fp)
  184ed4:	e0bff817 	ldw	r2,-32(fp)
  184ed8:	1000051e 	bne	r2,zero,184ef0 <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
  184edc:	e13ffd17 	ldw	r4,-12(fp)
  184ee0:	018540c0 	call	18540c <alt_find_file>
  184ee4:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
  184ee8:	00800044 	movi	r2,1
  184eec:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
  184ef0:	e0bff817 	ldw	r2,-32(fp)
  184ef4:	10002a26 	beq	r2,zero,184fa0 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
  184ef8:	e13ff817 	ldw	r4,-32(fp)
  184efc:	01855200 	call	185520 <alt_get_fd>
  184f00:	e0bff915 	stw	r2,-28(fp)
  184f04:	e0bff917 	ldw	r2,-28(fp)
  184f08:	1000030e 	bge	r2,zero,184f18 <open+0x88>
    {
      status = index;
  184f0c:	e0bff917 	ldw	r2,-28(fp)
  184f10:	e0bffa15 	stw	r2,-24(fp)
  184f14:	00002406 	br	184fa8 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
  184f18:	e13ff917 	ldw	r4,-28(fp)
  184f1c:	01400304 	movi	r5,12
  184f20:	01805f00 	call	1805f0 <__mulsi3>
  184f24:	00c00674 	movhi	r3,25
  184f28:	18e81e04 	addi	r3,r3,-24456
  184f2c:	10c5883a 	add	r2,r2,r3
  184f30:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
  184f34:	e0fffe17 	ldw	r3,-8(fp)
  184f38:	00900034 	movhi	r2,16384
  184f3c:	10bfffc4 	addi	r2,r2,-1
  184f40:	1886703a 	and	r3,r3,r2
  184f44:	e0bffc17 	ldw	r2,-16(fp)
  184f48:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
  184f4c:	e0bffb17 	ldw	r2,-20(fp)
  184f50:	1000051e 	bne	r2,zero,184f68 <open+0xd8>
  184f54:	e13ffc17 	ldw	r4,-16(fp)
  184f58:	0184da00 	call	184da0 <alt_file_locked>
  184f5c:	e0bffa15 	stw	r2,-24(fp)
  184f60:	e0bffa17 	ldw	r2,-24(fp)
  184f64:	10001016 	blt	r2,zero,184fa8 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
  184f68:	e0bff817 	ldw	r2,-32(fp)
  184f6c:	10800317 	ldw	r2,12(r2)
  184f70:	10000826 	beq	r2,zero,184f94 <open+0x104>
  184f74:	e0bff817 	ldw	r2,-32(fp)
  184f78:	10800317 	ldw	r2,12(r2)
  184f7c:	e13ffc17 	ldw	r4,-16(fp)
  184f80:	e17ffd17 	ldw	r5,-12(fp)
  184f84:	e1bffe17 	ldw	r6,-8(fp)
  184f88:	e1ffff17 	ldw	r7,-4(fp)
  184f8c:	103ee83a 	callr	r2
  184f90:	00000106 	br	184f98 <open+0x108>
  184f94:	0005883a 	mov	r2,zero
  184f98:	e0bffa15 	stw	r2,-24(fp)
  184f9c:	00000206 	br	184fa8 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
  184fa0:	00bffb44 	movi	r2,-19
  184fa4:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
  184fa8:	e0bffa17 	ldw	r2,-24(fp)
  184fac:	1000080e 	bge	r2,zero,184fd0 <open+0x140>
  {
    alt_release_fd (index);  
  184fb0:	e13ff917 	ldw	r4,-28(fp)
  184fb4:	0184fe80 	call	184fe8 <alt_release_fd>
    ALT_ERRNO = -status;
  184fb8:	0184d500 	call	184d50 <alt_get_errno>
  184fbc:	e0fffa17 	ldw	r3,-24(fp)
  184fc0:	00c7c83a 	sub	r3,zero,r3
  184fc4:	10c00015 	stw	r3,0(r2)
    return -1;
  184fc8:	00bfffc4 	movi	r2,-1
  184fcc:	00000106 	br	184fd4 <open+0x144>
  }
  
  /* return the reference upon success */

  return index;
  184fd0:	e0bff917 	ldw	r2,-28(fp)
}
  184fd4:	e037883a 	mov	sp,fp
  184fd8:	dfc00117 	ldw	ra,4(sp)
  184fdc:	df000017 	ldw	fp,0(sp)
  184fe0:	dec00204 	addi	sp,sp,8
  184fe4:	f800283a 	ret

00184fe8 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
  184fe8:	defffc04 	addi	sp,sp,-16
  184fec:	dfc00315 	stw	ra,12(sp)
  184ff0:	df000215 	stw	fp,8(sp)
  184ff4:	dc000115 	stw	r16,4(sp)
  184ff8:	df000104 	addi	fp,sp,4
  184ffc:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
  185000:	e0bfff17 	ldw	r2,-4(fp)
  185004:	108000d0 	cmplti	r2,r2,3
  185008:	1000111e 	bne	r2,zero,185050 <alt_release_fd+0x68>
  {
    alt_fd_list[fd].fd_flags = 0;
  18500c:	04000674 	movhi	r16,25
  185010:	84281e04 	addi	r16,r16,-24456
  185014:	e0bfff17 	ldw	r2,-4(fp)
  185018:	1009883a 	mov	r4,r2
  18501c:	01400304 	movi	r5,12
  185020:	01805f00 	call	1805f0 <__mulsi3>
  185024:	8085883a 	add	r2,r16,r2
  185028:	10800204 	addi	r2,r2,8
  18502c:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
  185030:	04000674 	movhi	r16,25
  185034:	84281e04 	addi	r16,r16,-24456
  185038:	e0bfff17 	ldw	r2,-4(fp)
  18503c:	1009883a 	mov	r4,r2
  185040:	01400304 	movi	r5,12
  185044:	01805f00 	call	1805f0 <__mulsi3>
  185048:	8085883a 	add	r2,r16,r2
  18504c:	10000015 	stw	zero,0(r2)
  }
}
  185050:	e037883a 	mov	sp,fp
  185054:	dfc00217 	ldw	ra,8(sp)
  185058:	df000117 	ldw	fp,4(sp)
  18505c:	dc000017 	ldw	r16,0(sp)
  185060:	dec00304 	addi	sp,sp,12
  185064:	f800283a 	ret

00185068 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
  185068:	defffa04 	addi	sp,sp,-24
  18506c:	df000515 	stw	fp,20(sp)
  185070:	df000504 	addi	fp,sp,20
  185074:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  185078:	0005303a 	rdctl	r2,status
  18507c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  185080:	e0fffc17 	ldw	r3,-16(fp)
  185084:	00bfff84 	movi	r2,-2
  185088:	1884703a 	and	r2,r3,r2
  18508c:	1001703a 	wrctl	status,r2
  
  return context;
  185090:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
  185094:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
  185098:	e0bfff17 	ldw	r2,-4(fp)
  18509c:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  1850a0:	e0bffd17 	ldw	r2,-12(fp)
  1850a4:	10800017 	ldw	r2,0(r2)
  1850a8:	e0fffd17 	ldw	r3,-12(fp)
  1850ac:	18c00117 	ldw	r3,4(r3)
  1850b0:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
  1850b4:	e0bffd17 	ldw	r2,-12(fp)
  1850b8:	10800117 	ldw	r2,4(r2)
  1850bc:	e0fffd17 	ldw	r3,-12(fp)
  1850c0:	18c00017 	ldw	r3,0(r3)
  1850c4:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  1850c8:	e0bffd17 	ldw	r2,-12(fp)
  1850cc:	e0fffd17 	ldw	r3,-12(fp)
  1850d0:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
  1850d4:	e0bffd17 	ldw	r2,-12(fp)
  1850d8:	e0fffd17 	ldw	r3,-12(fp)
  1850dc:	10c00015 	stw	r3,0(r2)
  1850e0:	e0bffb17 	ldw	r2,-20(fp)
  1850e4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  1850e8:	e0bffe17 	ldw	r2,-8(fp)
  1850ec:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
  1850f0:	e037883a 	mov	sp,fp
  1850f4:	df000017 	ldw	fp,0(sp)
  1850f8:	dec00104 	addi	sp,sp,4
  1850fc:	f800283a 	ret

00185100 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
  185100:	defffb04 	addi	sp,sp,-20
  185104:	dfc00415 	stw	ra,16(sp)
  185108:	df000315 	stw	fp,12(sp)
  18510c:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
  185110:	d0a00717 	ldw	r2,-32740(gp)
  185114:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
  185118:	d0a6d917 	ldw	r2,-25756(gp)
  18511c:	10800044 	addi	r2,r2,1
  185120:	d0a6d915 	stw	r2,-25756(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  185124:	00002e06 	br	1851e0 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
  185128:	e0bffd17 	ldw	r2,-12(fp)
  18512c:	10800017 	ldw	r2,0(r2)
  185130:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
  185134:	e0bffd17 	ldw	r2,-12(fp)
  185138:	10800403 	ldbu	r2,16(r2)
  18513c:	10803fcc 	andi	r2,r2,255
  185140:	10000426 	beq	r2,zero,185154 <alt_tick+0x54>
  185144:	d0a6d917 	ldw	r2,-25756(gp)
  185148:	1000021e 	bne	r2,zero,185154 <alt_tick+0x54>
    {
      alarm->rollover = 0;
  18514c:	e0bffd17 	ldw	r2,-12(fp)
  185150:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
  185154:	e0bffd17 	ldw	r2,-12(fp)
  185158:	10800217 	ldw	r2,8(r2)
  18515c:	d0e6d917 	ldw	r3,-25756(gp)
  185160:	18801d36 	bltu	r3,r2,1851d8 <alt_tick+0xd8>
  185164:	e0bffd17 	ldw	r2,-12(fp)
  185168:	10800403 	ldbu	r2,16(r2)
  18516c:	10803fcc 	andi	r2,r2,255
  185170:	1000191e 	bne	r2,zero,1851d8 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
  185174:	e0bffd17 	ldw	r2,-12(fp)
  185178:	10c00317 	ldw	r3,12(r2)
  18517c:	e0bffd17 	ldw	r2,-12(fp)
  185180:	10800517 	ldw	r2,20(r2)
  185184:	1009883a 	mov	r4,r2
  185188:	183ee83a 	callr	r3
  18518c:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
  185190:	e0bfff17 	ldw	r2,-4(fp)
  185194:	1000031e 	bne	r2,zero,1851a4 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
  185198:	e13ffd17 	ldw	r4,-12(fp)
  18519c:	01850680 	call	185068 <alt_alarm_stop>
  1851a0:	00000d06 	br	1851d8 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
  1851a4:	e0bffd17 	ldw	r2,-12(fp)
  1851a8:	10c00217 	ldw	r3,8(r2)
  1851ac:	e0bfff17 	ldw	r2,-4(fp)
  1851b0:	1887883a 	add	r3,r3,r2
  1851b4:	e0bffd17 	ldw	r2,-12(fp)
  1851b8:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
  1851bc:	e0bffd17 	ldw	r2,-12(fp)
  1851c0:	10c00217 	ldw	r3,8(r2)
  1851c4:	d0a6d917 	ldw	r2,-25756(gp)
  1851c8:	1880032e 	bgeu	r3,r2,1851d8 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
  1851cc:	e0bffd17 	ldw	r2,-12(fp)
  1851d0:	00c00044 	movi	r3,1
  1851d4:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
  1851d8:	e0bffe17 	ldw	r2,-8(fp)
  1851dc:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  1851e0:	e0fffd17 	ldw	r3,-12(fp)
  1851e4:	d0a00704 	addi	r2,gp,-32740
  1851e8:	18bfcf1e 	bne	r3,r2,185128 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
  1851ec:	01853540 	call	185354 <port_time_tick>
}
  1851f0:	e037883a 	mov	sp,fp
  1851f4:	dfc00117 	ldw	ra,4(sp)
  1851f8:	df000017 	ldw	fp,0(sp)
  1851fc:	dec00204 	addi	sp,sp,8
  185200:	f800283a 	ret

00185204 <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
  185204:	deffff04 	addi	sp,sp,-4
  185208:	df000015 	stw	fp,0(sp)
  18520c:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
  185210:	000170fa 	wrctl	ienable,zero
}
  185214:	e037883a 	mov	sp,fp
  185218:	df000017 	ldw	fp,0(sp)
  18521c:	dec00104 	addi	sp,sp,4
  185220:	f800283a 	ret

00185224 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
Thread *chRegFirstThread(void) {
  185224:	defffc04 	addi	sp,sp,-16
  185228:	df000315 	stw	fp,12(sp)
  18522c:	df000304 	addi	fp,sp,12
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  185230:	0005303a 	rdctl	r2,status
  185234:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  185238:	e0fffe17 	ldw	r3,-8(fp)
  18523c:	00bfff84 	movi	r2,-2
  185240:	1884703a 	and	r2,r3,r2
  185244:	1001703a 	wrctl	status,r2
  Thread *tp;

  chSysLock();
  tp = rlist.r_newer;
  185248:	00800674 	movhi	r2,25
  18524c:	10b18704 	addi	r2,r2,-14820
  185250:	10800417 	ldw	r2,16(r2)
  185254:	e0bffd15 	stw	r2,-12(fp)
#if CH_USE_DYNAMIC
  tp->p_refs++;
  185258:	e0bffd17 	ldw	r2,-12(fp)
  18525c:	10800783 	ldbu	r2,30(r2)
  185260:	10800044 	addi	r2,r2,1
  185264:	1007883a 	mov	r3,r2
  185268:	e0bffd17 	ldw	r2,-12(fp)
  18526c:	10c00785 	stb	r3,30(r2)
  185270:	00800044 	movi	r2,1
  185274:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  185278:	e0bfff17 	ldw	r2,-4(fp)
  18527c:	1001703a 	wrctl	status,r2
#endif
  chSysUnlock();
  return tp;
  185280:	e0bffd17 	ldw	r2,-12(fp)
}
  185284:	e037883a 	mov	sp,fp
  185288:	df000017 	ldw	fp,0(sp)
  18528c:	dec00104 	addi	sp,sp,4
  185290:	f800283a 	ret

00185294 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
Thread *chRegNextThread(Thread *tp) {
  185294:	defffa04 	addi	sp,sp,-24
  185298:	dfc00515 	stw	ra,20(sp)
  18529c:	df000415 	stw	fp,16(sp)
  1852a0:	df000404 	addi	fp,sp,16
  1852a4:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  1852a8:	0005303a 	rdctl	r2,status
  1852ac:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  1852b0:	e0fffd17 	ldw	r3,-12(fp)
  1852b4:	00bfff84 	movi	r2,-2
  1852b8:	1884703a 	and	r2,r3,r2
  1852bc:	1001703a 	wrctl	status,r2
  Thread *ntp;

  chSysLock();
  ntp = tp->p_newer;
  1852c0:	e0bfff17 	ldw	r2,-4(fp)
  1852c4:	10800417 	ldw	r2,16(r2)
  1852c8:	e0bffc15 	stw	r2,-16(fp)
  if (ntp == (Thread *)&rlist)
  1852cc:	e0fffc17 	ldw	r3,-16(fp)
  1852d0:	00800674 	movhi	r2,25
  1852d4:	10b18704 	addi	r2,r2,-14820
  1852d8:	1880021e 	bne	r3,r2,1852e4 <chRegNextThread+0x50>
    ntp = NULL;
  1852dc:	e03ffc15 	stw	zero,-16(fp)
  1852e0:	00000606 	br	1852fc <chRegNextThread+0x68>
#if CH_USE_DYNAMIC
  else {
    chDbgAssert(ntp->p_refs < 255, "chRegNextThread(), #1",
                "too many references");
    ntp->p_refs++;
  1852e4:	e0bffc17 	ldw	r2,-16(fp)
  1852e8:	10800783 	ldbu	r2,30(r2)
  1852ec:	10800044 	addi	r2,r2,1
  1852f0:	1007883a 	mov	r3,r2
  1852f4:	e0bffc17 	ldw	r2,-16(fp)
  1852f8:	10c00785 	stb	r3,30(r2)
  1852fc:	00800044 	movi	r2,1
  185300:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  185304:	e0bffe17 	ldw	r2,-8(fp)
  185308:	1001703a 	wrctl	status,r2
  }
#endif
  chSysUnlock();
#if CH_USE_DYNAMIC
  chThdRelease(tp);
  18530c:	e13fff17 	ldw	r4,-4(fp)
  185310:	0182b140 	call	182b14 <chThdRelease>
#endif
  return ntp;
  185314:	e0bffc17 	ldw	r2,-16(fp)
}
  185318:	e037883a 	mov	sp,fp
  18531c:	dfc00117 	ldw	ra,4(sp)
  185320:	df000017 	ldw	fp,0(sp)
  185324:	dec00204 	addi	sp,sp,8
  185328:	f800283a 	ret

0018532c <port_halt>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void port_halt (void) 
{
  18532c:	defffe04 	addi	sp,sp,-8
  185330:	df000115 	stw	fp,4(sp)
  185334:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  185338:	0005303a 	rdctl	r2,status
  18533c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  185340:	e0ffff17 	ldw	r3,-4(fp)
  185344:	00bfff84 	movi	r2,-2
  185348:	1884703a 	and	r2,r3,r2
  18534c:	1001703a 	wrctl	status,r2
   port_disable();
   while (TRUE) 
   {
   }  
  185350:	003fff06 	br	185350 <port_halt+0x24>

00185354 <port_time_tick>:
/*
 * ChibiOS time tick, called by the Nios
 * hal.sys_clk_timer.
 */
CH_IRQ_HANDLER (port_time_tick)
{
  185354:	defffe04 	addi	sp,sp,-8
  185358:	dfc00115 	stw	ra,4(sp)
  18535c:	df000015 	stw	fp,0(sp)
  185360:	d839883a 	mov	fp,sp
   CH_IRQ_PROLOGUE();

   chSysLockFromIsr();
   chSysTimerHandlerI();
  185364:	01843a40 	call	1843a4 <chSysTimerHandlerI>
   chSysUnlockFromIsr();

   CH_IRQ_EPILOGUE();
} /* port_time_tick */
  185368:	e037883a 	mov	sp,fp
  18536c:	dfc00117 	ldw	ra,4(sp)
  185370:	df000017 	ldw	fp,0(sp)
  185374:	dec00204 	addi	sp,sp,8
  185378:	f800283a 	ret

0018537c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  18537c:	defffa04 	addi	sp,sp,-24
  185380:	dfc00515 	stw	ra,20(sp)
  185384:	df000415 	stw	fp,16(sp)
  185388:	df000404 	addi	fp,sp,16
  18538c:	e13ffe15 	stw	r4,-8(fp)
  185390:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
  185394:	e0bfff17 	ldw	r2,-4(fp)
  185398:	10800017 	ldw	r2,0(r2)
  18539c:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
  1853a0:	e13ffe17 	ldw	r4,-8(fp)
  1853a4:	0186f840 	call	186f84 <strlen>
  1853a8:	10800044 	addi	r2,r2,1
  1853ac:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  1853b0:	00000d06 	br	1853e8 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  1853b4:	e0bffc17 	ldw	r2,-16(fp)
  1853b8:	10c00217 	ldw	r3,8(r2)
  1853bc:	e0bffd17 	ldw	r2,-12(fp)
  1853c0:	1809883a 	mov	r4,r3
  1853c4:	e17ffe17 	ldw	r5,-8(fp)
  1853c8:	100d883a 	mov	r6,r2
  1853cc:	01864300 	call	186430 <memcmp>
  1853d0:	1000021e 	bne	r2,zero,1853dc <alt_find_dev+0x60>
    {
      /* match found */

      return next;
  1853d4:	e0bffc17 	ldw	r2,-16(fp)
  1853d8:	00000706 	br	1853f8 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
  1853dc:	e0bffc17 	ldw	r2,-16(fp)
  1853e0:	10800017 	ldw	r2,0(r2)
  1853e4:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  1853e8:	e0fffc17 	ldw	r3,-16(fp)
  1853ec:	e0bfff17 	ldw	r2,-4(fp)
  1853f0:	18bff01e 	bne	r3,r2,1853b4 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
  1853f4:	0005883a 	mov	r2,zero
}
  1853f8:	e037883a 	mov	sp,fp
  1853fc:	dfc00117 	ldw	ra,4(sp)
  185400:	df000017 	ldw	fp,0(sp)
  185404:	dec00204 	addi	sp,sp,8
  185408:	f800283a 	ret

0018540c <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
  18540c:	defffb04 	addi	sp,sp,-20
  185410:	dfc00415 	stw	ra,16(sp)
  185414:	df000315 	stw	fp,12(sp)
  185418:	df000304 	addi	fp,sp,12
  18541c:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
  185420:	00800674 	movhi	r2,25
  185424:	10aa8004 	addi	r2,r2,-22016
  185428:	10800017 	ldw	r2,0(r2)
  18542c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  185430:	00003106 	br	1854f8 <alt_find_file+0xec>
  {
    len = strlen(next->name);
  185434:	e0bffd17 	ldw	r2,-12(fp)
  185438:	10800217 	ldw	r2,8(r2)
  18543c:	1009883a 	mov	r4,r2
  185440:	0186f840 	call	186f84 <strlen>
  185444:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
  185448:	e0bffd17 	ldw	r2,-12(fp)
  18544c:	10c00217 	ldw	r3,8(r2)
  185450:	e0bffe17 	ldw	r2,-8(fp)
  185454:	10bfffc4 	addi	r2,r2,-1
  185458:	1885883a 	add	r2,r3,r2
  18545c:	10800003 	ldbu	r2,0(r2)
  185460:	10803fcc 	andi	r2,r2,255
  185464:	1080201c 	xori	r2,r2,128
  185468:	10bfe004 	addi	r2,r2,-128
  18546c:	10800bd8 	cmpnei	r2,r2,47
  185470:	1000031e 	bne	r2,zero,185480 <alt_find_file+0x74>
    {
      len -= 1;
  185474:	e0bffe17 	ldw	r2,-8(fp)
  185478:	10bfffc4 	addi	r2,r2,-1
  18547c:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  185480:	e0bffe17 	ldw	r2,-8(fp)
  185484:	e0ffff17 	ldw	r3,-4(fp)
  185488:	1885883a 	add	r2,r3,r2
  18548c:	10800003 	ldbu	r2,0(r2)
  185490:	10803fcc 	andi	r2,r2,255
  185494:	1080201c 	xori	r2,r2,128
  185498:	10bfe004 	addi	r2,r2,-128
  18549c:	10800be0 	cmpeqi	r2,r2,47
  1854a0:	1000081e 	bne	r2,zero,1854c4 <alt_find_file+0xb8>
  1854a4:	e0bffe17 	ldw	r2,-8(fp)
  1854a8:	e0ffff17 	ldw	r3,-4(fp)
  1854ac:	1885883a 	add	r2,r3,r2
  1854b0:	10800003 	ldbu	r2,0(r2)
  1854b4:	10803fcc 	andi	r2,r2,255
  1854b8:	1080201c 	xori	r2,r2,128
  1854bc:	10bfe004 	addi	r2,r2,-128
  1854c0:	10000a1e 	bne	r2,zero,1854ec <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
  1854c4:	e0bffd17 	ldw	r2,-12(fp)
  1854c8:	10c00217 	ldw	r3,8(r2)
  1854cc:	e0bffe17 	ldw	r2,-8(fp)
  1854d0:	1809883a 	mov	r4,r3
  1854d4:	e17fff17 	ldw	r5,-4(fp)
  1854d8:	100d883a 	mov	r6,r2
  1854dc:	01864300 	call	186430 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  1854e0:	1000021e 	bne	r2,zero,1854ec <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
  1854e4:	e0bffd17 	ldw	r2,-12(fp)
  1854e8:	00000806 	br	18550c <alt_find_file+0x100>
    }
    next = (alt_dev*) next->llist.next;
  1854ec:	e0bffd17 	ldw	r2,-12(fp)
  1854f0:	10800017 	ldw	r2,0(r2)
  1854f4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  1854f8:	e0fffd17 	ldw	r3,-12(fp)
  1854fc:	00800674 	movhi	r2,25
  185500:	10aa8004 	addi	r2,r2,-22016
  185504:	18bfcb1e 	bne	r3,r2,185434 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
  185508:	0005883a 	mov	r2,zero
}
  18550c:	e037883a 	mov	sp,fp
  185510:	dfc00117 	ldw	ra,4(sp)
  185514:	df000017 	ldw	fp,0(sp)
  185518:	dec00204 	addi	sp,sp,8
  18551c:	f800283a 	ret

00185520 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
  185520:	defffa04 	addi	sp,sp,-24
  185524:	dfc00515 	stw	ra,20(sp)
  185528:	df000415 	stw	fp,16(sp)
  18552c:	dc000315 	stw	r16,12(sp)
  185530:	df000304 	addi	fp,sp,12
  185534:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
  185538:	00bffa04 	movi	r2,-24
  18553c:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  185540:	e03ffd15 	stw	zero,-12(fp)
  185544:	00002106 	br	1855cc <alt_get_fd+0xac>
  {
    if (!alt_fd_list[i].dev)
  185548:	04000674 	movhi	r16,25
  18554c:	84281e04 	addi	r16,r16,-24456
  185550:	e0bffd17 	ldw	r2,-12(fp)
  185554:	1009883a 	mov	r4,r2
  185558:	01400304 	movi	r5,12
  18555c:	01805f00 	call	1805f0 <__mulsi3>
  185560:	8085883a 	add	r2,r16,r2
  185564:	10800017 	ldw	r2,0(r2)
  185568:	1000151e 	bne	r2,zero,1855c0 <alt_get_fd+0xa0>
    {
      alt_fd_list[i].dev = dev;
  18556c:	04000674 	movhi	r16,25
  185570:	84281e04 	addi	r16,r16,-24456
  185574:	e0bffd17 	ldw	r2,-12(fp)
  185578:	1009883a 	mov	r4,r2
  18557c:	01400304 	movi	r5,12
  185580:	01805f00 	call	1805f0 <__mulsi3>
  185584:	8085883a 	add	r2,r16,r2
  185588:	e0ffff17 	ldw	r3,-4(fp)
  18558c:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
  185590:	00800674 	movhi	r2,25
  185594:	10aa8404 	addi	r2,r2,-22000
  185598:	10c00017 	ldw	r3,0(r2)
  18559c:	e0bffd17 	ldw	r2,-12(fp)
  1855a0:	1880040e 	bge	r3,r2,1855b4 <alt_get_fd+0x94>
      {
        alt_max_fd = i;
  1855a4:	00800674 	movhi	r2,25
  1855a8:	10aa8404 	addi	r2,r2,-22000
  1855ac:	e0fffd17 	ldw	r3,-12(fp)
  1855b0:	10c00015 	stw	r3,0(r2)
      }
      rc = i;
  1855b4:	e0bffd17 	ldw	r2,-12(fp)
  1855b8:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
  1855bc:	00000606 	br	1855d8 <alt_get_fd+0xb8>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  1855c0:	e0bffd17 	ldw	r2,-12(fp)
  1855c4:	10800044 	addi	r2,r2,1
  1855c8:	e0bffd15 	stw	r2,-12(fp)
  1855cc:	e0bffd17 	ldw	r2,-12(fp)
  1855d0:	10800810 	cmplti	r2,r2,32
  1855d4:	103fdc1e 	bne	r2,zero,185548 <alt_get_fd+0x28>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
  1855d8:	e0bffe17 	ldw	r2,-8(fp)
}
  1855dc:	e037883a 	mov	sp,fp
  1855e0:	dfc00217 	ldw	ra,8(sp)
  1855e4:	df000117 	ldw	fp,4(sp)
  1855e8:	dc000017 	ldw	r16,0(sp)
  1855ec:	dec00304 	addi	sp,sp,12
  1855f0:	f800283a 	ret

001855f4 <atexit>:
  1855f4:	200b883a 	mov	r5,r4
  1855f8:	000d883a 	mov	r6,zero
  1855fc:	0009883a 	mov	r4,zero
  185600:	000f883a 	mov	r7,zero
  185604:	01872dc1 	jmpi	1872dc <__register_exitproc>

00185608 <exit>:
  185608:	defffe04 	addi	sp,sp,-8
  18560c:	000b883a 	mov	r5,zero
  185610:	dc000015 	stw	r16,0(sp)
  185614:	dfc00115 	stw	ra,4(sp)
  185618:	2021883a 	mov	r16,r4
  18561c:	018740c0 	call	18740c <__call_exitprocs>
  185620:	00800674 	movhi	r2,25
  185624:	10aa8904 	addi	r2,r2,-21980
  185628:	11000017 	ldw	r4,0(r2)
  18562c:	20800f17 	ldw	r2,60(r4)
  185630:	10000126 	beq	r2,zero,185638 <exit+0x30>
  185634:	103ee83a 	callr	r2
  185638:	8009883a 	mov	r4,r16
  18563c:	01887a40 	call	1887a4 <_exit>

00185640 <_fputs_r>:
  185640:	defff804 	addi	sp,sp,-32
  185644:	dc000515 	stw	r16,20(sp)
  185648:	2021883a 	mov	r16,r4
  18564c:	2809883a 	mov	r4,r5
  185650:	dc400615 	stw	r17,24(sp)
  185654:	dfc00715 	stw	ra,28(sp)
  185658:	3023883a 	mov	r17,r6
  18565c:	d9400315 	stw	r5,12(sp)
  185660:	0186f840 	call	186f84 <strlen>
  185664:	d8800215 	stw	r2,8(sp)
  185668:	d8800415 	stw	r2,16(sp)
  18566c:	d8800304 	addi	r2,sp,12
  185670:	d8800015 	stw	r2,0(sp)
  185674:	00800044 	movi	r2,1
  185678:	d8800115 	stw	r2,4(sp)
  18567c:	80000426 	beq	r16,zero,185690 <_fputs_r+0x50>
  185680:	80800e17 	ldw	r2,56(r16)
  185684:	1000021e 	bne	r2,zero,185690 <_fputs_r+0x50>
  185688:	8009883a 	mov	r4,r16
  18568c:	01878680 	call	187868 <__sinit>
  185690:	8009883a 	mov	r4,r16
  185694:	880b883a 	mov	r5,r17
  185698:	d80d883a 	mov	r6,sp
  18569c:	01856d00 	call	1856d0 <__sfvwrite_r>
  1856a0:	dfc00717 	ldw	ra,28(sp)
  1856a4:	dc400617 	ldw	r17,24(sp)
  1856a8:	dc000517 	ldw	r16,20(sp)
  1856ac:	dec00804 	addi	sp,sp,32
  1856b0:	f800283a 	ret

001856b4 <fputs>:
  1856b4:	00c00674 	movhi	r3,25
  1856b8:	18ea8a04 	addi	r3,r3,-21976
  1856bc:	2005883a 	mov	r2,r4
  1856c0:	19000017 	ldw	r4,0(r3)
  1856c4:	280d883a 	mov	r6,r5
  1856c8:	100b883a 	mov	r5,r2
  1856cc:	01856401 	jmpi	185640 <_fputs_r>

001856d0 <__sfvwrite_r>:
  1856d0:	30800217 	ldw	r2,8(r6)
  1856d4:	defff504 	addi	sp,sp,-44
  1856d8:	dd400615 	stw	r21,24(sp)
  1856dc:	dd000515 	stw	r20,20(sp)
  1856e0:	dc000115 	stw	r16,4(sp)
  1856e4:	dfc00a15 	stw	ra,40(sp)
  1856e8:	df000915 	stw	fp,36(sp)
  1856ec:	ddc00815 	stw	r23,32(sp)
  1856f0:	dd800715 	stw	r22,28(sp)
  1856f4:	dcc00415 	stw	r19,16(sp)
  1856f8:	dc800315 	stw	r18,12(sp)
  1856fc:	dc400215 	stw	r17,8(sp)
  185700:	3029883a 	mov	r20,r6
  185704:	202b883a 	mov	r21,r4
  185708:	2821883a 	mov	r16,r5
  18570c:	10002126 	beq	r2,zero,185794 <__sfvwrite_r+0xc4>
  185710:	2880030b 	ldhu	r2,12(r5)
  185714:	10c0020c 	andi	r3,r2,8
  185718:	18ffffcc 	andi	r3,r3,65535
  18571c:	18e0001c 	xori	r3,r3,32768
  185720:	18e00004 	addi	r3,r3,-32768
  185724:	18002826 	beq	r3,zero,1857c8 <__sfvwrite_r+0xf8>
  185728:	28c00417 	ldw	r3,16(r5)
  18572c:	18002626 	beq	r3,zero,1857c8 <__sfvwrite_r+0xf8>
  185730:	10c0008c 	andi	r3,r2,2
  185734:	18ffffcc 	andi	r3,r3,65535
  185738:	18e0001c 	xori	r3,r3,32768
  18573c:	18e00004 	addi	r3,r3,-32768
  185740:	a4400017 	ldw	r17,0(r20)
  185744:	18002b26 	beq	r3,zero,1857f4 <__sfvwrite_r+0x124>
  185748:	0027883a 	mov	r19,zero
  18574c:	0025883a 	mov	r18,zero
  185750:	05810004 	movi	r22,1024
  185754:	980d883a 	mov	r6,r19
  185758:	a809883a 	mov	r4,r21
  18575c:	90004f26 	beq	r18,zero,18589c <__sfvwrite_r+0x1cc>
  185760:	900f883a 	mov	r7,r18
  185764:	81400717 	ldw	r5,28(r16)
  185768:	b480012e 	bgeu	r22,r18,185770 <__sfvwrite_r+0xa0>
  18576c:	01c10004 	movi	r7,1024
  185770:	80800917 	ldw	r2,36(r16)
  185774:	103ee83a 	callr	r2
  185778:	0080540e 	bge	zero,r2,1858cc <__sfvwrite_r+0x1fc>
  18577c:	a0c00217 	ldw	r3,8(r20)
  185780:	98a7883a 	add	r19,r19,r2
  185784:	90a5c83a 	sub	r18,r18,r2
  185788:	1885c83a 	sub	r2,r3,r2
  18578c:	a0800215 	stw	r2,8(r20)
  185790:	103ff01e 	bne	r2,zero,185754 <__sfvwrite_r+0x84>
  185794:	0005883a 	mov	r2,zero
  185798:	dfc00a17 	ldw	ra,40(sp)
  18579c:	df000917 	ldw	fp,36(sp)
  1857a0:	ddc00817 	ldw	r23,32(sp)
  1857a4:	dd800717 	ldw	r22,28(sp)
  1857a8:	dd400617 	ldw	r21,24(sp)
  1857ac:	dd000517 	ldw	r20,20(sp)
  1857b0:	dcc00417 	ldw	r19,16(sp)
  1857b4:	dc800317 	ldw	r18,12(sp)
  1857b8:	dc400217 	ldw	r17,8(sp)
  1857bc:	dc000117 	ldw	r16,4(sp)
  1857c0:	dec00b04 	addi	sp,sp,44
  1857c4:	f800283a 	ret
  1857c8:	a809883a 	mov	r4,r21
  1857cc:	800b883a 	mov	r5,r16
  1857d0:	01871680 	call	187168 <__swsetup_r>
  1857d4:	1000f01e 	bne	r2,zero,185b98 <__sfvwrite_r+0x4c8>
  1857d8:	8080030b 	ldhu	r2,12(r16)
  1857dc:	a4400017 	ldw	r17,0(r20)
  1857e0:	10c0008c 	andi	r3,r2,2
  1857e4:	18ffffcc 	andi	r3,r3,65535
  1857e8:	18e0001c 	xori	r3,r3,32768
  1857ec:	18e00004 	addi	r3,r3,-32768
  1857f0:	183fd51e 	bne	r3,zero,185748 <__sfvwrite_r+0x78>
  1857f4:	10c0004c 	andi	r3,r2,1
  1857f8:	002d883a 	mov	r22,zero
  1857fc:	1800381e 	bne	r3,zero,1858e0 <__sfvwrite_r+0x210>
  185800:	0025883a 	mov	r18,zero
  185804:	90002126 	beq	r18,zero,18588c <__sfvwrite_r+0x1bc>
  185808:	10c0800c 	andi	r3,r2,512
  18580c:	18ffffcc 	andi	r3,r3,65535
  185810:	18e0001c 	xori	r3,r3,32768
  185814:	18e00004 	addi	r3,r3,-32768
  185818:	84c00217 	ldw	r19,8(r16)
  18581c:	18006b26 	beq	r3,zero,1859cc <__sfvwrite_r+0x2fc>
  185820:	980f883a 	mov	r7,r19
  185824:	94c08636 	bltu	r18,r19,185a40 <__sfvwrite_r+0x370>
  185828:	10c1200c 	andi	r3,r2,1152
  18582c:	18009f1e 	bne	r3,zero,185aac <__sfvwrite_r+0x3dc>
  185830:	81000017 	ldw	r4,0(r16)
  185834:	982f883a 	mov	r23,r19
  185838:	9039883a 	mov	fp,r18
  18583c:	9027883a 	mov	r19,r18
  185840:	380d883a 	mov	r6,r7
  185844:	b00b883a 	mov	r5,r22
  185848:	d9c00015 	stw	r7,0(sp)
  18584c:	01865ec0 	call	1865ec <memmove>
  185850:	d9c00017 	ldw	r7,0(sp)
  185854:	81000217 	ldw	r4,8(r16)
  185858:	80800017 	ldw	r2,0(r16)
  18585c:	25efc83a 	sub	r23,r4,r23
  185860:	11cf883a 	add	r7,r2,r7
  185864:	85c00215 	stw	r23,8(r16)
  185868:	81c00015 	stw	r7,0(r16)
  18586c:	a0800217 	ldw	r2,8(r20)
  185870:	b72d883a 	add	r22,r22,fp
  185874:	9725c83a 	sub	r18,r18,fp
  185878:	14e7c83a 	sub	r19,r2,r19
  18587c:	a4c00215 	stw	r19,8(r20)
  185880:	983fc426 	beq	r19,zero,185794 <__sfvwrite_r+0xc4>
  185884:	8080030b 	ldhu	r2,12(r16)
  185888:	903fdf1e 	bne	r18,zero,185808 <__sfvwrite_r+0x138>
  18588c:	8d800017 	ldw	r22,0(r17)
  185890:	8c800117 	ldw	r18,4(r17)
  185894:	8c400204 	addi	r17,r17,8
  185898:	003fda06 	br	185804 <__sfvwrite_r+0x134>
  18589c:	8cc00017 	ldw	r19,0(r17)
  1858a0:	8c800117 	ldw	r18,4(r17)
  1858a4:	8c400204 	addi	r17,r17,8
  1858a8:	003faa06 	br	185754 <__sfvwrite_r+0x84>
  1858ac:	01869240 	call	186924 <_realloc_r>
  1858b0:	102f883a 	mov	r23,r2
  1858b4:	10009f1e 	bne	r2,zero,185b34 <__sfvwrite_r+0x464>
  1858b8:	81400417 	ldw	r5,16(r16)
  1858bc:	a809883a 	mov	r4,r21
  1858c0:	0187bec0 	call	187bec <_free_r>
  1858c4:	00800304 	movi	r2,12
  1858c8:	a8800015 	stw	r2,0(r21)
  1858cc:	80c0030b 	ldhu	r3,12(r16)
  1858d0:	00bfffc4 	movi	r2,-1
  1858d4:	18c01014 	ori	r3,r3,64
  1858d8:	80c0030d 	sth	r3,12(r16)
  1858dc:	003fae06 	br	185798 <__sfvwrite_r+0xc8>
  1858e0:	0007883a 	mov	r3,zero
  1858e4:	0039883a 	mov	fp,zero
  1858e8:	0025883a 	mov	r18,zero
  1858ec:	90001e26 	beq	r18,zero,185968 <__sfvwrite_r+0x298>
  1858f0:	18006526 	beq	r3,zero,185a88 <__sfvwrite_r+0x3b8>
  1858f4:	b02f883a 	mov	r23,r22
  1858f8:	9580012e 	bgeu	r18,r22,185900 <__sfvwrite_r+0x230>
  1858fc:	902f883a 	mov	r23,r18
  185900:	81000017 	ldw	r4,0(r16)
  185904:	80800417 	ldw	r2,16(r16)
  185908:	84c00217 	ldw	r19,8(r16)
  18590c:	81c00517 	ldw	r7,20(r16)
  185910:	1100022e 	bgeu	r2,r4,18591c <__sfvwrite_r+0x24c>
  185914:	99e7883a 	add	r19,r19,r7
  185918:	9dc01816 	blt	r19,r23,18597c <__sfvwrite_r+0x2ac>
  18591c:	b9c03b16 	blt	r23,r7,185a0c <__sfvwrite_r+0x33c>
  185920:	80800917 	ldw	r2,36(r16)
  185924:	81400717 	ldw	r5,28(r16)
  185928:	a809883a 	mov	r4,r21
  18592c:	d8c00015 	stw	r3,0(sp)
  185930:	e00d883a 	mov	r6,fp
  185934:	103ee83a 	callr	r2
  185938:	1027883a 	mov	r19,r2
  18593c:	d8c00017 	ldw	r3,0(sp)
  185940:	00bfe20e 	bge	zero,r2,1858cc <__sfvwrite_r+0x1fc>
  185944:	b4edc83a 	sub	r22,r22,r19
  185948:	b0001a26 	beq	r22,zero,1859b4 <__sfvwrite_r+0x2e4>
  18594c:	a0800217 	ldw	r2,8(r20)
  185950:	e4f9883a 	add	fp,fp,r19
  185954:	94e5c83a 	sub	r18,r18,r19
  185958:	14e7c83a 	sub	r19,r2,r19
  18595c:	a4c00215 	stw	r19,8(r20)
  185960:	983f8c26 	beq	r19,zero,185794 <__sfvwrite_r+0xc4>
  185964:	903fe21e 	bne	r18,zero,1858f0 <__sfvwrite_r+0x220>
  185968:	8f000017 	ldw	fp,0(r17)
  18596c:	8c800117 	ldw	r18,4(r17)
  185970:	0007883a 	mov	r3,zero
  185974:	8c400204 	addi	r17,r17,8
  185978:	003fdc06 	br	1858ec <__sfvwrite_r+0x21c>
  18597c:	e00b883a 	mov	r5,fp
  185980:	980d883a 	mov	r6,r19
  185984:	d8c00015 	stw	r3,0(sp)
  185988:	01865ec0 	call	1865ec <memmove>
  18598c:	80800017 	ldw	r2,0(r16)
  185990:	a809883a 	mov	r4,r21
  185994:	800b883a 	mov	r5,r16
  185998:	14c5883a 	add	r2,r2,r19
  18599c:	80800015 	stw	r2,0(r16)
  1859a0:	01875ac0 	call	1875ac <_fflush_r>
  1859a4:	d8c00017 	ldw	r3,0(sp)
  1859a8:	103fc81e 	bne	r2,zero,1858cc <__sfvwrite_r+0x1fc>
  1859ac:	b4edc83a 	sub	r22,r22,r19
  1859b0:	b03fe61e 	bne	r22,zero,18594c <__sfvwrite_r+0x27c>
  1859b4:	a809883a 	mov	r4,r21
  1859b8:	800b883a 	mov	r5,r16
  1859bc:	01875ac0 	call	1875ac <_fflush_r>
  1859c0:	103fc21e 	bne	r2,zero,1858cc <__sfvwrite_r+0x1fc>
  1859c4:	0007883a 	mov	r3,zero
  1859c8:	003fe006 	br	18594c <__sfvwrite_r+0x27c>
  1859cc:	81000017 	ldw	r4,0(r16)
  1859d0:	80800417 	ldw	r2,16(r16)
  1859d4:	1100022e 	bgeu	r2,r4,1859e0 <__sfvwrite_r+0x310>
  1859d8:	9839883a 	mov	fp,r19
  1859dc:	9c806036 	bltu	r19,r18,185b60 <__sfvwrite_r+0x490>
  1859e0:	81c00517 	ldw	r7,20(r16)
  1859e4:	91c01c36 	bltu	r18,r7,185a58 <__sfvwrite_r+0x388>
  1859e8:	80800917 	ldw	r2,36(r16)
  1859ec:	81400717 	ldw	r5,28(r16)
  1859f0:	a809883a 	mov	r4,r21
  1859f4:	b00d883a 	mov	r6,r22
  1859f8:	103ee83a 	callr	r2
  1859fc:	1027883a 	mov	r19,r2
  185a00:	00bfb20e 	bge	zero,r2,1858cc <__sfvwrite_r+0x1fc>
  185a04:	1039883a 	mov	fp,r2
  185a08:	003f9806 	br	18586c <__sfvwrite_r+0x19c>
  185a0c:	b80d883a 	mov	r6,r23
  185a10:	e00b883a 	mov	r5,fp
  185a14:	d8c00015 	stw	r3,0(sp)
  185a18:	01865ec0 	call	1865ec <memmove>
  185a1c:	80800217 	ldw	r2,8(r16)
  185a20:	81000017 	ldw	r4,0(r16)
  185a24:	b827883a 	mov	r19,r23
  185a28:	15c5c83a 	sub	r2,r2,r23
  185a2c:	25ef883a 	add	r23,r4,r23
  185a30:	80800215 	stw	r2,8(r16)
  185a34:	85c00015 	stw	r23,0(r16)
  185a38:	d8c00017 	ldw	r3,0(sp)
  185a3c:	003fc106 	br	185944 <__sfvwrite_r+0x274>
  185a40:	81000017 	ldw	r4,0(r16)
  185a44:	902f883a 	mov	r23,r18
  185a48:	9039883a 	mov	fp,r18
  185a4c:	9027883a 	mov	r19,r18
  185a50:	900f883a 	mov	r7,r18
  185a54:	003f7a06 	br	185840 <__sfvwrite_r+0x170>
  185a58:	b00b883a 	mov	r5,r22
  185a5c:	900d883a 	mov	r6,r18
  185a60:	01865ec0 	call	1865ec <memmove>
  185a64:	80c00217 	ldw	r3,8(r16)
  185a68:	80800017 	ldw	r2,0(r16)
  185a6c:	9027883a 	mov	r19,r18
  185a70:	1c87c83a 	sub	r3,r3,r18
  185a74:	1485883a 	add	r2,r2,r18
  185a78:	80c00215 	stw	r3,8(r16)
  185a7c:	80800015 	stw	r2,0(r16)
  185a80:	9039883a 	mov	fp,r18
  185a84:	003f7906 	br	18586c <__sfvwrite_r+0x19c>
  185a88:	e009883a 	mov	r4,fp
  185a8c:	01400284 	movi	r5,10
  185a90:	900d883a 	mov	r6,r18
  185a94:	01863380 	call	186338 <memchr>
  185a98:	10003c26 	beq	r2,zero,185b8c <__sfvwrite_r+0x4bc>
  185a9c:	15800044 	addi	r22,r2,1
  185aa0:	b72dc83a 	sub	r22,r22,fp
  185aa4:	00c00044 	movi	r3,1
  185aa8:	003f9206 	br	1858f4 <__sfvwrite_r+0x224>
  185aac:	81000517 	ldw	r4,20(r16)
  185ab0:	81400417 	ldw	r5,16(r16)
  185ab4:	80c00017 	ldw	r3,0(r16)
  185ab8:	210d883a 	add	r6,r4,r4
  185abc:	3109883a 	add	r4,r6,r4
  185ac0:	2026d7fa 	srli	r19,r4,31
  185ac4:	1979c83a 	sub	fp,r3,r5
  185ac8:	e1800044 	addi	r6,fp,1
  185acc:	9909883a 	add	r4,r19,r4
  185ad0:	2027d07a 	srai	r19,r4,1
  185ad4:	3489883a 	add	r4,r6,r18
  185ad8:	980d883a 	mov	r6,r19
  185adc:	9900022e 	bgeu	r19,r4,185ae8 <__sfvwrite_r+0x418>
  185ae0:	2027883a 	mov	r19,r4
  185ae4:	200d883a 	mov	r6,r4
  185ae8:	1081000c 	andi	r2,r2,1024
  185aec:	10bfffcc 	andi	r2,r2,65535
  185af0:	10a0001c 	xori	r2,r2,32768
  185af4:	10a00004 	addi	r2,r2,-32768
  185af8:	a809883a 	mov	r4,r21
  185afc:	103f6b26 	beq	r2,zero,1858ac <__sfvwrite_r+0x1dc>
  185b00:	300b883a 	mov	r5,r6
  185b04:	0185bb40 	call	185bb4 <_malloc_r>
  185b08:	102f883a 	mov	r23,r2
  185b0c:	103f6d26 	beq	r2,zero,1858c4 <__sfvwrite_r+0x1f4>
  185b10:	81400417 	ldw	r5,16(r16)
  185b14:	1009883a 	mov	r4,r2
  185b18:	e00d883a 	mov	r6,fp
  185b1c:	01864ac0 	call	1864ac <memcpy>
  185b20:	8080030b 	ldhu	r2,12(r16)
  185b24:	00fedfc4 	movi	r3,-1153
  185b28:	10c4703a 	and	r2,r2,r3
  185b2c:	10802014 	ori	r2,r2,128
  185b30:	8080030d 	sth	r2,12(r16)
  185b34:	bf09883a 	add	r4,r23,fp
  185b38:	9f07c83a 	sub	r3,r19,fp
  185b3c:	85c00415 	stw	r23,16(r16)
  185b40:	84c00515 	stw	r19,20(r16)
  185b44:	81000015 	stw	r4,0(r16)
  185b48:	902f883a 	mov	r23,r18
  185b4c:	80c00215 	stw	r3,8(r16)
  185b50:	9039883a 	mov	fp,r18
  185b54:	9027883a 	mov	r19,r18
  185b58:	900f883a 	mov	r7,r18
  185b5c:	003f3806 	br	185840 <__sfvwrite_r+0x170>
  185b60:	b00b883a 	mov	r5,r22
  185b64:	980d883a 	mov	r6,r19
  185b68:	01865ec0 	call	1865ec <memmove>
  185b6c:	80800017 	ldw	r2,0(r16)
  185b70:	a809883a 	mov	r4,r21
  185b74:	800b883a 	mov	r5,r16
  185b78:	14c5883a 	add	r2,r2,r19
  185b7c:	80800015 	stw	r2,0(r16)
  185b80:	01875ac0 	call	1875ac <_fflush_r>
  185b84:	103f3926 	beq	r2,zero,18586c <__sfvwrite_r+0x19c>
  185b88:	003f5006 	br	1858cc <__sfvwrite_r+0x1fc>
  185b8c:	95800044 	addi	r22,r18,1
  185b90:	00c00044 	movi	r3,1
  185b94:	003f5706 	br	1858f4 <__sfvwrite_r+0x224>
  185b98:	80c0030b 	ldhu	r3,12(r16)
  185b9c:	00bfffc4 	movi	r2,-1
  185ba0:	18c01014 	ori	r3,r3,64
  185ba4:	80c0030d 	sth	r3,12(r16)
  185ba8:	00c00244 	movi	r3,9
  185bac:	a8c00015 	stw	r3,0(r21)
  185bb0:	003ef906 	br	185798 <__sfvwrite_r+0xc8>

00185bb4 <_malloc_r>:
  185bb4:	defff604 	addi	sp,sp,-40
  185bb8:	dc800215 	stw	r18,8(sp)
  185bbc:	dfc00915 	stw	ra,36(sp)
  185bc0:	df000815 	stw	fp,32(sp)
  185bc4:	ddc00715 	stw	r23,28(sp)
  185bc8:	dd800615 	stw	r22,24(sp)
  185bcc:	dd400515 	stw	r21,20(sp)
  185bd0:	dd000415 	stw	r20,16(sp)
  185bd4:	dcc00315 	stw	r19,12(sp)
  185bd8:	dc400115 	stw	r17,4(sp)
  185bdc:	dc000015 	stw	r16,0(sp)
  185be0:	288002c4 	addi	r2,r5,11
  185be4:	00c00584 	movi	r3,22
  185be8:	2025883a 	mov	r18,r4
  185bec:	18802b2e 	bgeu	r3,r2,185c9c <_malloc_r+0xe8>
  185bf0:	047ffe04 	movi	r17,-8
  185bf4:	1462703a 	and	r17,r2,r17
  185bf8:	88002a16 	blt	r17,zero,185ca4 <_malloc_r+0xf0>
  185bfc:	89402936 	bltu	r17,r5,185ca4 <_malloc_r+0xf0>
  185c00:	9009883a 	mov	r4,r18
  185c04:	0188afc0 	call	188afc <__malloc_lock>
  185c08:	00807dc4 	movi	r2,503
  185c0c:	14402936 	bltu	r2,r17,185cb4 <_malloc_r+0x100>
  185c10:	8808d0fa 	srli	r4,r17,3
  185c14:	04c00674 	movhi	r19,25
  185c18:	9ce97e04 	addi	r19,r19,-23048
  185c1c:	2105883a 	add	r2,r4,r4
  185c20:	1085883a 	add	r2,r2,r2
  185c24:	1085883a 	add	r2,r2,r2
  185c28:	9885883a 	add	r2,r19,r2
  185c2c:	14000317 	ldw	r16,12(r2)
  185c30:	80815526 	beq	r16,r2,186188 <_malloc_r+0x5d4>
  185c34:	81000117 	ldw	r4,4(r16)
  185c38:	00bfff04 	movi	r2,-4
  185c3c:	80c00317 	ldw	r3,12(r16)
  185c40:	2084703a 	and	r2,r4,r2
  185c44:	8085883a 	add	r2,r16,r2
  185c48:	11800117 	ldw	r6,4(r2)
  185c4c:	81400217 	ldw	r5,8(r16)
  185c50:	9009883a 	mov	r4,r18
  185c54:	31800054 	ori	r6,r6,1
  185c58:	11800115 	stw	r6,4(r2)
  185c5c:	28c00315 	stw	r3,12(r5)
  185c60:	19400215 	stw	r5,8(r3)
  185c64:	0188b1c0 	call	188b1c <__malloc_unlock>
  185c68:	80800204 	addi	r2,r16,8
  185c6c:	dfc00917 	ldw	ra,36(sp)
  185c70:	df000817 	ldw	fp,32(sp)
  185c74:	ddc00717 	ldw	r23,28(sp)
  185c78:	dd800617 	ldw	r22,24(sp)
  185c7c:	dd400517 	ldw	r21,20(sp)
  185c80:	dd000417 	ldw	r20,16(sp)
  185c84:	dcc00317 	ldw	r19,12(sp)
  185c88:	dc800217 	ldw	r18,8(sp)
  185c8c:	dc400117 	ldw	r17,4(sp)
  185c90:	dc000017 	ldw	r16,0(sp)
  185c94:	dec00a04 	addi	sp,sp,40
  185c98:	f800283a 	ret
  185c9c:	04400404 	movi	r17,16
  185ca0:	897fd72e 	bgeu	r17,r5,185c00 <_malloc_r+0x4c>
  185ca4:	00800304 	movi	r2,12
  185ca8:	90800015 	stw	r2,0(r18)
  185cac:	0005883a 	mov	r2,zero
  185cb0:	003fee06 	br	185c6c <_malloc_r+0xb8>
  185cb4:	8808d27a 	srli	r4,r17,9
  185cb8:	20007126 	beq	r4,zero,185e80 <_malloc_r+0x2cc>
  185cbc:	00800104 	movi	r2,4
  185cc0:	1100eb36 	bltu	r2,r4,186070 <_malloc_r+0x4bc>
  185cc4:	8808d1ba 	srli	r4,r17,6
  185cc8:	21000e04 	addi	r4,r4,56
  185ccc:	210b883a 	add	r5,r4,r4
  185cd0:	294b883a 	add	r5,r5,r5
  185cd4:	294b883a 	add	r5,r5,r5
  185cd8:	04c00674 	movhi	r19,25
  185cdc:	9ce97e04 	addi	r19,r19,-23048
  185ce0:	994b883a 	add	r5,r19,r5
  185ce4:	2c000317 	ldw	r16,12(r5)
  185ce8:	2c000e26 	beq	r5,r16,185d24 <_malloc_r+0x170>
  185cec:	80c00117 	ldw	r3,4(r16)
  185cf0:	01ffff04 	movi	r7,-4
  185cf4:	018003c4 	movi	r6,15
  185cf8:	19c6703a 	and	r3,r3,r7
  185cfc:	1c45c83a 	sub	r2,r3,r17
  185d00:	30800716 	blt	r6,r2,185d20 <_malloc_r+0x16c>
  185d04:	1000610e 	bge	r2,zero,185e8c <_malloc_r+0x2d8>
  185d08:	84000317 	ldw	r16,12(r16)
  185d0c:	2c000526 	beq	r5,r16,185d24 <_malloc_r+0x170>
  185d10:	80c00117 	ldw	r3,4(r16)
  185d14:	19c6703a 	and	r3,r3,r7
  185d18:	1c45c83a 	sub	r2,r3,r17
  185d1c:	30bff90e 	bge	r6,r2,185d04 <_malloc_r+0x150>
  185d20:	213fffc4 	addi	r4,r4,-1
  185d24:	21000044 	addi	r4,r4,1
  185d28:	9c000417 	ldw	r16,16(r19)
  185d2c:	00c00674 	movhi	r3,25
  185d30:	18e97e04 	addi	r3,r3,-23048
  185d34:	1a400204 	addi	r9,r3,8
  185d38:	8240ff26 	beq	r16,r9,186138 <_malloc_r+0x584>
  185d3c:	81400117 	ldw	r5,4(r16)
  185d40:	00bfff04 	movi	r2,-4
  185d44:	018003c4 	movi	r6,15
  185d48:	2884703a 	and	r2,r5,r2
  185d4c:	144bc83a 	sub	r5,r2,r17
  185d50:	3140ea16 	blt	r6,r5,1860fc <_malloc_r+0x548>
  185d54:	1a400515 	stw	r9,20(r3)
  185d58:	1a400415 	stw	r9,16(r3)
  185d5c:	2800570e 	bge	r5,zero,185ebc <_malloc_r+0x308>
  185d60:	01407fc4 	movi	r5,511
  185d64:	2880ca36 	bltu	r5,r2,186090 <_malloc_r+0x4dc>
  185d68:	1004d0fa 	srli	r2,r2,3
  185d6c:	02000044 	movi	r8,1
  185d70:	19c00117 	ldw	r7,4(r3)
  185d74:	108b883a 	add	r5,r2,r2
  185d78:	294b883a 	add	r5,r5,r5
  185d7c:	1005d0ba 	srai	r2,r2,2
  185d80:	294b883a 	add	r5,r5,r5
  185d84:	28cb883a 	add	r5,r5,r3
  185d88:	29800217 	ldw	r6,8(r5)
  185d8c:	4084983a 	sll	r2,r8,r2
  185d90:	81400315 	stw	r5,12(r16)
  185d94:	81800215 	stw	r6,8(r16)
  185d98:	11c4b03a 	or	r2,r2,r7
  185d9c:	18800115 	stw	r2,4(r3)
  185da0:	2c000215 	stw	r16,8(r5)
  185da4:	34000315 	stw	r16,12(r6)
  185da8:	200bd0ba 	srai	r5,r4,2
  185dac:	00c00044 	movi	r3,1
  185db0:	194a983a 	sll	r5,r3,r5
  185db4:	11404936 	bltu	r2,r5,185edc <_malloc_r+0x328>
  185db8:	1146703a 	and	r3,r2,r5
  185dbc:	18000a1e 	bne	r3,zero,185de8 <_malloc_r+0x234>
  185dc0:	00ffff04 	movi	r3,-4
  185dc4:	294b883a 	add	r5,r5,r5
  185dc8:	20c8703a 	and	r4,r4,r3
  185dcc:	1146703a 	and	r3,r2,r5
  185dd0:	21000104 	addi	r4,r4,4
  185dd4:	1800041e 	bne	r3,zero,185de8 <_malloc_r+0x234>
  185dd8:	294b883a 	add	r5,r5,r5
  185ddc:	1146703a 	and	r3,r2,r5
  185de0:	21000104 	addi	r4,r4,4
  185de4:	183ffc26 	beq	r3,zero,185dd8 <_malloc_r+0x224>
  185de8:	023fff04 	movi	r8,-4
  185dec:	01c003c4 	movi	r7,15
  185df0:	2105883a 	add	r2,r4,r4
  185df4:	1085883a 	add	r2,r2,r2
  185df8:	1085883a 	add	r2,r2,r2
  185dfc:	9899883a 	add	r12,r19,r2
  185e00:	62800304 	addi	r10,r12,12
  185e04:	2017883a 	mov	r11,r4
  185e08:	54000017 	ldw	r16,0(r10)
  185e0c:	51bffd04 	addi	r6,r10,-12
  185e10:	8180041e 	bne	r16,r6,185e24 <_malloc_r+0x270>
  185e14:	0000ca06 	br	186140 <_malloc_r+0x58c>
  185e18:	10001c0e 	bge	r2,zero,185e8c <_malloc_r+0x2d8>
  185e1c:	84000317 	ldw	r16,12(r16)
  185e20:	8180c726 	beq	r16,r6,186140 <_malloc_r+0x58c>
  185e24:	80c00117 	ldw	r3,4(r16)
  185e28:	1a06703a 	and	r3,r3,r8
  185e2c:	1c45c83a 	sub	r2,r3,r17
  185e30:	38bff90e 	bge	r7,r2,185e18 <_malloc_r+0x264>
  185e34:	81000317 	ldw	r4,12(r16)
  185e38:	81400217 	ldw	r5,8(r16)
  185e3c:	8447883a 	add	r3,r16,r17
  185e40:	8c400054 	ori	r17,r17,1
  185e44:	29000315 	stw	r4,12(r5)
  185e48:	21400215 	stw	r5,8(r4)
  185e4c:	84400115 	stw	r17,4(r16)
  185e50:	1889883a 	add	r4,r3,r2
  185e54:	11400054 	ori	r5,r2,1
  185e58:	98c00515 	stw	r3,20(r19)
  185e5c:	98c00415 	stw	r3,16(r19)
  185e60:	20800015 	stw	r2,0(r4)
  185e64:	1a400315 	stw	r9,12(r3)
  185e68:	1a400215 	stw	r9,8(r3)
  185e6c:	19400115 	stw	r5,4(r3)
  185e70:	9009883a 	mov	r4,r18
  185e74:	0188b1c0 	call	188b1c <__malloc_unlock>
  185e78:	80800204 	addi	r2,r16,8
  185e7c:	003f7b06 	br	185c6c <_malloc_r+0xb8>
  185e80:	8808d0fa 	srli	r4,r17,3
  185e84:	210b883a 	add	r5,r4,r4
  185e88:	003f9106 	br	185cd0 <_malloc_r+0x11c>
  185e8c:	80c7883a 	add	r3,r16,r3
  185e90:	19400117 	ldw	r5,4(r3)
  185e94:	80800317 	ldw	r2,12(r16)
  185e98:	81000217 	ldw	r4,8(r16)
  185e9c:	29400054 	ori	r5,r5,1
  185ea0:	19400115 	stw	r5,4(r3)
  185ea4:	20800315 	stw	r2,12(r4)
  185ea8:	11000215 	stw	r4,8(r2)
  185eac:	9009883a 	mov	r4,r18
  185eb0:	0188b1c0 	call	188b1c <__malloc_unlock>
  185eb4:	80800204 	addi	r2,r16,8
  185eb8:	003f6c06 	br	185c6c <_malloc_r+0xb8>
  185ebc:	8085883a 	add	r2,r16,r2
  185ec0:	10c00117 	ldw	r3,4(r2)
  185ec4:	9009883a 	mov	r4,r18
  185ec8:	18c00054 	ori	r3,r3,1
  185ecc:	10c00115 	stw	r3,4(r2)
  185ed0:	0188b1c0 	call	188b1c <__malloc_unlock>
  185ed4:	80800204 	addi	r2,r16,8
  185ed8:	003f6406 	br	185c6c <_malloc_r+0xb8>
  185edc:	9c000217 	ldw	r16,8(r19)
  185ee0:	00bfff04 	movi	r2,-4
  185ee4:	85400117 	ldw	r21,4(r16)
  185ee8:	a8aa703a 	and	r21,r21,r2
  185eec:	ac400336 	bltu	r21,r17,185efc <_malloc_r+0x348>
  185ef0:	ac45c83a 	sub	r2,r21,r17
  185ef4:	00c003c4 	movi	r3,15
  185ef8:	18805316 	blt	r3,r2,186048 <_malloc_r+0x494>
  185efc:	d5e6dd17 	ldw	r23,-25740(gp)
  185f00:	d0e00b17 	ldw	r3,-32724(gp)
  185f04:	00bfffc4 	movi	r2,-1
  185f08:	8579883a 	add	fp,r16,r21
  185f0c:	8def883a 	add	r23,r17,r23
  185f10:	1880d226 	beq	r3,r2,18625c <_malloc_r+0x6a8>
  185f14:	bdc403c4 	addi	r23,r23,4111
  185f18:	00bc0004 	movi	r2,-4096
  185f1c:	b8ae703a 	and	r23,r23,r2
  185f20:	9009883a 	mov	r4,r18
  185f24:	b80b883a 	mov	r5,r23
  185f28:	0186f200 	call	186f20 <_sbrk_r>
  185f2c:	1029883a 	mov	r20,r2
  185f30:	00bfffc4 	movi	r2,-1
  185f34:	a080d126 	beq	r20,r2,18627c <_malloc_r+0x6c8>
  185f38:	a7009f36 	bltu	r20,fp,1861b8 <_malloc_r+0x604>
  185f3c:	05800674 	movhi	r22,25
  185f40:	b5b17904 	addi	r22,r22,-14876
  185f44:	b0800017 	ldw	r2,0(r22)
  185f48:	b885883a 	add	r2,r23,r2
  185f4c:	b0800015 	stw	r2,0(r22)
  185f50:	e500cf26 	beq	fp,r20,186290 <_malloc_r+0x6dc>
  185f54:	d1200b17 	ldw	r4,-32724(gp)
  185f58:	00ffffc4 	movi	r3,-1
  185f5c:	20c0e026 	beq	r4,r3,1862e0 <_malloc_r+0x72c>
  185f60:	a739c83a 	sub	fp,r20,fp
  185f64:	1705883a 	add	r2,r2,fp
  185f68:	b0800015 	stw	r2,0(r22)
  185f6c:	a08001cc 	andi	r2,r20,7
  185f70:	1000a526 	beq	r2,zero,186208 <_malloc_r+0x654>
  185f74:	a0a9c83a 	sub	r20,r20,r2
  185f78:	00c40204 	movi	r3,4104
  185f7c:	a5000204 	addi	r20,r20,8
  185f80:	1885c83a 	sub	r2,r3,r2
  185f84:	a5c7883a 	add	r3,r20,r23
  185f88:	18c3ffcc 	andi	r3,r3,4095
  185f8c:	10efc83a 	sub	r23,r2,r3
  185f90:	9009883a 	mov	r4,r18
  185f94:	b80b883a 	mov	r5,r23
  185f98:	0186f200 	call	186f20 <_sbrk_r>
  185f9c:	00ffffc4 	movi	r3,-1
  185fa0:	10c0cc26 	beq	r2,r3,1862d4 <_malloc_r+0x720>
  185fa4:	1505c83a 	sub	r2,r2,r20
  185fa8:	b887883a 	add	r3,r23,r2
  185fac:	18c00054 	ori	r3,r3,1
  185fb0:	b0800017 	ldw	r2,0(r22)
  185fb4:	9d000215 	stw	r20,8(r19)
  185fb8:	a0c00115 	stw	r3,4(r20)
  185fbc:	b885883a 	add	r2,r23,r2
  185fc0:	b0800015 	stw	r2,0(r22)
  185fc4:	84c00e26 	beq	r16,r19,186000 <_malloc_r+0x44c>
  185fc8:	00c003c4 	movi	r3,15
  185fcc:	1d40902e 	bgeu	r3,r21,186210 <_malloc_r+0x65c>
  185fd0:	ad7ffd04 	addi	r21,r21,-12
  185fd4:	013ffe04 	movi	r4,-8
  185fd8:	a908703a 	and	r4,r21,r4
  185fdc:	810b883a 	add	r5,r16,r4
  185fe0:	01800144 	movi	r6,5
  185fe4:	29800115 	stw	r6,4(r5)
  185fe8:	29800215 	stw	r6,8(r5)
  185fec:	81400117 	ldw	r5,4(r16)
  185ff0:	2940004c 	andi	r5,r5,1
  185ff4:	214ab03a 	or	r5,r4,r5
  185ff8:	81400115 	stw	r5,4(r16)
  185ffc:	1900ae36 	bltu	r3,r4,1862b8 <_malloc_r+0x704>
  186000:	d0e6dc17 	ldw	r3,-25744(gp)
  186004:	1880012e 	bgeu	r3,r2,18600c <_malloc_r+0x458>
  186008:	d0a6dc15 	stw	r2,-25744(gp)
  18600c:	d0e6db17 	ldw	r3,-25748(gp)
  186010:	9c000217 	ldw	r16,8(r19)
  186014:	1880012e 	bgeu	r3,r2,18601c <_malloc_r+0x468>
  186018:	d0a6db15 	stw	r2,-25748(gp)
  18601c:	80c00117 	ldw	r3,4(r16)
  186020:	00bfff04 	movi	r2,-4
  186024:	1886703a 	and	r3,r3,r2
  186028:	1c45c83a 	sub	r2,r3,r17
  18602c:	1c400236 	bltu	r3,r17,186038 <_malloc_r+0x484>
  186030:	00c003c4 	movi	r3,15
  186034:	18800416 	blt	r3,r2,186048 <_malloc_r+0x494>
  186038:	9009883a 	mov	r4,r18
  18603c:	0188b1c0 	call	188b1c <__malloc_unlock>
  186040:	0005883a 	mov	r2,zero
  186044:	003f0906 	br	185c6c <_malloc_r+0xb8>
  186048:	88c00054 	ori	r3,r17,1
  18604c:	10800054 	ori	r2,r2,1
  186050:	80c00115 	stw	r3,4(r16)
  186054:	8463883a 	add	r17,r16,r17
  186058:	88800115 	stw	r2,4(r17)
  18605c:	9009883a 	mov	r4,r18
  186060:	9c400215 	stw	r17,8(r19)
  186064:	0188b1c0 	call	188b1c <__malloc_unlock>
  186068:	80800204 	addi	r2,r16,8
  18606c:	003eff06 	br	185c6c <_malloc_r+0xb8>
  186070:	00800504 	movi	r2,20
  186074:	1100492e 	bgeu	r2,r4,18619c <_malloc_r+0x5e8>
  186078:	00801504 	movi	r2,84
  18607c:	11005c36 	bltu	r2,r4,1861f0 <_malloc_r+0x63c>
  186080:	8808d33a 	srli	r4,r17,12
  186084:	21001b84 	addi	r4,r4,110
  186088:	210b883a 	add	r5,r4,r4
  18608c:	003f1006 	br	185cd0 <_malloc_r+0x11c>
  186090:	1006d27a 	srli	r3,r2,9
  186094:	01400104 	movi	r5,4
  186098:	28c0432e 	bgeu	r5,r3,1861a8 <_malloc_r+0x5f4>
  18609c:	01400504 	movi	r5,20
  1860a0:	28c07036 	bltu	r5,r3,186264 <_malloc_r+0x6b0>
  1860a4:	194016c4 	addi	r5,r3,91
  1860a8:	294d883a 	add	r6,r5,r5
  1860ac:	318d883a 	add	r6,r6,r6
  1860b0:	318d883a 	add	r6,r6,r6
  1860b4:	998d883a 	add	r6,r19,r6
  1860b8:	30c00217 	ldw	r3,8(r6)
  1860bc:	01c00674 	movhi	r7,25
  1860c0:	39e97e04 	addi	r7,r7,-23048
  1860c4:	19805726 	beq	r3,r6,186224 <_malloc_r+0x670>
  1860c8:	01ffff04 	movi	r7,-4
  1860cc:	19400117 	ldw	r5,4(r3)
  1860d0:	29ca703a 	and	r5,r5,r7
  1860d4:	1140022e 	bgeu	r2,r5,1860e0 <_malloc_r+0x52c>
  1860d8:	18c00217 	ldw	r3,8(r3)
  1860dc:	30fffb1e 	bne	r6,r3,1860cc <_malloc_r+0x518>
  1860e0:	19400317 	ldw	r5,12(r3)
  1860e4:	98800117 	ldw	r2,4(r19)
  1860e8:	81400315 	stw	r5,12(r16)
  1860ec:	80c00215 	stw	r3,8(r16)
  1860f0:	2c000215 	stw	r16,8(r5)
  1860f4:	1c000315 	stw	r16,12(r3)
  1860f8:	003f2b06 	br	185da8 <_malloc_r+0x1f4>
  1860fc:	8445883a 	add	r2,r16,r17
  186100:	8c400054 	ori	r17,r17,1
  186104:	18800515 	stw	r2,20(r3)
  186108:	18800415 	stw	r2,16(r3)
  18610c:	29000054 	ori	r4,r5,1
  186110:	1147883a 	add	r3,r2,r5
  186114:	84400115 	stw	r17,4(r16)
  186118:	11000115 	stw	r4,4(r2)
  18611c:	12400315 	stw	r9,12(r2)
  186120:	12400215 	stw	r9,8(r2)
  186124:	19400015 	stw	r5,0(r3)
  186128:	9009883a 	mov	r4,r18
  18612c:	0188b1c0 	call	188b1c <__malloc_unlock>
  186130:	80800204 	addi	r2,r16,8
  186134:	003ecd06 	br	185c6c <_malloc_r+0xb8>
  186138:	18800117 	ldw	r2,4(r3)
  18613c:	003f1a06 	br	185da8 <_malloc_r+0x1f4>
  186140:	5ac00044 	addi	r11,r11,1
  186144:	588000cc 	andi	r2,r11,3
  186148:	52800204 	addi	r10,r10,8
  18614c:	103f2e1e 	bne	r2,zero,185e08 <_malloc_r+0x254>
  186150:	20c000cc 	andi	r3,r4,3
  186154:	60bffe04 	addi	r2,r12,-8
  186158:	18006f26 	beq	r3,zero,186318 <_malloc_r+0x764>
  18615c:	63000017 	ldw	r12,0(r12)
  186160:	213fffc4 	addi	r4,r4,-1
  186164:	60bffa26 	beq	r12,r2,186150 <_malloc_r+0x59c>
  186168:	98800117 	ldw	r2,4(r19)
  18616c:	294b883a 	add	r5,r5,r5
  186170:	117f5a36 	bltu	r2,r5,185edc <_malloc_r+0x328>
  186174:	283f5926 	beq	r5,zero,185edc <_malloc_r+0x328>
  186178:	1146703a 	and	r3,r2,r5
  18617c:	18001626 	beq	r3,zero,1861d8 <_malloc_r+0x624>
  186180:	5809883a 	mov	r4,r11
  186184:	003f1a06 	br	185df0 <_malloc_r+0x23c>
  186188:	80800204 	addi	r2,r16,8
  18618c:	84000517 	ldw	r16,20(r16)
  186190:	143ea81e 	bne	r2,r16,185c34 <_malloc_r+0x80>
  186194:	21000084 	addi	r4,r4,2
  186198:	003ee306 	br	185d28 <_malloc_r+0x174>
  18619c:	210016c4 	addi	r4,r4,91
  1861a0:	210b883a 	add	r5,r4,r4
  1861a4:	003eca06 	br	185cd0 <_malloc_r+0x11c>
  1861a8:	100ad1ba 	srli	r5,r2,6
  1861ac:	29400e04 	addi	r5,r5,56
  1861b0:	294d883a 	add	r6,r5,r5
  1861b4:	003fbd06 	br	1860ac <_malloc_r+0x4f8>
  1861b8:	84ff6026 	beq	r16,r19,185f3c <_malloc_r+0x388>
  1861bc:	00800674 	movhi	r2,25
  1861c0:	10a97e04 	addi	r2,r2,-23048
  1861c4:	14000217 	ldw	r16,8(r2)
  1861c8:	00bfff04 	movi	r2,-4
  1861cc:	80c00117 	ldw	r3,4(r16)
  1861d0:	1886703a 	and	r3,r3,r2
  1861d4:	003f9406 	br	186028 <_malloc_r+0x474>
  1861d8:	294b883a 	add	r5,r5,r5
  1861dc:	1146703a 	and	r3,r2,r5
  1861e0:	5ac00104 	addi	r11,r11,4
  1861e4:	183ffc26 	beq	r3,zero,1861d8 <_malloc_r+0x624>
  1861e8:	5809883a 	mov	r4,r11
  1861ec:	003f0006 	br	185df0 <_malloc_r+0x23c>
  1861f0:	00805504 	movi	r2,340
  1861f4:	11001336 	bltu	r2,r4,186244 <_malloc_r+0x690>
  1861f8:	8808d3fa 	srli	r4,r17,15
  1861fc:	21001dc4 	addi	r4,r4,119
  186200:	210b883a 	add	r5,r4,r4
  186204:	003eb206 	br	185cd0 <_malloc_r+0x11c>
  186208:	00840004 	movi	r2,4096
  18620c:	003f5d06 	br	185f84 <_malloc_r+0x3d0>
  186210:	00800044 	movi	r2,1
  186214:	a0800115 	stw	r2,4(r20)
  186218:	a021883a 	mov	r16,r20
  18621c:	0007883a 	mov	r3,zero
  186220:	003f8106 	br	186028 <_malloc_r+0x474>
  186224:	280bd0ba 	srai	r5,r5,2
  186228:	01800044 	movi	r6,1
  18622c:	38800117 	ldw	r2,4(r7)
  186230:	314c983a 	sll	r6,r6,r5
  186234:	180b883a 	mov	r5,r3
  186238:	3084b03a 	or	r2,r6,r2
  18623c:	38800115 	stw	r2,4(r7)
  186240:	003fa906 	br	1860e8 <_malloc_r+0x534>
  186244:	00815504 	movi	r2,1364
  186248:	11001836 	bltu	r2,r4,1862ac <_malloc_r+0x6f8>
  18624c:	8808d4ba 	srli	r4,r17,18
  186250:	21001f04 	addi	r4,r4,124
  186254:	210b883a 	add	r5,r4,r4
  186258:	003e9d06 	br	185cd0 <_malloc_r+0x11c>
  18625c:	bdc00404 	addi	r23,r23,16
  186260:	003f2f06 	br	185f20 <_malloc_r+0x36c>
  186264:	01401504 	movi	r5,84
  186268:	28c01f36 	bltu	r5,r3,1862e8 <_malloc_r+0x734>
  18626c:	100ad33a 	srli	r5,r2,12
  186270:	29401b84 	addi	r5,r5,110
  186274:	294d883a 	add	r6,r5,r5
  186278:	003f8c06 	br	1860ac <_malloc_r+0x4f8>
  18627c:	9c000217 	ldw	r16,8(r19)
  186280:	00bfff04 	movi	r2,-4
  186284:	80c00117 	ldw	r3,4(r16)
  186288:	1886703a 	and	r3,r3,r2
  18628c:	003f6606 	br	186028 <_malloc_r+0x474>
  186290:	e0c3ffcc 	andi	r3,fp,4095
  186294:	183f2f1e 	bne	r3,zero,185f54 <_malloc_r+0x3a0>
  186298:	98c00217 	ldw	r3,8(r19)
  18629c:	bd49883a 	add	r4,r23,r21
  1862a0:	21000054 	ori	r4,r4,1
  1862a4:	19000115 	stw	r4,4(r3)
  1862a8:	003f5506 	br	186000 <_malloc_r+0x44c>
  1862ac:	01403f04 	movi	r5,252
  1862b0:	01001f84 	movi	r4,126
  1862b4:	003e8606 	br	185cd0 <_malloc_r+0x11c>
  1862b8:	9009883a 	mov	r4,r18
  1862bc:	81400204 	addi	r5,r16,8
  1862c0:	0187bec0 	call	187bec <_free_r>
  1862c4:	00800674 	movhi	r2,25
  1862c8:	10b17904 	addi	r2,r2,-14876
  1862cc:	10800017 	ldw	r2,0(r2)
  1862d0:	003f4b06 	br	186000 <_malloc_r+0x44c>
  1862d4:	00c00044 	movi	r3,1
  1862d8:	002f883a 	mov	r23,zero
  1862dc:	003f3406 	br	185fb0 <_malloc_r+0x3fc>
  1862e0:	d5200b15 	stw	r20,-32724(gp)
  1862e4:	003f2106 	br	185f6c <_malloc_r+0x3b8>
  1862e8:	01405504 	movi	r5,340
  1862ec:	28c00436 	bltu	r5,r3,186300 <_malloc_r+0x74c>
  1862f0:	100ad3fa 	srli	r5,r2,15
  1862f4:	29401dc4 	addi	r5,r5,119
  1862f8:	294d883a 	add	r6,r5,r5
  1862fc:	003f6b06 	br	1860ac <_malloc_r+0x4f8>
  186300:	01415504 	movi	r5,1364
  186304:	28c00936 	bltu	r5,r3,18632c <_malloc_r+0x778>
  186308:	100ad4ba 	srli	r5,r2,18
  18630c:	29401f04 	addi	r5,r5,124
  186310:	294d883a 	add	r6,r5,r5
  186314:	003f6506 	br	1860ac <_malloc_r+0x4f8>
  186318:	98800117 	ldw	r2,4(r19)
  18631c:	0146303a 	nor	r3,zero,r5
  186320:	1884703a 	and	r2,r3,r2
  186324:	98800115 	stw	r2,4(r19)
  186328:	003f9006 	br	18616c <_malloc_r+0x5b8>
  18632c:	01803f04 	movi	r6,252
  186330:	01401f84 	movi	r5,126
  186334:	003f5d06 	br	1860ac <_malloc_r+0x4f8>

00186338 <memchr>:
  186338:	008000c4 	movi	r2,3
  18633c:	29403fcc 	andi	r5,r5,255
  186340:	1180282e 	bgeu	r2,r6,1863e4 <memchr+0xac>
  186344:	2086703a 	and	r3,r4,r2
  186348:	1800351e 	bne	r3,zero,186420 <memchr+0xe8>
  18634c:	2816923a 	slli	r11,r5,8
  186350:	2093883a 	add	r9,r4,r2
  186354:	22000084 	addi	r8,r4,2
  186358:	5957883a 	add	r11,r11,r5
  18635c:	5816923a 	slli	r11,r11,8
  186360:	20c00044 	addi	r3,r4,1
  186364:	037fbff4 	movhi	r13,65279
  186368:	6b7fbfc4 	addi	r13,r13,-257
  18636c:	5957883a 	add	r11,r11,r5
  186370:	5816923a 	slli	r11,r11,8
  186374:	03202074 	movhi	r12,32897
  186378:	63202004 	addi	r12,r12,-32640
  18637c:	101d883a 	mov	r14,r2
  186380:	5957883a 	add	r11,r11,r5
  186384:	21c00017 	ldw	r7,0(r4)
  186388:	31bfff04 	addi	r6,r6,-4
  18638c:	1805883a 	mov	r2,r3
  186390:	3acef03a 	xor	r7,r7,r11
  186394:	3b55883a 	add	r10,r7,r13
  186398:	01ce303a 	nor	r7,zero,r7
  18639c:	51ce703a 	and	r7,r10,r7
  1863a0:	3b0e703a 	and	r7,r7,r12
  1863a4:	38000a26 	beq	r7,zero,1863d0 <memchr+0x98>
  1863a8:	21c00003 	ldbu	r7,0(r4)
  1863ac:	39401e26 	beq	r7,r5,186428 <memchr+0xf0>
  1863b0:	19c00003 	ldbu	r7,0(r3)
  1863b4:	39401926 	beq	r7,r5,18641c <memchr+0xe4>
  1863b8:	41c00003 	ldbu	r7,0(r8)
  1863bc:	4005883a 	mov	r2,r8
  1863c0:	39401626 	beq	r7,r5,18641c <memchr+0xe4>
  1863c4:	49c00003 	ldbu	r7,0(r9)
  1863c8:	4805883a 	mov	r2,r9
  1863cc:	39401326 	beq	r7,r5,18641c <memchr+0xe4>
  1863d0:	21000104 	addi	r4,r4,4
  1863d4:	4a400104 	addi	r9,r9,4
  1863d8:	42000104 	addi	r8,r8,4
  1863dc:	18c00104 	addi	r3,r3,4
  1863e0:	71bfe836 	bltu	r14,r6,186384 <memchr+0x4c>
  1863e4:	2005883a 	mov	r2,r4
  1863e8:	30000a26 	beq	r6,zero,186414 <memchr+0xdc>
  1863ec:	10c00003 	ldbu	r3,0(r2)
  1863f0:	19400a26 	beq	r3,r5,18641c <memchr+0xe4>
  1863f4:	10c00044 	addi	r3,r2,1
  1863f8:	118d883a 	add	r6,r2,r6
  1863fc:	00000306 	br	18640c <memchr+0xd4>
  186400:	11000003 	ldbu	r4,0(r2)
  186404:	18c00044 	addi	r3,r3,1
  186408:	21400426 	beq	r4,r5,18641c <memchr+0xe4>
  18640c:	1805883a 	mov	r2,r3
  186410:	19bffb1e 	bne	r3,r6,186400 <memchr+0xc8>
  186414:	0005883a 	mov	r2,zero
  186418:	f800283a 	ret
  18641c:	f800283a 	ret
  186420:	2005883a 	mov	r2,r4
  186424:	003ff106 	br	1863ec <memchr+0xb4>
  186428:	2005883a 	mov	r2,r4
  18642c:	f800283a 	ret

00186430 <memcmp>:
  186430:	01c000c4 	movi	r7,3
  186434:	3980192e 	bgeu	r7,r6,18649c <memcmp+0x6c>
  186438:	2904b03a 	or	r2,r5,r4
  18643c:	11c4703a 	and	r2,r2,r7
  186440:	10000f26 	beq	r2,zero,186480 <memcmp+0x50>
  186444:	20c00003 	ldbu	r3,0(r4)
  186448:	28800003 	ldbu	r2,0(r5)
  18644c:	1880151e 	bne	r3,r2,1864a4 <memcmp+0x74>
  186450:	31bfff84 	addi	r6,r6,-2
  186454:	01ffffc4 	movi	r7,-1
  186458:	00000406 	br	18646c <memcmp+0x3c>
  18645c:	20c00003 	ldbu	r3,0(r4)
  186460:	28800003 	ldbu	r2,0(r5)
  186464:	31bfffc4 	addi	r6,r6,-1
  186468:	18800e1e 	bne	r3,r2,1864a4 <memcmp+0x74>
  18646c:	21000044 	addi	r4,r4,1
  186470:	29400044 	addi	r5,r5,1
  186474:	31fff91e 	bne	r6,r7,18645c <memcmp+0x2c>
  186478:	0005883a 	mov	r2,zero
  18647c:	f800283a 	ret
  186480:	20c00017 	ldw	r3,0(r4)
  186484:	28800017 	ldw	r2,0(r5)
  186488:	1880041e 	bne	r3,r2,18649c <memcmp+0x6c>
  18648c:	31bfff04 	addi	r6,r6,-4
  186490:	21000104 	addi	r4,r4,4
  186494:	29400104 	addi	r5,r5,4
  186498:	39bff936 	bltu	r7,r6,186480 <memcmp+0x50>
  18649c:	303fe91e 	bne	r6,zero,186444 <memcmp+0x14>
  1864a0:	003ff506 	br	186478 <memcmp+0x48>
  1864a4:	1885c83a 	sub	r2,r3,r2
  1864a8:	f800283a 	ret

001864ac <memcpy>:
  1864ac:	defffb04 	addi	sp,sp,-20
  1864b0:	dc000015 	stw	r16,0(sp)
  1864b4:	dfc00415 	stw	ra,16(sp)
  1864b8:	dcc00315 	stw	r19,12(sp)
  1864bc:	dc800215 	stw	r18,8(sp)
  1864c0:	dc400115 	stw	r17,4(sp)
  1864c4:	00c003c4 	movi	r3,15
  1864c8:	2021883a 	mov	r16,r4
  1864cc:	3005883a 	mov	r2,r6
  1864d0:	1980032e 	bgeu	r3,r6,1864e0 <memcpy+0x34>
  1864d4:	2906b03a 	or	r3,r5,r4
  1864d8:	18c000cc 	andi	r3,r3,3
  1864dc:	18001026 	beq	r3,zero,186520 <memcpy+0x74>
  1864e0:	8007883a 	mov	r3,r16
  1864e4:	288f883a 	add	r7,r5,r2
  1864e8:	10000526 	beq	r2,zero,186500 <memcpy+0x54>
  1864ec:	29800003 	ldbu	r6,0(r5)
  1864f0:	18c00044 	addi	r3,r3,1
  1864f4:	29400044 	addi	r5,r5,1
  1864f8:	19bfffc5 	stb	r6,-1(r3)
  1864fc:	29fffb1e 	bne	r5,r7,1864ec <memcpy+0x40>
  186500:	8005883a 	mov	r2,r16
  186504:	dfc00417 	ldw	ra,16(sp)
  186508:	dcc00317 	ldw	r19,12(sp)
  18650c:	dc800217 	ldw	r18,8(sp)
  186510:	dc400117 	ldw	r17,4(sp)
  186514:	dc000017 	ldw	r16,0(sp)
  186518:	dec00504 	addi	sp,sp,20
  18651c:	f800283a 	ret
  186520:	32bffc04 	addi	r10,r6,-16
  186524:	5014d13a 	srli	r10,r10,4
  186528:	20800404 	addi	r2,r4,16
  18652c:	2007883a 	mov	r3,r4
  186530:	5008913a 	slli	r4,r10,4
  186534:	280f883a 	mov	r7,r5
  186538:	1105883a 	add	r2,r2,r4
  18653c:	3a000017 	ldw	r8,0(r7)
  186540:	18c00404 	addi	r3,r3,16
  186544:	39c00404 	addi	r7,r7,16
  186548:	1a3ffc15 	stw	r8,-16(r3)
  18654c:	3a3ffd17 	ldw	r8,-12(r7)
  186550:	1a3ffd15 	stw	r8,-12(r3)
  186554:	3a3ffe17 	ldw	r8,-8(r7)
  186558:	1a3ffe15 	stw	r8,-8(r3)
  18655c:	3a3fff17 	ldw	r8,-4(r7)
  186560:	1a3fff15 	stw	r8,-4(r3)
  186564:	18bff51e 	bne	r3,r2,18653c <memcpy+0x90>
  186568:	52800044 	addi	r10,r10,1
  18656c:	5014913a 	slli	r10,r10,4
  186570:	308003cc 	andi	r2,r6,15
  186574:	010000c4 	movi	r4,3
  186578:	8287883a 	add	r3,r16,r10
  18657c:	2a95883a 	add	r10,r5,r10
  186580:	2080182e 	bgeu	r4,r2,1865e4 <memcpy+0x138>
  186584:	147fff04 	addi	r17,r2,-4
  186588:	8808d0ba 	srli	r4,r17,2
  18658c:	1a400104 	addi	r9,r3,4
  186590:	180d883a 	mov	r6,r3
  186594:	2105883a 	add	r2,r4,r4
  186598:	1085883a 	add	r2,r2,r2
  18659c:	4893883a 	add	r9,r9,r2
  1865a0:	500f883a 	mov	r7,r10
  1865a4:	3a000017 	ldw	r8,0(r7)
  1865a8:	31800104 	addi	r6,r6,4
  1865ac:	39c00104 	addi	r7,r7,4
  1865b0:	323fff15 	stw	r8,-4(r6)
  1865b4:	327ffb1e 	bne	r6,r9,1865a4 <memcpy+0xf8>
  1865b8:	20800044 	addi	r2,r4,1
  1865bc:	1085883a 	add	r2,r2,r2
  1865c0:	1085883a 	add	r2,r2,r2
  1865c4:	017fff04 	movi	r5,-4
  1865c8:	18a5883a 	add	r18,r3,r2
  1865cc:	50a7883a 	add	r19,r10,r2
  1865d0:	01805f00 	call	1805f0 <__mulsi3>
  1865d4:	1445883a 	add	r2,r2,r17
  1865d8:	980b883a 	mov	r5,r19
  1865dc:	9007883a 	mov	r3,r18
  1865e0:	003fc006 	br	1864e4 <memcpy+0x38>
  1865e4:	500b883a 	mov	r5,r10
  1865e8:	003fbe06 	br	1864e4 <memcpy+0x38>

001865ec <memmove>:
  1865ec:	defffb04 	addi	sp,sp,-20
  1865f0:	dc000015 	stw	r16,0(sp)
  1865f4:	dfc00415 	stw	ra,16(sp)
  1865f8:	dcc00315 	stw	r19,12(sp)
  1865fc:	dc800215 	stw	r18,8(sp)
  186600:	dc400115 	stw	r17,4(sp)
  186604:	2021883a 	mov	r16,r4
  186608:	300f883a 	mov	r7,r6
  18660c:	2900122e 	bgeu	r5,r4,186658 <memmove+0x6c>
  186610:	2987883a 	add	r3,r5,r6
  186614:	20c0102e 	bgeu	r4,r3,186658 <memmove+0x6c>
  186618:	218b883a 	add	r5,r4,r6
  18661c:	1989c83a 	sub	r4,r3,r6
  186620:	30000526 	beq	r6,zero,186638 <memmove+0x4c>
  186624:	18ffffc4 	addi	r3,r3,-1
  186628:	18800003 	ldbu	r2,0(r3)
  18662c:	297fffc4 	addi	r5,r5,-1
  186630:	28800005 	stb	r2,0(r5)
  186634:	193ffb1e 	bne	r3,r4,186624 <memmove+0x38>
  186638:	8005883a 	mov	r2,r16
  18663c:	dfc00417 	ldw	ra,16(sp)
  186640:	dcc00317 	ldw	r19,12(sp)
  186644:	dc800217 	ldw	r18,8(sp)
  186648:	dc400117 	ldw	r17,4(sp)
  18664c:	dc000017 	ldw	r16,0(sp)
  186650:	dec00504 	addi	sp,sp,20
  186654:	f800283a 	ret
  186658:	008003c4 	movi	r2,15
  18665c:	1180422e 	bgeu	r2,r6,186768 <memmove+0x17c>
  186660:	2c04b03a 	or	r2,r5,r16
  186664:	108000cc 	andi	r2,r2,3
  186668:	10003f1e 	bne	r2,zero,186768 <memmove+0x17c>
  18666c:	32bffc04 	addi	r10,r6,-16
  186670:	5014d13a 	srli	r10,r10,4
  186674:	81000404 	addi	r4,r16,16
  186678:	8007883a 	mov	r3,r16
  18667c:	5004913a 	slli	r2,r10,4
  186680:	280f883a 	mov	r7,r5
  186684:	2089883a 	add	r4,r4,r2
  186688:	38800017 	ldw	r2,0(r7)
  18668c:	18c00404 	addi	r3,r3,16
  186690:	39c00404 	addi	r7,r7,16
  186694:	18bffc15 	stw	r2,-16(r3)
  186698:	38bffd17 	ldw	r2,-12(r7)
  18669c:	18bffd15 	stw	r2,-12(r3)
  1866a0:	38bffe17 	ldw	r2,-8(r7)
  1866a4:	18bffe15 	stw	r2,-8(r3)
  1866a8:	38bfff17 	ldw	r2,-4(r7)
  1866ac:	18bfff15 	stw	r2,-4(r3)
  1866b0:	193ff51e 	bne	r3,r4,186688 <memmove+0x9c>
  1866b4:	52800044 	addi	r10,r10,1
  1866b8:	5014913a 	slli	r10,r10,4
  1866bc:	31c003cc 	andi	r7,r6,15
  1866c0:	008000c4 	movi	r2,3
  1866c4:	8287883a 	add	r3,r16,r10
  1866c8:	2a95883a 	add	r10,r5,r10
  1866cc:	11c0282e 	bgeu	r2,r7,186770 <memmove+0x184>
  1866d0:	3c7fff04 	addi	r17,r7,-4
  1866d4:	8808d0ba 	srli	r4,r17,2
  1866d8:	1a400104 	addi	r9,r3,4
  1866dc:	180d883a 	mov	r6,r3
  1866e0:	2105883a 	add	r2,r4,r4
  1866e4:	1085883a 	add	r2,r2,r2
  1866e8:	4893883a 	add	r9,r9,r2
  1866ec:	5005883a 	mov	r2,r10
  1866f0:	12000017 	ldw	r8,0(r2)
  1866f4:	31800104 	addi	r6,r6,4
  1866f8:	10800104 	addi	r2,r2,4
  1866fc:	323fff15 	stw	r8,-4(r6)
  186700:	327ffb1e 	bne	r6,r9,1866f0 <memmove+0x104>
  186704:	20800044 	addi	r2,r4,1
  186708:	1085883a 	add	r2,r2,r2
  18670c:	1085883a 	add	r2,r2,r2
  186710:	017fff04 	movi	r5,-4
  186714:	18a5883a 	add	r18,r3,r2
  186718:	50a7883a 	add	r19,r10,r2
  18671c:	01805f00 	call	1805f0 <__mulsi3>
  186720:	144f883a 	add	r7,r2,r17
  186724:	980b883a 	mov	r5,r19
  186728:	9007883a 	mov	r3,r18
  18672c:	383fc226 	beq	r7,zero,186638 <memmove+0x4c>
  186730:	19cf883a 	add	r7,r3,r7
  186734:	29800003 	ldbu	r6,0(r5)
  186738:	18c00044 	addi	r3,r3,1
  18673c:	29400044 	addi	r5,r5,1
  186740:	19bfffc5 	stb	r6,-1(r3)
  186744:	19fffb1e 	bne	r3,r7,186734 <memmove+0x148>
  186748:	8005883a 	mov	r2,r16
  18674c:	dfc00417 	ldw	ra,16(sp)
  186750:	dcc00317 	ldw	r19,12(sp)
  186754:	dc800217 	ldw	r18,8(sp)
  186758:	dc400117 	ldw	r17,4(sp)
  18675c:	dc000017 	ldw	r16,0(sp)
  186760:	dec00504 	addi	sp,sp,20
  186764:	f800283a 	ret
  186768:	8007883a 	mov	r3,r16
  18676c:	003fef06 	br	18672c <memmove+0x140>
  186770:	500b883a 	mov	r5,r10
  186774:	003fed06 	br	18672c <memmove+0x140>

00186778 <_putc_r>:
  186778:	defffc04 	addi	sp,sp,-16
  18677c:	dc000215 	stw	r16,8(sp)
  186780:	dfc00315 	stw	ra,12(sp)
  186784:	2021883a 	mov	r16,r4
  186788:	20000226 	beq	r4,zero,186794 <_putc_r+0x1c>
  18678c:	20800e17 	ldw	r2,56(r4)
  186790:	10001d26 	beq	r2,zero,186808 <_putc_r+0x90>
  186794:	30800217 	ldw	r2,8(r6)
  186798:	10bfffc4 	addi	r2,r2,-1
  18679c:	30800215 	stw	r2,8(r6)
  1867a0:	10000a16 	blt	r2,zero,1867cc <_putc_r+0x54>
  1867a4:	30800017 	ldw	r2,0(r6)
  1867a8:	11400005 	stb	r5,0(r2)
  1867ac:	30800017 	ldw	r2,0(r6)
  1867b0:	10c00044 	addi	r3,r2,1
  1867b4:	10800003 	ldbu	r2,0(r2)
  1867b8:	30c00015 	stw	r3,0(r6)
  1867bc:	dfc00317 	ldw	ra,12(sp)
  1867c0:	dc000217 	ldw	r16,8(sp)
  1867c4:	dec00404 	addi	sp,sp,16
  1867c8:	f800283a 	ret
  1867cc:	30c00617 	ldw	r3,24(r6)
  1867d0:	10c01316 	blt	r2,r3,186820 <_putc_r+0xa8>
  1867d4:	30800017 	ldw	r2,0(r6)
  1867d8:	01000284 	movi	r4,10
  1867dc:	11400005 	stb	r5,0(r2)
  1867e0:	30c00017 	ldw	r3,0(r6)
  1867e4:	19400003 	ldbu	r5,0(r3)
  1867e8:	29000d26 	beq	r5,r4,186820 <_putc_r+0xa8>
  1867ec:	18c00044 	addi	r3,r3,1
  1867f0:	2805883a 	mov	r2,r5
  1867f4:	30c00015 	stw	r3,0(r6)
  1867f8:	dfc00317 	ldw	ra,12(sp)
  1867fc:	dc000217 	ldw	r16,8(sp)
  186800:	dec00404 	addi	sp,sp,16
  186804:	f800283a 	ret
  186808:	d9400015 	stw	r5,0(sp)
  18680c:	d9800115 	stw	r6,4(sp)
  186810:	01878680 	call	187868 <__sinit>
  186814:	d9800117 	ldw	r6,4(sp)
  186818:	d9400017 	ldw	r5,0(sp)
  18681c:	003fdd06 	br	186794 <_putc_r+0x1c>
  186820:	8009883a 	mov	r4,r16
  186824:	dfc00317 	ldw	ra,12(sp)
  186828:	dc000217 	ldw	r16,8(sp)
  18682c:	dec00404 	addi	sp,sp,16
  186830:	01870101 	jmpi	187010 <__swbuf_r>

00186834 <putc>:
  186834:	defffc04 	addi	sp,sp,-16
  186838:	dc400115 	stw	r17,4(sp)
  18683c:	04400674 	movhi	r17,25
  186840:	8c6a8a04 	addi	r17,r17,-21976
  186844:	88800017 	ldw	r2,0(r17)
  186848:	dc800215 	stw	r18,8(sp)
  18684c:	dc000015 	stw	r16,0(sp)
  186850:	dfc00315 	stw	ra,12(sp)
  186854:	2025883a 	mov	r18,r4
  186858:	2821883a 	mov	r16,r5
  18685c:	10000226 	beq	r2,zero,186868 <putc+0x34>
  186860:	10c00e17 	ldw	r3,56(r2)
  186864:	18002126 	beq	r3,zero,1868ec <putc+0xb8>
  186868:	80800217 	ldw	r2,8(r16)
  18686c:	10bfffc4 	addi	r2,r2,-1
  186870:	80800215 	stw	r2,8(r16)
  186874:	10000c16 	blt	r2,zero,1868a8 <putc+0x74>
  186878:	80800017 	ldw	r2,0(r16)
  18687c:	14800005 	stb	r18,0(r2)
  186880:	80800017 	ldw	r2,0(r16)
  186884:	10c00044 	addi	r3,r2,1
  186888:	10800003 	ldbu	r2,0(r2)
  18688c:	80c00015 	stw	r3,0(r16)
  186890:	dfc00317 	ldw	ra,12(sp)
  186894:	dc800217 	ldw	r18,8(sp)
  186898:	dc400117 	ldw	r17,4(sp)
  18689c:	dc000017 	ldw	r16,0(sp)
  1868a0:	dec00404 	addi	sp,sp,16
  1868a4:	f800283a 	ret
  1868a8:	80c00617 	ldw	r3,24(r16)
  1868ac:	10c01216 	blt	r2,r3,1868f8 <putc+0xc4>
  1868b0:	80800017 	ldw	r2,0(r16)
  1868b4:	01000284 	movi	r4,10
  1868b8:	14800005 	stb	r18,0(r2)
  1868bc:	80c00017 	ldw	r3,0(r16)
  1868c0:	19400003 	ldbu	r5,0(r3)
  1868c4:	29001526 	beq	r5,r4,18691c <putc+0xe8>
  1868c8:	18c00044 	addi	r3,r3,1
  1868cc:	2805883a 	mov	r2,r5
  1868d0:	80c00015 	stw	r3,0(r16)
  1868d4:	dfc00317 	ldw	ra,12(sp)
  1868d8:	dc800217 	ldw	r18,8(sp)
  1868dc:	dc400117 	ldw	r17,4(sp)
  1868e0:	dc000017 	ldw	r16,0(sp)
  1868e4:	dec00404 	addi	sp,sp,16
  1868e8:	f800283a 	ret
  1868ec:	1009883a 	mov	r4,r2
  1868f0:	01878680 	call	187868 <__sinit>
  1868f4:	003fdc06 	br	186868 <putc+0x34>
  1868f8:	89000017 	ldw	r4,0(r17)
  1868fc:	900b883a 	mov	r5,r18
  186900:	800d883a 	mov	r6,r16
  186904:	dfc00317 	ldw	ra,12(sp)
  186908:	dc800217 	ldw	r18,8(sp)
  18690c:	dc400117 	ldw	r17,4(sp)
  186910:	dc000017 	ldw	r16,0(sp)
  186914:	dec00404 	addi	sp,sp,16
  186918:	01870101 	jmpi	187010 <__swbuf_r>
  18691c:	89000017 	ldw	r4,0(r17)
  186920:	003ff706 	br	186900 <putc+0xcc>

00186924 <_realloc_r>:
  186924:	defff504 	addi	sp,sp,-44
  186928:	dd400615 	stw	r21,24(sp)
  18692c:	dc800315 	stw	r18,12(sp)
  186930:	dc000115 	stw	r16,4(sp)
  186934:	dfc00a15 	stw	ra,40(sp)
  186938:	df000915 	stw	fp,36(sp)
  18693c:	ddc00815 	stw	r23,32(sp)
  186940:	dd800715 	stw	r22,28(sp)
  186944:	dd000515 	stw	r20,20(sp)
  186948:	dcc00415 	stw	r19,16(sp)
  18694c:	dc400215 	stw	r17,8(sp)
  186950:	2821883a 	mov	r16,r5
  186954:	202b883a 	mov	r21,r4
  186958:	3025883a 	mov	r18,r6
  18695c:	28009626 	beq	r5,zero,186bb8 <_realloc_r+0x294>
  186960:	0188afc0 	call	188afc <__malloc_lock>
  186964:	80bfff17 	ldw	r2,-4(r16)
  186968:	04ffff04 	movi	r19,-4
  18696c:	90c002c4 	addi	r3,r18,11
  186970:	01000584 	movi	r4,22
  186974:	85bffe04 	addi	r22,r16,-8
  186978:	14e6703a 	and	r19,r2,r19
  18697c:	20c0372e 	bgeu	r4,r3,186a5c <_realloc_r+0x138>
  186980:	047ffe04 	movi	r17,-8
  186984:	1c62703a 	and	r17,r3,r17
  186988:	8807883a 	mov	r3,r17
  18698c:	88005a16 	blt	r17,zero,186af8 <_realloc_r+0x1d4>
  186990:	8c805936 	bltu	r17,r18,186af8 <_realloc_r+0x1d4>
  186994:	98c0340e 	bge	r19,r3,186a68 <_realloc_r+0x144>
  186998:	07000674 	movhi	fp,25
  18699c:	e7297e04 	addi	fp,fp,-23048
  1869a0:	e1400217 	ldw	r5,8(fp)
  1869a4:	b4c9883a 	add	r4,r22,r19
  1869a8:	29009026 	beq	r5,r4,186bec <_realloc_r+0x2c8>
  1869ac:	21800117 	ldw	r6,4(r4)
  1869b0:	01ffff84 	movi	r7,-2
  1869b4:	31ce703a 	and	r7,r6,r7
  1869b8:	21cf883a 	add	r7,r4,r7
  1869bc:	39c00117 	ldw	r7,4(r7)
  1869c0:	39c0004c 	andi	r7,r7,1
  1869c4:	38004326 	beq	r7,zero,186ad4 <_realloc_r+0x1b0>
  1869c8:	000d883a 	mov	r6,zero
  1869cc:	0009883a 	mov	r4,zero
  1869d0:	1080004c 	andi	r2,r2,1
  1869d4:	10005a1e 	bne	r2,zero,186b40 <_realloc_r+0x21c>
  1869d8:	85fffe17 	ldw	r23,-8(r16)
  1869dc:	00bfff04 	movi	r2,-4
  1869e0:	b5efc83a 	sub	r23,r22,r23
  1869e4:	b9c00117 	ldw	r7,4(r23)
  1869e8:	388e703a 	and	r7,r7,r2
  1869ec:	3ccf883a 	add	r7,r7,r19
  1869f0:	20005226 	beq	r4,zero,186b3c <_realloc_r+0x218>
  1869f4:	31e9883a 	add	r20,r6,r7
  1869f8:	2140c726 	beq	r4,r5,186d18 <_realloc_r+0x3f4>
  1869fc:	a0c04f16 	blt	r20,r3,186b3c <_realloc_r+0x218>
  186a00:	20800317 	ldw	r2,12(r4)
  186a04:	20c00217 	ldw	r3,8(r4)
  186a08:	99bfff04 	addi	r6,r19,-4
  186a0c:	01000904 	movi	r4,36
  186a10:	18800315 	stw	r2,12(r3)
  186a14:	10c00215 	stw	r3,8(r2)
  186a18:	b8c00217 	ldw	r3,8(r23)
  186a1c:	b8800317 	ldw	r2,12(r23)
  186a20:	bc800204 	addi	r18,r23,8
  186a24:	18800315 	stw	r2,12(r3)
  186a28:	10c00215 	stw	r3,8(r2)
  186a2c:	2180ed36 	bltu	r4,r6,186de4 <_realloc_r+0x4c0>
  186a30:	008004c4 	movi	r2,19
  186a34:	11809b2e 	bgeu	r2,r6,186ca4 <_realloc_r+0x380>
  186a38:	80800017 	ldw	r2,0(r16)
  186a3c:	b8800215 	stw	r2,8(r23)
  186a40:	80800117 	ldw	r2,4(r16)
  186a44:	b8800315 	stw	r2,12(r23)
  186a48:	008006c4 	movi	r2,27
  186a4c:	1180f936 	bltu	r2,r6,186e34 <_realloc_r+0x510>
  186a50:	b8800404 	addi	r2,r23,16
  186a54:	80c00204 	addi	r3,r16,8
  186a58:	00009406 	br	186cac <_realloc_r+0x388>
  186a5c:	00c00404 	movi	r3,16
  186a60:	1823883a 	mov	r17,r3
  186a64:	003fca06 	br	186990 <_realloc_r+0x6c>
  186a68:	9829883a 	mov	r20,r19
  186a6c:	a447c83a 	sub	r3,r20,r17
  186a70:	010003c4 	movi	r4,15
  186a74:	1080004c 	andi	r2,r2,1
  186a78:	20c02336 	bltu	r4,r3,186b08 <_realloc_r+0x1e4>
  186a7c:	1504b03a 	or	r2,r2,r20
  186a80:	b0800115 	stw	r2,4(r22)
  186a84:	b52d883a 	add	r22,r22,r20
  186a88:	b0800117 	ldw	r2,4(r22)
  186a8c:	10800054 	ori	r2,r2,1
  186a90:	b0800115 	stw	r2,4(r22)
  186a94:	a809883a 	mov	r4,r21
  186a98:	0188b1c0 	call	188b1c <__malloc_unlock>
  186a9c:	8025883a 	mov	r18,r16
  186aa0:	9005883a 	mov	r2,r18
  186aa4:	dfc00a17 	ldw	ra,40(sp)
  186aa8:	df000917 	ldw	fp,36(sp)
  186aac:	ddc00817 	ldw	r23,32(sp)
  186ab0:	dd800717 	ldw	r22,28(sp)
  186ab4:	dd400617 	ldw	r21,24(sp)
  186ab8:	dd000517 	ldw	r20,20(sp)
  186abc:	dcc00417 	ldw	r19,16(sp)
  186ac0:	dc800317 	ldw	r18,12(sp)
  186ac4:	dc400217 	ldw	r17,8(sp)
  186ac8:	dc000117 	ldw	r16,4(sp)
  186acc:	dec00b04 	addi	sp,sp,44
  186ad0:	f800283a 	ret
  186ad4:	01ffff04 	movi	r7,-4
  186ad8:	31cc703a 	and	r6,r6,r7
  186adc:	34e9883a 	add	r20,r6,r19
  186ae0:	a0ffbb16 	blt	r20,r3,1869d0 <_realloc_r+0xac>
  186ae4:	20c00317 	ldw	r3,12(r4)
  186ae8:	21000217 	ldw	r4,8(r4)
  186aec:	20c00315 	stw	r3,12(r4)
  186af0:	19000215 	stw	r4,8(r3)
  186af4:	003fdd06 	br	186a6c <_realloc_r+0x148>
  186af8:	00800304 	movi	r2,12
  186afc:	a8800015 	stw	r2,0(r21)
  186b00:	0025883a 	mov	r18,zero
  186b04:	003fe606 	br	186aa0 <_realloc_r+0x17c>
  186b08:	1444b03a 	or	r2,r2,r17
  186b0c:	b0800115 	stw	r2,4(r22)
  186b10:	b44b883a 	add	r5,r22,r17
  186b14:	18800054 	ori	r2,r3,1
  186b18:	28800115 	stw	r2,4(r5)
  186b1c:	28c7883a 	add	r3,r5,r3
  186b20:	18800117 	ldw	r2,4(r3)
  186b24:	a809883a 	mov	r4,r21
  186b28:	29400204 	addi	r5,r5,8
  186b2c:	10800054 	ori	r2,r2,1
  186b30:	18800115 	stw	r2,4(r3)
  186b34:	0187bec0 	call	187bec <_free_r>
  186b38:	003fd606 	br	186a94 <_realloc_r+0x170>
  186b3c:	38c0330e 	bge	r7,r3,186c0c <_realloc_r+0x2e8>
  186b40:	900b883a 	mov	r5,r18
  186b44:	a809883a 	mov	r4,r21
  186b48:	0185bb40 	call	185bb4 <_malloc_r>
  186b4c:	1025883a 	mov	r18,r2
  186b50:	10001626 	beq	r2,zero,186bac <_realloc_r+0x288>
  186b54:	80bfff17 	ldw	r2,-4(r16)
  186b58:	00ffff84 	movi	r3,-2
  186b5c:	913ffe04 	addi	r4,r18,-8
  186b60:	10c6703a 	and	r3,r2,r3
  186b64:	b0c7883a 	add	r3,r22,r3
  186b68:	20c09926 	beq	r4,r3,186dd0 <_realloc_r+0x4ac>
  186b6c:	99bfff04 	addi	r6,r19,-4
  186b70:	00800904 	movi	r2,36
  186b74:	11806436 	bltu	r2,r6,186d08 <_realloc_r+0x3e4>
  186b78:	00c004c4 	movi	r3,19
  186b7c:	19804036 	bltu	r3,r6,186c80 <_realloc_r+0x35c>
  186b80:	9005883a 	mov	r2,r18
  186b84:	8007883a 	mov	r3,r16
  186b88:	19000017 	ldw	r4,0(r3)
  186b8c:	11000015 	stw	r4,0(r2)
  186b90:	19000117 	ldw	r4,4(r3)
  186b94:	11000115 	stw	r4,4(r2)
  186b98:	18c00217 	ldw	r3,8(r3)
  186b9c:	10c00215 	stw	r3,8(r2)
  186ba0:	a809883a 	mov	r4,r21
  186ba4:	800b883a 	mov	r5,r16
  186ba8:	0187bec0 	call	187bec <_free_r>
  186bac:	a809883a 	mov	r4,r21
  186bb0:	0188b1c0 	call	188b1c <__malloc_unlock>
  186bb4:	003fba06 	br	186aa0 <_realloc_r+0x17c>
  186bb8:	300b883a 	mov	r5,r6
  186bbc:	dfc00a17 	ldw	ra,40(sp)
  186bc0:	df000917 	ldw	fp,36(sp)
  186bc4:	ddc00817 	ldw	r23,32(sp)
  186bc8:	dd800717 	ldw	r22,28(sp)
  186bcc:	dd400617 	ldw	r21,24(sp)
  186bd0:	dd000517 	ldw	r20,20(sp)
  186bd4:	dcc00417 	ldw	r19,16(sp)
  186bd8:	dc800317 	ldw	r18,12(sp)
  186bdc:	dc400217 	ldw	r17,8(sp)
  186be0:	dc000117 	ldw	r16,4(sp)
  186be4:	dec00b04 	addi	sp,sp,44
  186be8:	0185bb41 	jmpi	185bb4 <_malloc_r>
  186bec:	29800117 	ldw	r6,4(r5)
  186bf0:	013fff04 	movi	r4,-4
  186bf4:	89c00404 	addi	r7,r17,16
  186bf8:	310c703a 	and	r6,r6,r4
  186bfc:	34c9883a 	add	r4,r6,r19
  186c00:	21c0340e 	bge	r4,r7,186cd4 <_realloc_r+0x3b0>
  186c04:	2809883a 	mov	r4,r5
  186c08:	003f7106 	br	1869d0 <_realloc_r+0xac>
  186c0c:	b8800317 	ldw	r2,12(r23)
  186c10:	b8c00217 	ldw	r3,8(r23)
  186c14:	99bfff04 	addi	r6,r19,-4
  186c18:	01000904 	movi	r4,36
  186c1c:	18800315 	stw	r2,12(r3)
  186c20:	10c00215 	stw	r3,8(r2)
  186c24:	bc800204 	addi	r18,r23,8
  186c28:	21807836 	bltu	r4,r6,186e0c <_realloc_r+0x4e8>
  186c2c:	008004c4 	movi	r2,19
  186c30:	1180732e 	bgeu	r2,r6,186e00 <_realloc_r+0x4dc>
  186c34:	80800017 	ldw	r2,0(r16)
  186c38:	b8800215 	stw	r2,8(r23)
  186c3c:	80800117 	ldw	r2,4(r16)
  186c40:	b8800315 	stw	r2,12(r23)
  186c44:	008006c4 	movi	r2,27
  186c48:	11808936 	bltu	r2,r6,186e70 <_realloc_r+0x54c>
  186c4c:	b8800404 	addi	r2,r23,16
  186c50:	80c00204 	addi	r3,r16,8
  186c54:	19000017 	ldw	r4,0(r3)
  186c58:	9021883a 	mov	r16,r18
  186c5c:	3829883a 	mov	r20,r7
  186c60:	11000015 	stw	r4,0(r2)
  186c64:	19000117 	ldw	r4,4(r3)
  186c68:	b82d883a 	mov	r22,r23
  186c6c:	11000115 	stw	r4,4(r2)
  186c70:	18c00217 	ldw	r3,8(r3)
  186c74:	10c00215 	stw	r3,8(r2)
  186c78:	b8800117 	ldw	r2,4(r23)
  186c7c:	003f7b06 	br	186a6c <_realloc_r+0x148>
  186c80:	80c00017 	ldw	r3,0(r16)
  186c84:	90c00015 	stw	r3,0(r18)
  186c88:	80c00117 	ldw	r3,4(r16)
  186c8c:	90c00115 	stw	r3,4(r18)
  186c90:	00c006c4 	movi	r3,27
  186c94:	19804636 	bltu	r3,r6,186db0 <_realloc_r+0x48c>
  186c98:	90800204 	addi	r2,r18,8
  186c9c:	80c00204 	addi	r3,r16,8
  186ca0:	003fb906 	br	186b88 <_realloc_r+0x264>
  186ca4:	9005883a 	mov	r2,r18
  186ca8:	8007883a 	mov	r3,r16
  186cac:	19000017 	ldw	r4,0(r3)
  186cb0:	9021883a 	mov	r16,r18
  186cb4:	b82d883a 	mov	r22,r23
  186cb8:	11000015 	stw	r4,0(r2)
  186cbc:	19000117 	ldw	r4,4(r3)
  186cc0:	11000115 	stw	r4,4(r2)
  186cc4:	18c00217 	ldw	r3,8(r3)
  186cc8:	10c00215 	stw	r3,8(r2)
  186ccc:	b8800117 	ldw	r2,4(r23)
  186cd0:	003f6606 	br	186a6c <_realloc_r+0x148>
  186cd4:	2445c83a 	sub	r2,r4,r17
  186cd8:	b46d883a 	add	r22,r22,r17
  186cdc:	10800054 	ori	r2,r2,1
  186ce0:	b0800115 	stw	r2,4(r22)
  186ce4:	80bfff17 	ldw	r2,-4(r16)
  186ce8:	a809883a 	mov	r4,r21
  186cec:	e5800215 	stw	r22,8(fp)
  186cf0:	1080004c 	andi	r2,r2,1
  186cf4:	88a2b03a 	or	r17,r17,r2
  186cf8:	847fff15 	stw	r17,-4(r16)
  186cfc:	0188b1c0 	call	188b1c <__malloc_unlock>
  186d00:	8025883a 	mov	r18,r16
  186d04:	003f6606 	br	186aa0 <_realloc_r+0x17c>
  186d08:	9009883a 	mov	r4,r18
  186d0c:	800b883a 	mov	r5,r16
  186d10:	01865ec0 	call	1865ec <memmove>
  186d14:	003fa206 	br	186ba0 <_realloc_r+0x27c>
  186d18:	88800404 	addi	r2,r17,16
  186d1c:	a0bf8716 	blt	r20,r2,186b3c <_realloc_r+0x218>
  186d20:	b8800317 	ldw	r2,12(r23)
  186d24:	b8c00217 	ldw	r3,8(r23)
  186d28:	99bfff04 	addi	r6,r19,-4
  186d2c:	01000904 	movi	r4,36
  186d30:	18800315 	stw	r2,12(r3)
  186d34:	10c00215 	stw	r3,8(r2)
  186d38:	bc800204 	addi	r18,r23,8
  186d3c:	21806536 	bltu	r4,r6,186ed4 <_realloc_r+0x5b0>
  186d40:	008004c4 	movi	r2,19
  186d44:	1180592e 	bgeu	r2,r6,186eac <_realloc_r+0x588>
  186d48:	80800017 	ldw	r2,0(r16)
  186d4c:	b8800215 	stw	r2,8(r23)
  186d50:	80800117 	ldw	r2,4(r16)
  186d54:	b8800315 	stw	r2,12(r23)
  186d58:	008006c4 	movi	r2,27
  186d5c:	11806136 	bltu	r2,r6,186ee4 <_realloc_r+0x5c0>
  186d60:	b8800404 	addi	r2,r23,16
  186d64:	80c00204 	addi	r3,r16,8
  186d68:	19000017 	ldw	r4,0(r3)
  186d6c:	11000015 	stw	r4,0(r2)
  186d70:	19000117 	ldw	r4,4(r3)
  186d74:	11000115 	stw	r4,4(r2)
  186d78:	18c00217 	ldw	r3,8(r3)
  186d7c:	10c00215 	stw	r3,8(r2)
  186d80:	a447c83a 	sub	r3,r20,r17
  186d84:	bc45883a 	add	r2,r23,r17
  186d88:	18c00054 	ori	r3,r3,1
  186d8c:	10c00115 	stw	r3,4(r2)
  186d90:	b8c00117 	ldw	r3,4(r23)
  186d94:	e0800215 	stw	r2,8(fp)
  186d98:	a809883a 	mov	r4,r21
  186d9c:	1880004c 	andi	r2,r3,1
  186da0:	88a2b03a 	or	r17,r17,r2
  186da4:	bc400115 	stw	r17,4(r23)
  186da8:	0188b1c0 	call	188b1c <__malloc_unlock>
  186dac:	003f3c06 	br	186aa0 <_realloc_r+0x17c>
  186db0:	80c00217 	ldw	r3,8(r16)
  186db4:	90c00215 	stw	r3,8(r18)
  186db8:	80c00317 	ldw	r3,12(r16)
  186dbc:	90c00315 	stw	r3,12(r18)
  186dc0:	30802426 	beq	r6,r2,186e54 <_realloc_r+0x530>
  186dc4:	90800404 	addi	r2,r18,16
  186dc8:	80c00404 	addi	r3,r16,16
  186dcc:	003f6e06 	br	186b88 <_realloc_r+0x264>
  186dd0:	953fff17 	ldw	r20,-4(r18)
  186dd4:	00ffff04 	movi	r3,-4
  186dd8:	a0e8703a 	and	r20,r20,r3
  186ddc:	a4e9883a 	add	r20,r20,r19
  186de0:	003f2206 	br	186a6c <_realloc_r+0x148>
  186de4:	800b883a 	mov	r5,r16
  186de8:	9009883a 	mov	r4,r18
  186dec:	01865ec0 	call	1865ec <memmove>
  186df0:	9021883a 	mov	r16,r18
  186df4:	b8800117 	ldw	r2,4(r23)
  186df8:	b82d883a 	mov	r22,r23
  186dfc:	003f1b06 	br	186a6c <_realloc_r+0x148>
  186e00:	9005883a 	mov	r2,r18
  186e04:	8007883a 	mov	r3,r16
  186e08:	003f9206 	br	186c54 <_realloc_r+0x330>
  186e0c:	800b883a 	mov	r5,r16
  186e10:	9009883a 	mov	r4,r18
  186e14:	d9c00015 	stw	r7,0(sp)
  186e18:	01865ec0 	call	1865ec <memmove>
  186e1c:	d9c00017 	ldw	r7,0(sp)
  186e20:	9021883a 	mov	r16,r18
  186e24:	b8800117 	ldw	r2,4(r23)
  186e28:	3829883a 	mov	r20,r7
  186e2c:	b82d883a 	mov	r22,r23
  186e30:	003f0e06 	br	186a6c <_realloc_r+0x148>
  186e34:	80800217 	ldw	r2,8(r16)
  186e38:	b8800415 	stw	r2,16(r23)
  186e3c:	80800317 	ldw	r2,12(r16)
  186e40:	b8800515 	stw	r2,20(r23)
  186e44:	31001226 	beq	r6,r4,186e90 <_realloc_r+0x56c>
  186e48:	b8800604 	addi	r2,r23,24
  186e4c:	80c00404 	addi	r3,r16,16
  186e50:	003f9606 	br	186cac <_realloc_r+0x388>
  186e54:	81000417 	ldw	r4,16(r16)
  186e58:	90800604 	addi	r2,r18,24
  186e5c:	80c00604 	addi	r3,r16,24
  186e60:	91000415 	stw	r4,16(r18)
  186e64:	81000517 	ldw	r4,20(r16)
  186e68:	91000515 	stw	r4,20(r18)
  186e6c:	003f4606 	br	186b88 <_realloc_r+0x264>
  186e70:	80800217 	ldw	r2,8(r16)
  186e74:	b8800415 	stw	r2,16(r23)
  186e78:	80800317 	ldw	r2,12(r16)
  186e7c:	b8800515 	stw	r2,20(r23)
  186e80:	31000d26 	beq	r6,r4,186eb8 <_realloc_r+0x594>
  186e84:	b8800604 	addi	r2,r23,24
  186e88:	80c00404 	addi	r3,r16,16
  186e8c:	003f7106 	br	186c54 <_realloc_r+0x330>
  186e90:	81000417 	ldw	r4,16(r16)
  186e94:	b8800804 	addi	r2,r23,32
  186e98:	80c00604 	addi	r3,r16,24
  186e9c:	b9000615 	stw	r4,24(r23)
  186ea0:	81000517 	ldw	r4,20(r16)
  186ea4:	b9000715 	stw	r4,28(r23)
  186ea8:	003f8006 	br	186cac <_realloc_r+0x388>
  186eac:	9005883a 	mov	r2,r18
  186eb0:	8007883a 	mov	r3,r16
  186eb4:	003fac06 	br	186d68 <_realloc_r+0x444>
  186eb8:	81000417 	ldw	r4,16(r16)
  186ebc:	b8800804 	addi	r2,r23,32
  186ec0:	80c00604 	addi	r3,r16,24
  186ec4:	b9000615 	stw	r4,24(r23)
  186ec8:	81000517 	ldw	r4,20(r16)
  186ecc:	b9000715 	stw	r4,28(r23)
  186ed0:	003f6006 	br	186c54 <_realloc_r+0x330>
  186ed4:	9009883a 	mov	r4,r18
  186ed8:	800b883a 	mov	r5,r16
  186edc:	01865ec0 	call	1865ec <memmove>
  186ee0:	003fa706 	br	186d80 <_realloc_r+0x45c>
  186ee4:	80800217 	ldw	r2,8(r16)
  186ee8:	b8800415 	stw	r2,16(r23)
  186eec:	80800317 	ldw	r2,12(r16)
  186ef0:	b8800515 	stw	r2,20(r23)
  186ef4:	31000326 	beq	r6,r4,186f04 <_realloc_r+0x5e0>
  186ef8:	b8800604 	addi	r2,r23,24
  186efc:	80c00404 	addi	r3,r16,16
  186f00:	003f9906 	br	186d68 <_realloc_r+0x444>
  186f04:	81000417 	ldw	r4,16(r16)
  186f08:	b8800804 	addi	r2,r23,32
  186f0c:	80c00604 	addi	r3,r16,24
  186f10:	b9000615 	stw	r4,24(r23)
  186f14:	81000517 	ldw	r4,20(r16)
  186f18:	b9000715 	stw	r4,28(r23)
  186f1c:	003f9206 	br	186d68 <_realloc_r+0x444>

00186f20 <_sbrk_r>:
  186f20:	defffd04 	addi	sp,sp,-12
  186f24:	dc400115 	stw	r17,4(sp)
  186f28:	dc000015 	stw	r16,0(sp)
  186f2c:	2023883a 	mov	r17,r4
  186f30:	04000674 	movhi	r16,25
  186f34:	84315a04 	addi	r16,r16,-15000
  186f38:	2809883a 	mov	r4,r5
  186f3c:	dfc00215 	stw	ra,8(sp)
  186f40:	80000015 	stw	zero,0(r16)
  186f44:	0188c800 	call	188c80 <sbrk>
  186f48:	00ffffc4 	movi	r3,-1
  186f4c:	10c00526 	beq	r2,r3,186f64 <_sbrk_r+0x44>
  186f50:	dfc00217 	ldw	ra,8(sp)
  186f54:	dc400117 	ldw	r17,4(sp)
  186f58:	dc000017 	ldw	r16,0(sp)
  186f5c:	dec00304 	addi	sp,sp,12
  186f60:	f800283a 	ret
  186f64:	80c00017 	ldw	r3,0(r16)
  186f68:	183ff926 	beq	r3,zero,186f50 <_sbrk_r+0x30>
  186f6c:	88c00015 	stw	r3,0(r17)
  186f70:	dfc00217 	ldw	ra,8(sp)
  186f74:	dc400117 	ldw	r17,4(sp)
  186f78:	dc000017 	ldw	r16,0(sp)
  186f7c:	dec00304 	addi	sp,sp,12
  186f80:	f800283a 	ret

00186f84 <strlen>:
  186f84:	208000cc 	andi	r2,r4,3
  186f88:	10001f1e 	bne	r2,zero,187008 <strlen+0x84>
  186f8c:	20800017 	ldw	r2,0(r4)
  186f90:	01ffbff4 	movhi	r7,65279
  186f94:	39ffbfc4 	addi	r7,r7,-257
  186f98:	01a02074 	movhi	r6,32897
  186f9c:	31a02004 	addi	r6,r6,-32640
  186fa0:	11c7883a 	add	r3,r2,r7
  186fa4:	0084303a 	nor	r2,zero,r2
  186fa8:	1886703a 	and	r3,r3,r2
  186fac:	1986703a 	and	r3,r3,r6
  186fb0:	2005883a 	mov	r2,r4
  186fb4:	1800101e 	bne	r3,zero,186ff8 <strlen+0x74>
  186fb8:	10800104 	addi	r2,r2,4
  186fbc:	10c00017 	ldw	r3,0(r2)
  186fc0:	19cb883a 	add	r5,r3,r7
  186fc4:	00c6303a 	nor	r3,zero,r3
  186fc8:	28c6703a 	and	r3,r5,r3
  186fcc:	1986703a 	and	r3,r3,r6
  186fd0:	1800091e 	bne	r3,zero,186ff8 <strlen+0x74>
  186fd4:	10800104 	addi	r2,r2,4
  186fd8:	10c00017 	ldw	r3,0(r2)
  186fdc:	19cb883a 	add	r5,r3,r7
  186fe0:	00c6303a 	nor	r3,zero,r3
  186fe4:	28c6703a 	and	r3,r5,r3
  186fe8:	1986703a 	and	r3,r3,r6
  186fec:	183ff226 	beq	r3,zero,186fb8 <strlen+0x34>
  186ff0:	00000106 	br	186ff8 <strlen+0x74>
  186ff4:	10800044 	addi	r2,r2,1
  186ff8:	10c00007 	ldb	r3,0(r2)
  186ffc:	183ffd1e 	bne	r3,zero,186ff4 <strlen+0x70>
  187000:	1105c83a 	sub	r2,r2,r4
  187004:	f800283a 	ret
  187008:	2005883a 	mov	r2,r4
  18700c:	003ffa06 	br	186ff8 <strlen+0x74>

00187010 <__swbuf_r>:
  187010:	defffc04 	addi	sp,sp,-16
  187014:	dc800215 	stw	r18,8(sp)
  187018:	dc400115 	stw	r17,4(sp)
  18701c:	dc000015 	stw	r16,0(sp)
  187020:	dfc00315 	stw	ra,12(sp)
  187024:	2023883a 	mov	r17,r4
  187028:	2825883a 	mov	r18,r5
  18702c:	3021883a 	mov	r16,r6
  187030:	20000226 	beq	r4,zero,18703c <__swbuf_r+0x2c>
  187034:	20800e17 	ldw	r2,56(r4)
  187038:	10003b26 	beq	r2,zero,187128 <__swbuf_r+0x118>
  18703c:	8080030b 	ldhu	r2,12(r16)
  187040:	80c00617 	ldw	r3,24(r16)
  187044:	1080020c 	andi	r2,r2,8
  187048:	10bfffcc 	andi	r2,r2,65535
  18704c:	10a0001c 	xori	r2,r2,32768
  187050:	80c00215 	stw	r3,8(r16)
  187054:	10a00004 	addi	r2,r2,-32768
  187058:	10002226 	beq	r2,zero,1870e4 <__swbuf_r+0xd4>
  18705c:	80800417 	ldw	r2,16(r16)
  187060:	10002026 	beq	r2,zero,1870e4 <__swbuf_r+0xd4>
  187064:	80c00017 	ldw	r3,0(r16)
  187068:	81000517 	ldw	r4,20(r16)
  18706c:	94803fcc 	andi	r18,r18,255
  187070:	1885c83a 	sub	r2,r3,r2
  187074:	1100250e 	bge	r2,r4,18710c <__swbuf_r+0xfc>
  187078:	10800044 	addi	r2,r2,1
  18707c:	81400217 	ldw	r5,8(r16)
  187080:	19000044 	addi	r4,r3,1
  187084:	297fffc4 	addi	r5,r5,-1
  187088:	81400215 	stw	r5,8(r16)
  18708c:	1c800005 	stb	r18,0(r3)
  187090:	80c00517 	ldw	r3,20(r16)
  187094:	81000015 	stw	r4,0(r16)
  187098:	18800c26 	beq	r3,r2,1870cc <__swbuf_r+0xbc>
  18709c:	8080030b 	ldhu	r2,12(r16)
  1870a0:	1080004c 	andi	r2,r2,1
  1870a4:	10000226 	beq	r2,zero,1870b0 <__swbuf_r+0xa0>
  1870a8:	00800284 	movi	r2,10
  1870ac:	90800726 	beq	r18,r2,1870cc <__swbuf_r+0xbc>
  1870b0:	9005883a 	mov	r2,r18
  1870b4:	dfc00317 	ldw	ra,12(sp)
  1870b8:	dc800217 	ldw	r18,8(sp)
  1870bc:	dc400117 	ldw	r17,4(sp)
  1870c0:	dc000017 	ldw	r16,0(sp)
  1870c4:	dec00404 	addi	sp,sp,16
  1870c8:	f800283a 	ret
  1870cc:	8809883a 	mov	r4,r17
  1870d0:	800b883a 	mov	r5,r16
  1870d4:	01875ac0 	call	1875ac <_fflush_r>
  1870d8:	103ff526 	beq	r2,zero,1870b0 <__swbuf_r+0xa0>
  1870dc:	04bfffc4 	movi	r18,-1
  1870e0:	003ff306 	br	1870b0 <__swbuf_r+0xa0>
  1870e4:	8809883a 	mov	r4,r17
  1870e8:	800b883a 	mov	r5,r16
  1870ec:	01871680 	call	187168 <__swsetup_r>
  1870f0:	10000f1e 	bne	r2,zero,187130 <__swbuf_r+0x120>
  1870f4:	80800417 	ldw	r2,16(r16)
  1870f8:	80c00017 	ldw	r3,0(r16)
  1870fc:	81000517 	ldw	r4,20(r16)
  187100:	94803fcc 	andi	r18,r18,255
  187104:	1885c83a 	sub	r2,r3,r2
  187108:	113fdb16 	blt	r2,r4,187078 <__swbuf_r+0x68>
  18710c:	8809883a 	mov	r4,r17
  187110:	800b883a 	mov	r5,r16
  187114:	01875ac0 	call	1875ac <_fflush_r>
  187118:	103ff01e 	bne	r2,zero,1870dc <__swbuf_r+0xcc>
  18711c:	80c00017 	ldw	r3,0(r16)
  187120:	00800044 	movi	r2,1
  187124:	003fd506 	br	18707c <__swbuf_r+0x6c>
  187128:	01878680 	call	187868 <__sinit>
  18712c:	003fc306 	br	18703c <__swbuf_r+0x2c>
  187130:	8080030b 	ldhu	r2,12(r16)
  187134:	04bfffc4 	movi	r18,-1
  187138:	10801014 	ori	r2,r2,64
  18713c:	8080030d 	sth	r2,12(r16)
  187140:	00800244 	movi	r2,9
  187144:	88800015 	stw	r2,0(r17)
  187148:	003fd906 	br	1870b0 <__swbuf_r+0xa0>

0018714c <__swbuf>:
  18714c:	00c00674 	movhi	r3,25
  187150:	18ea8a04 	addi	r3,r3,-21976
  187154:	2005883a 	mov	r2,r4
  187158:	19000017 	ldw	r4,0(r3)
  18715c:	280d883a 	mov	r6,r5
  187160:	100b883a 	mov	r5,r2
  187164:	01870101 	jmpi	187010 <__swbuf_r>

00187168 <__swsetup_r>:
  187168:	00800674 	movhi	r2,25
  18716c:	10aa8a04 	addi	r2,r2,-21976
  187170:	10800017 	ldw	r2,0(r2)
  187174:	defffd04 	addi	sp,sp,-12
  187178:	dc400115 	stw	r17,4(sp)
  18717c:	dc000015 	stw	r16,0(sp)
  187180:	dfc00215 	stw	ra,8(sp)
  187184:	2023883a 	mov	r17,r4
  187188:	2821883a 	mov	r16,r5
  18718c:	10000226 	beq	r2,zero,187198 <__swsetup_r+0x30>
  187190:	10c00e17 	ldw	r3,56(r2)
  187194:	18003d26 	beq	r3,zero,18728c <__swsetup_r+0x124>
  187198:	8080030b 	ldhu	r2,12(r16)
  18719c:	10c0020c 	andi	r3,r2,8
  1871a0:	18ffffcc 	andi	r3,r3,65535
  1871a4:	18e0001c 	xori	r3,r3,32768
  1871a8:	18e00004 	addi	r3,r3,-32768
  1871ac:	18001226 	beq	r3,zero,1871f8 <__swsetup_r+0x90>
  1871b0:	80c00417 	ldw	r3,16(r16)
  1871b4:	18001f26 	beq	r3,zero,187234 <__swsetup_r+0xcc>
  1871b8:	1100004c 	andi	r4,r2,1
  1871bc:	2000261e 	bne	r4,zero,187258 <__swsetup_r+0xf0>
  1871c0:	1080008c 	andi	r2,r2,2
  1871c4:	10bfffcc 	andi	r2,r2,65535
  1871c8:	10a0001c 	xori	r2,r2,32768
  1871cc:	10a00004 	addi	r2,r2,-32768
  1871d0:	1000311e 	bne	r2,zero,187298 <__swsetup_r+0x130>
  1871d4:	80800517 	ldw	r2,20(r16)
  1871d8:	80800215 	stw	r2,8(r16)
  1871dc:	18002326 	beq	r3,zero,18726c <__swsetup_r+0x104>
  1871e0:	0005883a 	mov	r2,zero
  1871e4:	dfc00217 	ldw	ra,8(sp)
  1871e8:	dc400117 	ldw	r17,4(sp)
  1871ec:	dc000017 	ldw	r16,0(sp)
  1871f0:	dec00304 	addi	sp,sp,12
  1871f4:	f800283a 	ret
  1871f8:	10c0040c 	andi	r3,r2,16
  1871fc:	18ffffcc 	andi	r3,r3,65535
  187200:	18e0001c 	xori	r3,r3,32768
  187204:	18e00004 	addi	r3,r3,-32768
  187208:	18001e26 	beq	r3,zero,187284 <__swsetup_r+0x11c>
  18720c:	10c0010c 	andi	r3,r2,4
  187210:	18ffffcc 	andi	r3,r3,65535
  187214:	18e0001c 	xori	r3,r3,32768
  187218:	18e00004 	addi	r3,r3,-32768
  18721c:	1800211e 	bne	r3,zero,1872a4 <__swsetup_r+0x13c>
  187220:	80c00417 	ldw	r3,16(r16)
  187224:	11400214 	ori	r5,r2,8
  187228:	8140030d 	sth	r5,12(r16)
  18722c:	2805883a 	mov	r2,r5
  187230:	183fe11e 	bne	r3,zero,1871b8 <__swsetup_r+0x50>
  187234:	1140a00c 	andi	r5,r2,640
  187238:	01008004 	movi	r4,512
  18723c:	293fde26 	beq	r5,r4,1871b8 <__swsetup_r+0x50>
  187240:	8809883a 	mov	r4,r17
  187244:	800b883a 	mov	r5,r16
  187248:	018801c0 	call	18801c <__smakebuf_r>
  18724c:	8080030b 	ldhu	r2,12(r16)
  187250:	80c00417 	ldw	r3,16(r16)
  187254:	003fd806 	br	1871b8 <__swsetup_r+0x50>
  187258:	80800517 	ldw	r2,20(r16)
  18725c:	80000215 	stw	zero,8(r16)
  187260:	0085c83a 	sub	r2,zero,r2
  187264:	80800615 	stw	r2,24(r16)
  187268:	183fdd1e 	bne	r3,zero,1871e0 <__swsetup_r+0x78>
  18726c:	8080030b 	ldhu	r2,12(r16)
  187270:	1080200c 	andi	r2,r2,128
  187274:	10bfffcc 	andi	r2,r2,65535
  187278:	10a0001c 	xori	r2,r2,32768
  18727c:	10a00004 	addi	r2,r2,-32768
  187280:	103fd826 	beq	r2,zero,1871e4 <__swsetup_r+0x7c>
  187284:	00bfffc4 	movi	r2,-1
  187288:	003fd606 	br	1871e4 <__swsetup_r+0x7c>
  18728c:	1009883a 	mov	r4,r2
  187290:	01878680 	call	187868 <__sinit>
  187294:	003fc006 	br	187198 <__swsetup_r+0x30>
  187298:	0005883a 	mov	r2,zero
  18729c:	80800215 	stw	r2,8(r16)
  1872a0:	003fce06 	br	1871dc <__swsetup_r+0x74>
  1872a4:	81400c17 	ldw	r5,48(r16)
  1872a8:	28000626 	beq	r5,zero,1872c4 <__swsetup_r+0x15c>
  1872ac:	80c01004 	addi	r3,r16,64
  1872b0:	28c00326 	beq	r5,r3,1872c0 <__swsetup_r+0x158>
  1872b4:	8809883a 	mov	r4,r17
  1872b8:	0187bec0 	call	187bec <_free_r>
  1872bc:	8080030b 	ldhu	r2,12(r16)
  1872c0:	80000c15 	stw	zero,48(r16)
  1872c4:	80c00417 	ldw	r3,16(r16)
  1872c8:	013ff6c4 	movi	r4,-37
  1872cc:	2084703a 	and	r2,r4,r2
  1872d0:	80000115 	stw	zero,4(r16)
  1872d4:	80c00015 	stw	r3,0(r16)
  1872d8:	003fd206 	br	187224 <__swsetup_r+0xbc>

001872dc <__register_exitproc>:
  1872dc:	defffa04 	addi	sp,sp,-24
  1872e0:	00800674 	movhi	r2,25
  1872e4:	10aa8904 	addi	r2,r2,-21980
  1872e8:	dc000315 	stw	r16,12(sp)
  1872ec:	14000017 	ldw	r16,0(r2)
  1872f0:	dc400415 	stw	r17,16(sp)
  1872f4:	dfc00515 	stw	ra,20(sp)
  1872f8:	80805217 	ldw	r2,328(r16)
  1872fc:	2023883a 	mov	r17,r4
  187300:	10003e26 	beq	r2,zero,1873fc <__register_exitproc+0x120>
  187304:	10c00117 	ldw	r3,4(r2)
  187308:	020007c4 	movi	r8,31
  18730c:	40c0180e 	bge	r8,r3,187370 <__register_exitproc+0x94>
  187310:	00800034 	movhi	r2,0
  187314:	10800004 	addi	r2,r2,0
  187318:	1000061e 	bne	r2,zero,187334 <__register_exitproc+0x58>
  18731c:	00bfffc4 	movi	r2,-1
  187320:	dfc00517 	ldw	ra,20(sp)
  187324:	dc400417 	ldw	r17,16(sp)
  187328:	dc000317 	ldw	r16,12(sp)
  18732c:	dec00604 	addi	sp,sp,24
  187330:	f800283a 	ret
  187334:	01006404 	movi	r4,400
  187338:	d9400015 	stw	r5,0(sp)
  18733c:	d9800115 	stw	r6,4(sp)
  187340:	d9c00215 	stw	r7,8(sp)
  187344:	00000000 	call	0 <__reset-0x180000>
  187348:	d9400017 	ldw	r5,0(sp)
  18734c:	d9800117 	ldw	r6,4(sp)
  187350:	d9c00217 	ldw	r7,8(sp)
  187354:	103ff126 	beq	r2,zero,18731c <__register_exitproc+0x40>
  187358:	80c05217 	ldw	r3,328(r16)
  18735c:	10000115 	stw	zero,4(r2)
  187360:	10c00015 	stw	r3,0(r2)
  187364:	80805215 	stw	r2,328(r16)
  187368:	10006215 	stw	zero,392(r2)
  18736c:	10006315 	stw	zero,396(r2)
  187370:	10c00117 	ldw	r3,4(r2)
  187374:	88000d1e 	bne	r17,zero,1873ac <__register_exitproc+0xd0>
  187378:	19000084 	addi	r4,r3,2
  18737c:	2109883a 	add	r4,r4,r4
  187380:	18c00044 	addi	r3,r3,1
  187384:	2109883a 	add	r4,r4,r4
  187388:	1109883a 	add	r4,r2,r4
  18738c:	10c00115 	stw	r3,4(r2)
  187390:	0005883a 	mov	r2,zero
  187394:	21400015 	stw	r5,0(r4)
  187398:	dfc00517 	ldw	ra,20(sp)
  18739c:	dc400417 	ldw	r17,16(sp)
  1873a0:	dc000317 	ldw	r16,12(sp)
  1873a4:	dec00604 	addi	sp,sp,24
  1873a8:	f800283a 	ret
  1873ac:	02400044 	movi	r9,1
  1873b0:	12806217 	ldw	r10,392(r2)
  1873b4:	48d2983a 	sll	r9,r9,r3
  1873b8:	19000804 	addi	r4,r3,32
  1873bc:	18d1883a 	add	r8,r3,r3
  1873c0:	2109883a 	add	r4,r4,r4
  1873c4:	4211883a 	add	r8,r8,r8
  1873c8:	2109883a 	add	r4,r4,r4
  1873cc:	1109883a 	add	r4,r2,r4
  1873d0:	1211883a 	add	r8,r2,r8
  1873d4:	5254b03a 	or	r10,r10,r9
  1873d8:	21c02215 	stw	r7,136(r4)
  1873dc:	41802215 	stw	r6,136(r8)
  1873e0:	12806215 	stw	r10,392(r2)
  1873e4:	01000084 	movi	r4,2
  1873e8:	893fe31e 	bne	r17,r4,187378 <__register_exitproc+0x9c>
  1873ec:	11006317 	ldw	r4,396(r2)
  1873f0:	2252b03a 	or	r9,r4,r9
  1873f4:	12406315 	stw	r9,396(r2)
  1873f8:	003fdf06 	br	187378 <__register_exitproc+0x9c>
  1873fc:	00800674 	movhi	r2,25
  187400:	10b24104 	addi	r2,r2,-14076
  187404:	80805215 	stw	r2,328(r16)
  187408:	003fbe06 	br	187304 <__register_exitproc+0x28>

0018740c <__call_exitprocs>:
  18740c:	00800674 	movhi	r2,25
  187410:	10aa8904 	addi	r2,r2,-21980
  187414:	10800017 	ldw	r2,0(r2)
  187418:	defff304 	addi	sp,sp,-52
  18741c:	df000b15 	stw	fp,44(sp)
  187420:	d8800015 	stw	r2,0(sp)
  187424:	10805204 	addi	r2,r2,328
  187428:	dd400815 	stw	r21,32(sp)
  18742c:	dfc00c15 	stw	ra,48(sp)
  187430:	ddc00a15 	stw	r23,40(sp)
  187434:	dd800915 	stw	r22,36(sp)
  187438:	dd000715 	stw	r20,28(sp)
  18743c:	dcc00615 	stw	r19,24(sp)
  187440:	dc800515 	stw	r18,20(sp)
  187444:	dc400415 	stw	r17,16(sp)
  187448:	dc000315 	stw	r16,12(sp)
  18744c:	d9000115 	stw	r4,4(sp)
  187450:	2839883a 	mov	fp,r5
  187454:	d8800215 	stw	r2,8(sp)
  187458:	057fffc4 	movi	r21,-1
  18745c:	d8800017 	ldw	r2,0(sp)
  187460:	ddc00217 	ldw	r23,8(sp)
  187464:	14805217 	ldw	r18,328(r2)
  187468:	90001726 	beq	r18,zero,1874c8 <__call_exitprocs+0xbc>
  18746c:	94400117 	ldw	r17,4(r18)
  187470:	8c3fffc4 	addi	r16,r17,-1
  187474:	80001116 	blt	r16,zero,1874bc <__call_exitprocs+0xb0>
  187478:	8c400044 	addi	r17,r17,1
  18747c:	8427883a 	add	r19,r16,r16
  187480:	8c63883a 	add	r17,r17,r17
  187484:	95802204 	addi	r22,r18,136
  187488:	9ce7883a 	add	r19,r19,r19
  18748c:	8c63883a 	add	r17,r17,r17
  187490:	b4e7883a 	add	r19,r22,r19
  187494:	9463883a 	add	r17,r18,r17
  187498:	e0001726 	beq	fp,zero,1874f8 <__call_exitprocs+0xec>
  18749c:	8c87c83a 	sub	r3,r17,r18
  1874a0:	b0c7883a 	add	r3,r22,r3
  1874a4:	18c01e17 	ldw	r3,120(r3)
  1874a8:	1f001326 	beq	r3,fp,1874f8 <__call_exitprocs+0xec>
  1874ac:	843fffc4 	addi	r16,r16,-1
  1874b0:	9cffff04 	addi	r19,r19,-4
  1874b4:	8c7fff04 	addi	r17,r17,-4
  1874b8:	857ff71e 	bne	r16,r21,187498 <__call_exitprocs+0x8c>
  1874bc:	00800034 	movhi	r2,0
  1874c0:	10800004 	addi	r2,r2,0
  1874c4:	10002a1e 	bne	r2,zero,187570 <__call_exitprocs+0x164>
  1874c8:	dfc00c17 	ldw	ra,48(sp)
  1874cc:	df000b17 	ldw	fp,44(sp)
  1874d0:	ddc00a17 	ldw	r23,40(sp)
  1874d4:	dd800917 	ldw	r22,36(sp)
  1874d8:	dd400817 	ldw	r21,32(sp)
  1874dc:	dd000717 	ldw	r20,28(sp)
  1874e0:	dcc00617 	ldw	r19,24(sp)
  1874e4:	dc800517 	ldw	r18,20(sp)
  1874e8:	dc400417 	ldw	r17,16(sp)
  1874ec:	dc000317 	ldw	r16,12(sp)
  1874f0:	dec00d04 	addi	sp,sp,52
  1874f4:	f800283a 	ret
  1874f8:	91000117 	ldw	r4,4(r18)
  1874fc:	88c00017 	ldw	r3,0(r17)
  187500:	213fffc4 	addi	r4,r4,-1
  187504:	24001526 	beq	r4,r16,18755c <__call_exitprocs+0x150>
  187508:	88000015 	stw	zero,0(r17)
  18750c:	183fe726 	beq	r3,zero,1874ac <__call_exitprocs+0xa0>
  187510:	00800044 	movi	r2,1
  187514:	1408983a 	sll	r4,r2,r16
  187518:	91406217 	ldw	r5,392(r18)
  18751c:	95000117 	ldw	r20,4(r18)
  187520:	214a703a 	and	r5,r4,r5
  187524:	28000b26 	beq	r5,zero,187554 <__call_exitprocs+0x148>
  187528:	91406317 	ldw	r5,396(r18)
  18752c:	2148703a 	and	r4,r4,r5
  187530:	20000c1e 	bne	r4,zero,187564 <__call_exitprocs+0x158>
  187534:	99400017 	ldw	r5,0(r19)
  187538:	d9000117 	ldw	r4,4(sp)
  18753c:	183ee83a 	callr	r3
  187540:	90c00117 	ldw	r3,4(r18)
  187544:	1d3fc51e 	bne	r3,r20,18745c <__call_exitprocs+0x50>
  187548:	b8c00017 	ldw	r3,0(r23)
  18754c:	1cbfd726 	beq	r3,r18,1874ac <__call_exitprocs+0xa0>
  187550:	003fc206 	br	18745c <__call_exitprocs+0x50>
  187554:	183ee83a 	callr	r3
  187558:	003ff906 	br	187540 <__call_exitprocs+0x134>
  18755c:	94000115 	stw	r16,4(r18)
  187560:	003fea06 	br	18750c <__call_exitprocs+0x100>
  187564:	99000017 	ldw	r4,0(r19)
  187568:	183ee83a 	callr	r3
  18756c:	003ff406 	br	187540 <__call_exitprocs+0x134>
  187570:	90c00117 	ldw	r3,4(r18)
  187574:	1800071e 	bne	r3,zero,187594 <__call_exitprocs+0x188>
  187578:	90c00017 	ldw	r3,0(r18)
  18757c:	18000926 	beq	r3,zero,1875a4 <__call_exitprocs+0x198>
  187580:	9009883a 	mov	r4,r18
  187584:	b8c00015 	stw	r3,0(r23)
  187588:	00000000 	call	0 <__reset-0x180000>
  18758c:	bc800017 	ldw	r18,0(r23)
  187590:	003fb506 	br	187468 <__call_exitprocs+0x5c>
  187594:	90c00017 	ldw	r3,0(r18)
  187598:	902f883a 	mov	r23,r18
  18759c:	1825883a 	mov	r18,r3
  1875a0:	003fb106 	br	187468 <__call_exitprocs+0x5c>
  1875a4:	0007883a 	mov	r3,zero
  1875a8:	003ffb06 	br	187598 <__call_exitprocs+0x18c>

001875ac <_fflush_r>:
  1875ac:	defffb04 	addi	sp,sp,-20
  1875b0:	dcc00315 	stw	r19,12(sp)
  1875b4:	dc400115 	stw	r17,4(sp)
  1875b8:	dfc00415 	stw	ra,16(sp)
  1875bc:	dc800215 	stw	r18,8(sp)
  1875c0:	dc000015 	stw	r16,0(sp)
  1875c4:	2027883a 	mov	r19,r4
  1875c8:	2823883a 	mov	r17,r5
  1875cc:	20000226 	beq	r4,zero,1875d8 <_fflush_r+0x2c>
  1875d0:	20800e17 	ldw	r2,56(r4)
  1875d4:	10005726 	beq	r2,zero,187734 <_fflush_r+0x188>
  1875d8:	8880030b 	ldhu	r2,12(r17)
  1875dc:	10c0020c 	andi	r3,r2,8
  1875e0:	18ffffcc 	andi	r3,r3,65535
  1875e4:	18e0001c 	xori	r3,r3,32768
  1875e8:	18e00004 	addi	r3,r3,-32768
  1875ec:	1800311e 	bne	r3,zero,1876b4 <_fflush_r+0x108>
  1875f0:	89000117 	ldw	r4,4(r17)
  1875f4:	10c20014 	ori	r3,r2,2048
  1875f8:	88c0030d 	sth	r3,12(r17)
  1875fc:	180b883a 	mov	r5,r3
  187600:	0100520e 	bge	zero,r4,18774c <_fflush_r+0x1a0>
  187604:	88c00a17 	ldw	r3,40(r17)
  187608:	18002226 	beq	r3,zero,187694 <_fflush_r+0xe8>
  18760c:	1084000c 	andi	r2,r2,4096
  187610:	10bfffcc 	andi	r2,r2,65535
  187614:	10a0001c 	xori	r2,r2,32768
  187618:	10a00004 	addi	r2,r2,-32768
  18761c:	10004e26 	beq	r2,zero,187758 <_fflush_r+0x1ac>
  187620:	8c001417 	ldw	r16,80(r17)
  187624:	2940010c 	andi	r5,r5,4
  187628:	297fffcc 	andi	r5,r5,65535
  18762c:	2960001c 	xori	r5,r5,32768
  187630:	29600004 	addi	r5,r5,-32768
  187634:	28000626 	beq	r5,zero,187650 <_fflush_r+0xa4>
  187638:	89000117 	ldw	r4,4(r17)
  18763c:	88800c17 	ldw	r2,48(r17)
  187640:	8121c83a 	sub	r16,r16,r4
  187644:	10000226 	beq	r2,zero,187650 <_fflush_r+0xa4>
  187648:	88800f17 	ldw	r2,60(r17)
  18764c:	80a1c83a 	sub	r16,r16,r2
  187650:	89400717 	ldw	r5,28(r17)
  187654:	9809883a 	mov	r4,r19
  187658:	800d883a 	mov	r6,r16
  18765c:	000f883a 	mov	r7,zero
  187660:	183ee83a 	callr	r3
  187664:	8080281e 	bne	r16,r2,187708 <_fflush_r+0x15c>
  187668:	8880030b 	ldhu	r2,12(r17)
  18766c:	88c00417 	ldw	r3,16(r17)
  187670:	88000115 	stw	zero,4(r17)
  187674:	113dffcc 	andi	r4,r2,63487
  187678:	1084000c 	andi	r2,r2,4096
  18767c:	10bfffcc 	andi	r2,r2,65535
  187680:	10a0001c 	xori	r2,r2,32768
  187684:	8900030d 	sth	r4,12(r17)
  187688:	88c00015 	stw	r3,0(r17)
  18768c:	10a00004 	addi	r2,r2,-32768
  187690:	10002c1e 	bne	r2,zero,187744 <_fflush_r+0x198>
  187694:	0005883a 	mov	r2,zero
  187698:	dfc00417 	ldw	ra,16(sp)
  18769c:	dcc00317 	ldw	r19,12(sp)
  1876a0:	dc800217 	ldw	r18,8(sp)
  1876a4:	dc400117 	ldw	r17,4(sp)
  1876a8:	dc000017 	ldw	r16,0(sp)
  1876ac:	dec00504 	addi	sp,sp,20
  1876b0:	f800283a 	ret
  1876b4:	8c800417 	ldw	r18,16(r17)
  1876b8:	903ff626 	beq	r18,zero,187694 <_fflush_r+0xe8>
  1876bc:	8c000017 	ldw	r16,0(r17)
  1876c0:	108000cc 	andi	r2,r2,3
  1876c4:	8c800015 	stw	r18,0(r17)
  1876c8:	84a1c83a 	sub	r16,r16,r18
  1876cc:	10001b1e 	bne	r2,zero,18773c <_fflush_r+0x190>
  1876d0:	88800517 	ldw	r2,20(r17)
  1876d4:	88800215 	stw	r2,8(r17)
  1876d8:	04000316 	blt	zero,r16,1876e8 <_fflush_r+0x13c>
  1876dc:	003fed06 	br	187694 <_fflush_r+0xe8>
  1876e0:	90a5883a 	add	r18,r18,r2
  1876e4:	043feb0e 	bge	zero,r16,187694 <_fflush_r+0xe8>
  1876e8:	88800917 	ldw	r2,36(r17)
  1876ec:	89400717 	ldw	r5,28(r17)
  1876f0:	800f883a 	mov	r7,r16
  1876f4:	900d883a 	mov	r6,r18
  1876f8:	9809883a 	mov	r4,r19
  1876fc:	103ee83a 	callr	r2
  187700:	80a1c83a 	sub	r16,r16,r2
  187704:	00bff616 	blt	zero,r2,1876e0 <_fflush_r+0x134>
  187708:	88c0030b 	ldhu	r3,12(r17)
  18770c:	00bfffc4 	movi	r2,-1
  187710:	18c01014 	ori	r3,r3,64
  187714:	88c0030d 	sth	r3,12(r17)
  187718:	dfc00417 	ldw	ra,16(sp)
  18771c:	dcc00317 	ldw	r19,12(sp)
  187720:	dc800217 	ldw	r18,8(sp)
  187724:	dc400117 	ldw	r17,4(sp)
  187728:	dc000017 	ldw	r16,0(sp)
  18772c:	dec00504 	addi	sp,sp,20
  187730:	f800283a 	ret
  187734:	01878680 	call	187868 <__sinit>
  187738:	003fa706 	br	1875d8 <_fflush_r+0x2c>
  18773c:	0005883a 	mov	r2,zero
  187740:	003fe406 	br	1876d4 <_fflush_r+0x128>
  187744:	8c001415 	stw	r16,80(r17)
  187748:	003fd206 	br	187694 <_fflush_r+0xe8>
  18774c:	88c00f17 	ldw	r3,60(r17)
  187750:	00ffac16 	blt	zero,r3,187604 <_fflush_r+0x58>
  187754:	003fcf06 	br	187694 <_fflush_r+0xe8>
  187758:	89400717 	ldw	r5,28(r17)
  18775c:	9809883a 	mov	r4,r19
  187760:	000d883a 	mov	r6,zero
  187764:	01c00044 	movi	r7,1
  187768:	183ee83a 	callr	r3
  18776c:	1021883a 	mov	r16,r2
  187770:	00bfffc4 	movi	r2,-1
  187774:	80800326 	beq	r16,r2,187784 <_fflush_r+0x1d8>
  187778:	8940030b 	ldhu	r5,12(r17)
  18777c:	88c00a17 	ldw	r3,40(r17)
  187780:	003fa806 	br	187624 <_fflush_r+0x78>
  187784:	98c00017 	ldw	r3,0(r19)
  187788:	00800744 	movi	r2,29
  18778c:	18bfde1e 	bne	r3,r2,187708 <_fflush_r+0x15c>
  187790:	003fc006 	br	187694 <_fflush_r+0xe8>

00187794 <fflush>:
  187794:	200b883a 	mov	r5,r4
  187798:	20000426 	beq	r4,zero,1877ac <fflush+0x18>
  18779c:	00800674 	movhi	r2,25
  1877a0:	10aa8a04 	addi	r2,r2,-21976
  1877a4:	11000017 	ldw	r4,0(r2)
  1877a8:	01875ac1 	jmpi	1875ac <_fflush_r>
  1877ac:	00800674 	movhi	r2,25
  1877b0:	10aa8904 	addi	r2,r2,-21980
  1877b4:	11000017 	ldw	r4,0(r2)
  1877b8:	01400634 	movhi	r5,24
  1877bc:	295d6b04 	addi	r5,r5,30124
  1877c0:	0187f641 	jmpi	187f64 <_fwalk_reent>

001877c4 <__fp_lock>:
  1877c4:	0005883a 	mov	r2,zero
  1877c8:	f800283a 	ret

001877cc <__fp_unlock>:
  1877cc:	0005883a 	mov	r2,zero
  1877d0:	f800283a 	ret

001877d4 <_cleanup_r>:
  1877d4:	01400674 	movhi	r5,25
  1877d8:	29617b04 	addi	r5,r5,-31252
  1877dc:	0187ebc1 	jmpi	187ebc <_fwalk>

001877e0 <__sfmoreglue>:
  1877e0:	defffc04 	addi	sp,sp,-16
  1877e4:	dc800215 	stw	r18,8(sp)
  1877e8:	2825883a 	mov	r18,r5
  1877ec:	dc000015 	stw	r16,0(sp)
  1877f0:	01401704 	movi	r5,92
  1877f4:	2021883a 	mov	r16,r4
  1877f8:	9009883a 	mov	r4,r18
  1877fc:	dfc00315 	stw	ra,12(sp)
  187800:	dc400115 	stw	r17,4(sp)
  187804:	01805f00 	call	1805f0 <__mulsi3>
  187808:	8009883a 	mov	r4,r16
  18780c:	11400304 	addi	r5,r2,12
  187810:	1023883a 	mov	r17,r2
  187814:	0185bb40 	call	185bb4 <_malloc_r>
  187818:	1021883a 	mov	r16,r2
  18781c:	10000726 	beq	r2,zero,18783c <__sfmoreglue+0x5c>
  187820:	11000304 	addi	r4,r2,12
  187824:	10000015 	stw	zero,0(r2)
  187828:	14800115 	stw	r18,4(r2)
  18782c:	11000215 	stw	r4,8(r2)
  187830:	000b883a 	mov	r5,zero
  187834:	880d883a 	mov	r6,r17
  187838:	01881c40 	call	1881c4 <memset>
  18783c:	8005883a 	mov	r2,r16
  187840:	dfc00317 	ldw	ra,12(sp)
  187844:	dc800217 	ldw	r18,8(sp)
  187848:	dc400117 	ldw	r17,4(sp)
  18784c:	dc000017 	ldw	r16,0(sp)
  187850:	dec00404 	addi	sp,sp,16
  187854:	f800283a 	ret

00187858 <_cleanup>:
  187858:	00800674 	movhi	r2,25
  18785c:	10aa8904 	addi	r2,r2,-21980
  187860:	11000017 	ldw	r4,0(r2)
  187864:	01877d41 	jmpi	1877d4 <_cleanup_r>

00187868 <__sinit>:
  187868:	20800e17 	ldw	r2,56(r4)
  18786c:	1000401e 	bne	r2,zero,187970 <__sinit+0x108>
  187870:	21400117 	ldw	r5,4(r4)
  187874:	01800634 	movhi	r6,24
  187878:	319df504 	addi	r6,r6,30676
  18787c:	20c00217 	ldw	r3,8(r4)
  187880:	21800f15 	stw	r6,60(r4)
  187884:	2080bb04 	addi	r2,r4,748
  187888:	02400044 	movi	r9,1
  18788c:	018000c4 	movi	r6,3
  187890:	2180b915 	stw	r6,740(r4)
  187894:	2080ba15 	stw	r2,744(r4)
  187898:	22400e15 	stw	r9,56(r4)
  18789c:	20800317 	ldw	r2,12(r4)
  1878a0:	2000b815 	stw	zero,736(r4)
  1878a4:	02000674 	movhi	r8,25
  1878a8:	4220a804 	addi	r8,r8,-32096
  1878ac:	01c00674 	movhi	r7,25
  1878b0:	39e0bd04 	addi	r7,r7,-32012
  1878b4:	01800674 	movhi	r6,25
  1878b8:	31a0df04 	addi	r6,r6,-31876
  1878bc:	01000674 	movhi	r4,25
  1878c0:	2120f604 	addi	r4,r4,-31784
  1878c4:	02800104 	movi	r10,4
  1878c8:	28000015 	stw	zero,0(r5)
  1878cc:	28000115 	stw	zero,4(r5)
  1878d0:	28000215 	stw	zero,8(r5)
  1878d4:	2a80030d 	sth	r10,12(r5)
  1878d8:	2800038d 	sth	zero,14(r5)
  1878dc:	28000415 	stw	zero,16(r5)
  1878e0:	28000515 	stw	zero,20(r5)
  1878e4:	28000615 	stw	zero,24(r5)
  1878e8:	29400715 	stw	r5,28(r5)
  1878ec:	2a000815 	stw	r8,32(r5)
  1878f0:	29c00915 	stw	r7,36(r5)
  1878f4:	29800a15 	stw	r6,40(r5)
  1878f8:	29000b15 	stw	r4,44(r5)
  1878fc:	01400284 	movi	r5,10
  187900:	18000015 	stw	zero,0(r3)
  187904:	18000115 	stw	zero,4(r3)
  187908:	18000215 	stw	zero,8(r3)
  18790c:	1940030d 	sth	r5,12(r3)
  187910:	1a40038d 	sth	r9,14(r3)
  187914:	18000415 	stw	zero,16(r3)
  187918:	18000515 	stw	zero,20(r3)
  18791c:	18000615 	stw	zero,24(r3)
  187920:	18c00715 	stw	r3,28(r3)
  187924:	1a000815 	stw	r8,32(r3)
  187928:	19c00915 	stw	r7,36(r3)
  18792c:	19800a15 	stw	r6,40(r3)
  187930:	19000b15 	stw	r4,44(r3)
  187934:	00c00484 	movi	r3,18
  187938:	10c0030d 	sth	r3,12(r2)
  18793c:	00c00084 	movi	r3,2
  187940:	10000015 	stw	zero,0(r2)
  187944:	10000115 	stw	zero,4(r2)
  187948:	10000215 	stw	zero,8(r2)
  18794c:	10c0038d 	sth	r3,14(r2)
  187950:	10000415 	stw	zero,16(r2)
  187954:	10000515 	stw	zero,20(r2)
  187958:	10000615 	stw	zero,24(r2)
  18795c:	10800715 	stw	r2,28(r2)
  187960:	12000815 	stw	r8,32(r2)
  187964:	11c00915 	stw	r7,36(r2)
  187968:	11800a15 	stw	r6,40(r2)
  18796c:	11000b15 	stw	r4,44(r2)
  187970:	f800283a 	ret

00187974 <__sfp>:
  187974:	defffc04 	addi	sp,sp,-16
  187978:	00800674 	movhi	r2,25
  18797c:	10aa8904 	addi	r2,r2,-21980
  187980:	dc400115 	stw	r17,4(sp)
  187984:	14400017 	ldw	r17,0(r2)
  187988:	dc800215 	stw	r18,8(sp)
  18798c:	dfc00315 	stw	ra,12(sp)
  187990:	88800e17 	ldw	r2,56(r17)
  187994:	dc000015 	stw	r16,0(sp)
  187998:	2025883a 	mov	r18,r4
  18799c:	10002826 	beq	r2,zero,187a40 <__sfp+0xcc>
  1879a0:	8c40b804 	addi	r17,r17,736
  1879a4:	043fffc4 	movi	r16,-1
  1879a8:	89400117 	ldw	r5,4(r17)
  1879ac:	88800217 	ldw	r2,8(r17)
  1879b0:	297fffc4 	addi	r5,r5,-1
  1879b4:	28000a16 	blt	r5,zero,1879e0 <__sfp+0x6c>
  1879b8:	10c0030f 	ldh	r3,12(r2)
  1879bc:	18000c26 	beq	r3,zero,1879f0 <__sfp+0x7c>
  1879c0:	10c01a04 	addi	r3,r2,104
  1879c4:	00000206 	br	1879d0 <__sfp+0x5c>
  1879c8:	19bfe90f 	ldh	r6,-92(r3)
  1879cc:	30000826 	beq	r6,zero,1879f0 <__sfp+0x7c>
  1879d0:	297fffc4 	addi	r5,r5,-1
  1879d4:	18bffd04 	addi	r2,r3,-12
  1879d8:	18c01704 	addi	r3,r3,92
  1879dc:	2c3ffa1e 	bne	r5,r16,1879c8 <__sfp+0x54>
  1879e0:	88800017 	ldw	r2,0(r17)
  1879e4:	10001926 	beq	r2,zero,187a4c <__sfp+0xd8>
  1879e8:	1023883a 	mov	r17,r2
  1879ec:	003fee06 	br	1879a8 <__sfp+0x34>
  1879f0:	00ffffc4 	movi	r3,-1
  1879f4:	10c0038d 	sth	r3,14(r2)
  1879f8:	00c00044 	movi	r3,1
  1879fc:	10c0030d 	sth	r3,12(r2)
  187a00:	10000015 	stw	zero,0(r2)
  187a04:	10000215 	stw	zero,8(r2)
  187a08:	10000115 	stw	zero,4(r2)
  187a0c:	10000415 	stw	zero,16(r2)
  187a10:	10000515 	stw	zero,20(r2)
  187a14:	10000615 	stw	zero,24(r2)
  187a18:	10000c15 	stw	zero,48(r2)
  187a1c:	10000d15 	stw	zero,52(r2)
  187a20:	10001115 	stw	zero,68(r2)
  187a24:	10001215 	stw	zero,72(r2)
  187a28:	dfc00317 	ldw	ra,12(sp)
  187a2c:	dc800217 	ldw	r18,8(sp)
  187a30:	dc400117 	ldw	r17,4(sp)
  187a34:	dc000017 	ldw	r16,0(sp)
  187a38:	dec00404 	addi	sp,sp,16
  187a3c:	f800283a 	ret
  187a40:	8809883a 	mov	r4,r17
  187a44:	01878680 	call	187868 <__sinit>
  187a48:	003fd506 	br	1879a0 <__sfp+0x2c>
  187a4c:	9009883a 	mov	r4,r18
  187a50:	01400104 	movi	r5,4
  187a54:	01877e00 	call	1877e0 <__sfmoreglue>
  187a58:	88800015 	stw	r2,0(r17)
  187a5c:	103fe21e 	bne	r2,zero,1879e8 <__sfp+0x74>
  187a60:	00800304 	movi	r2,12
  187a64:	90800015 	stw	r2,0(r18)
  187a68:	0005883a 	mov	r2,zero
  187a6c:	003fee06 	br	187a28 <__sfp+0xb4>

00187a70 <__sfp_lock_acquire>:
  187a70:	f800283a 	ret

00187a74 <__sfp_lock_release>:
  187a74:	f800283a 	ret

00187a78 <__sinit_lock_acquire>:
  187a78:	f800283a 	ret

00187a7c <__sinit_lock_release>:
  187a7c:	f800283a 	ret

00187a80 <__fp_lock_all>:
  187a80:	00800674 	movhi	r2,25
  187a84:	10aa8a04 	addi	r2,r2,-21976
  187a88:	11000017 	ldw	r4,0(r2)
  187a8c:	01400634 	movhi	r5,24
  187a90:	295df104 	addi	r5,r5,30660
  187a94:	0187ebc1 	jmpi	187ebc <_fwalk>

00187a98 <__fp_unlock_all>:
  187a98:	00800674 	movhi	r2,25
  187a9c:	10aa8a04 	addi	r2,r2,-21976
  187aa0:	11000017 	ldw	r4,0(r2)
  187aa4:	01400634 	movhi	r5,24
  187aa8:	295df304 	addi	r5,r5,30668
  187aac:	0187ebc1 	jmpi	187ebc <_fwalk>

00187ab0 <_malloc_trim_r>:
  187ab0:	defffb04 	addi	sp,sp,-20
  187ab4:	dcc00315 	stw	r19,12(sp)
  187ab8:	dc800215 	stw	r18,8(sp)
  187abc:	dc400115 	stw	r17,4(sp)
  187ac0:	dc000015 	stw	r16,0(sp)
  187ac4:	2827883a 	mov	r19,r5
  187ac8:	dfc00415 	stw	ra,16(sp)
  187acc:	04400674 	movhi	r17,25
  187ad0:	8c697e04 	addi	r17,r17,-23048
  187ad4:	2021883a 	mov	r16,r4
  187ad8:	0188afc0 	call	188afc <__malloc_lock>
  187adc:	88800217 	ldw	r2,8(r17)
  187ae0:	14800117 	ldw	r18,4(r2)
  187ae4:	00bfff04 	movi	r2,-4
  187ae8:	90a4703a 	and	r18,r18,r2
  187aec:	9083fbc4 	addi	r2,r18,4079
  187af0:	14e7c83a 	sub	r19,r2,r19
  187af4:	9826d33a 	srli	r19,r19,12
  187af8:	0083ffc4 	movi	r2,4095
  187afc:	9cffffc4 	addi	r19,r19,-1
  187b00:	9826933a 	slli	r19,r19,12
  187b04:	14c0060e 	bge	r2,r19,187b20 <_malloc_trim_r+0x70>
  187b08:	8009883a 	mov	r4,r16
  187b0c:	000b883a 	mov	r5,zero
  187b10:	0186f200 	call	186f20 <_sbrk_r>
  187b14:	88c00217 	ldw	r3,8(r17)
  187b18:	1c87883a 	add	r3,r3,r18
  187b1c:	10c00a26 	beq	r2,r3,187b48 <_malloc_trim_r+0x98>
  187b20:	8009883a 	mov	r4,r16
  187b24:	0188b1c0 	call	188b1c <__malloc_unlock>
  187b28:	0005883a 	mov	r2,zero
  187b2c:	dfc00417 	ldw	ra,16(sp)
  187b30:	dcc00317 	ldw	r19,12(sp)
  187b34:	dc800217 	ldw	r18,8(sp)
  187b38:	dc400117 	ldw	r17,4(sp)
  187b3c:	dc000017 	ldw	r16,0(sp)
  187b40:	dec00504 	addi	sp,sp,20
  187b44:	f800283a 	ret
  187b48:	8009883a 	mov	r4,r16
  187b4c:	04cbc83a 	sub	r5,zero,r19
  187b50:	0186f200 	call	186f20 <_sbrk_r>
  187b54:	00ffffc4 	movi	r3,-1
  187b58:	10c01326 	beq	r2,r3,187ba8 <_malloc_trim_r+0xf8>
  187b5c:	00800674 	movhi	r2,25
  187b60:	10b17904 	addi	r2,r2,-14876
  187b64:	11000017 	ldw	r4,0(r2)
  187b68:	88c00217 	ldw	r3,8(r17)
  187b6c:	94e5c83a 	sub	r18,r18,r19
  187b70:	94800054 	ori	r18,r18,1
  187b74:	24e7c83a 	sub	r19,r4,r19
  187b78:	1c800115 	stw	r18,4(r3)
  187b7c:	8009883a 	mov	r4,r16
  187b80:	14c00015 	stw	r19,0(r2)
  187b84:	0188b1c0 	call	188b1c <__malloc_unlock>
  187b88:	00800044 	movi	r2,1
  187b8c:	dfc00417 	ldw	ra,16(sp)
  187b90:	dcc00317 	ldw	r19,12(sp)
  187b94:	dc800217 	ldw	r18,8(sp)
  187b98:	dc400117 	ldw	r17,4(sp)
  187b9c:	dc000017 	ldw	r16,0(sp)
  187ba0:	dec00504 	addi	sp,sp,20
  187ba4:	f800283a 	ret
  187ba8:	8009883a 	mov	r4,r16
  187bac:	000b883a 	mov	r5,zero
  187bb0:	0186f200 	call	186f20 <_sbrk_r>
  187bb4:	88c00217 	ldw	r3,8(r17)
  187bb8:	014003c4 	movi	r5,15
  187bbc:	10c9c83a 	sub	r4,r2,r3
  187bc0:	293fd70e 	bge	r5,r4,187b20 <_malloc_trim_r+0x70>
  187bc4:	01400674 	movhi	r5,25
  187bc8:	296a8b04 	addi	r5,r5,-21972
  187bcc:	29400017 	ldw	r5,0(r5)
  187bd0:	21000054 	ori	r4,r4,1
  187bd4:	19000115 	stw	r4,4(r3)
  187bd8:	1145c83a 	sub	r2,r2,r5
  187bdc:	01400674 	movhi	r5,25
  187be0:	29717904 	addi	r5,r5,-14876
  187be4:	28800015 	stw	r2,0(r5)
  187be8:	003fcd06 	br	187b20 <_malloc_trim_r+0x70>

00187bec <_free_r>:
  187bec:	defffd04 	addi	sp,sp,-12
  187bf0:	dc400115 	stw	r17,4(sp)
  187bf4:	dc000015 	stw	r16,0(sp)
  187bf8:	dfc00215 	stw	ra,8(sp)
  187bfc:	2821883a 	mov	r16,r5
  187c00:	2023883a 	mov	r17,r4
  187c04:	28004b26 	beq	r5,zero,187d34 <_free_r+0x148>
  187c08:	0188afc0 	call	188afc <__malloc_lock>
  187c0c:	823fff17 	ldw	r8,-4(r16)
  187c10:	00bfff84 	movi	r2,-2
  187c14:	81bffe04 	addi	r6,r16,-8
  187c18:	4084703a 	and	r2,r8,r2
  187c1c:	3087883a 	add	r3,r6,r2
  187c20:	01400674 	movhi	r5,25
  187c24:	29697e04 	addi	r5,r5,-23048
  187c28:	1a400117 	ldw	r9,4(r3)
  187c2c:	29000217 	ldw	r4,8(r5)
  187c30:	01ffff04 	movi	r7,-4
  187c34:	49ce703a 	and	r7,r9,r7
  187c38:	20c06526 	beq	r4,r3,187dd0 <_free_r+0x1e4>
  187c3c:	19c00115 	stw	r7,4(r3)
  187c40:	4200004c 	andi	r8,r8,1
  187c44:	40003026 	beq	r8,zero,187d08 <_free_r+0x11c>
  187c48:	0009883a 	mov	r4,zero
  187c4c:	19d1883a 	add	r8,r3,r7
  187c50:	42000117 	ldw	r8,4(r8)
  187c54:	4200004c 	andi	r8,r8,1
  187c58:	4000061e 	bne	r8,zero,187c74 <_free_r+0x88>
  187c5c:	11c5883a 	add	r2,r2,r7
  187c60:	19c00217 	ldw	r7,8(r3)
  187c64:	20004e26 	beq	r4,zero,187da0 <_free_r+0x1b4>
  187c68:	18c00317 	ldw	r3,12(r3)
  187c6c:	38c00315 	stw	r3,12(r7)
  187c70:	19c00215 	stw	r7,8(r3)
  187c74:	11c00054 	ori	r7,r2,1
  187c78:	3087883a 	add	r3,r6,r2
  187c7c:	31c00115 	stw	r7,4(r6)
  187c80:	18800015 	stw	r2,0(r3)
  187c84:	20001a1e 	bne	r4,zero,187cf0 <_free_r+0x104>
  187c88:	00c07fc4 	movi	r3,511
  187c8c:	18802e2e 	bgeu	r3,r2,187d48 <_free_r+0x15c>
  187c90:	1006d27a 	srli	r3,r2,9
  187c94:	01000104 	movi	r4,4
  187c98:	20c06636 	bltu	r4,r3,187e34 <_free_r+0x248>
  187c9c:	1008d1ba 	srli	r4,r2,6
  187ca0:	21000e04 	addi	r4,r4,56
  187ca4:	210f883a 	add	r7,r4,r4
  187ca8:	39cf883a 	add	r7,r7,r7
  187cac:	39cf883a 	add	r7,r7,r7
  187cb0:	29cf883a 	add	r7,r5,r7
  187cb4:	38c00217 	ldw	r3,8(r7)
  187cb8:	01400674 	movhi	r5,25
  187cbc:	29697e04 	addi	r5,r5,-23048
  187cc0:	19c06126 	beq	r3,r7,187e48 <_free_r+0x25c>
  187cc4:	013fff04 	movi	r4,-4
  187cc8:	19400117 	ldw	r5,4(r3)
  187ccc:	290a703a 	and	r5,r5,r4
  187cd0:	1140022e 	bgeu	r2,r5,187cdc <_free_r+0xf0>
  187cd4:	18c00217 	ldw	r3,8(r3)
  187cd8:	38fffb1e 	bne	r7,r3,187cc8 <_free_r+0xdc>
  187cdc:	18800317 	ldw	r2,12(r3)
  187ce0:	30800315 	stw	r2,12(r6)
  187ce4:	30c00215 	stw	r3,8(r6)
  187ce8:	11800215 	stw	r6,8(r2)
  187cec:	19800315 	stw	r6,12(r3)
  187cf0:	8809883a 	mov	r4,r17
  187cf4:	dfc00217 	ldw	ra,8(sp)
  187cf8:	dc400117 	ldw	r17,4(sp)
  187cfc:	dc000017 	ldw	r16,0(sp)
  187d00:	dec00304 	addi	sp,sp,12
  187d04:	0188b1c1 	jmpi	188b1c <__malloc_unlock>
  187d08:	813ffe17 	ldw	r4,-8(r16)
  187d0c:	2a400204 	addi	r9,r5,8
  187d10:	310dc83a 	sub	r6,r6,r4
  187d14:	32000217 	ldw	r8,8(r6)
  187d18:	1105883a 	add	r2,r2,r4
  187d1c:	42404326 	beq	r8,r9,187e2c <_free_r+0x240>
  187d20:	32400317 	ldw	r9,12(r6)
  187d24:	0009883a 	mov	r4,zero
  187d28:	42400315 	stw	r9,12(r8)
  187d2c:	4a000215 	stw	r8,8(r9)
  187d30:	003fc606 	br	187c4c <_free_r+0x60>
  187d34:	dfc00217 	ldw	ra,8(sp)
  187d38:	dc400117 	ldw	r17,4(sp)
  187d3c:	dc000017 	ldw	r16,0(sp)
  187d40:	dec00304 	addi	sp,sp,12
  187d44:	f800283a 	ret
  187d48:	1004d0fa 	srli	r2,r2,3
  187d4c:	02000044 	movi	r8,1
  187d50:	29c00117 	ldw	r7,4(r5)
  187d54:	1087883a 	add	r3,r2,r2
  187d58:	18c7883a 	add	r3,r3,r3
  187d5c:	1005d0ba 	srai	r2,r2,2
  187d60:	18c7883a 	add	r3,r3,r3
  187d64:	28c7883a 	add	r3,r5,r3
  187d68:	19000217 	ldw	r4,8(r3)
  187d6c:	4084983a 	sll	r2,r8,r2
  187d70:	30c00315 	stw	r3,12(r6)
  187d74:	31000215 	stw	r4,8(r6)
  187d78:	11c4b03a 	or	r2,r2,r7
  187d7c:	21800315 	stw	r6,12(r4)
  187d80:	8809883a 	mov	r4,r17
  187d84:	28800115 	stw	r2,4(r5)
  187d88:	19800215 	stw	r6,8(r3)
  187d8c:	dfc00217 	ldw	ra,8(sp)
  187d90:	dc400117 	ldw	r17,4(sp)
  187d94:	dc000017 	ldw	r16,0(sp)
  187d98:	dec00304 	addi	sp,sp,12
  187d9c:	0188b1c1 	jmpi	188b1c <__malloc_unlock>
  187da0:	02000674 	movhi	r8,25
  187da4:	42298004 	addi	r8,r8,-23040
  187da8:	3a3faf1e 	bne	r7,r8,187c68 <_free_r+0x7c>
  187dac:	29800515 	stw	r6,20(r5)
  187db0:	29800415 	stw	r6,16(r5)
  187db4:	11000054 	ori	r4,r2,1
  187db8:	3087883a 	add	r3,r6,r2
  187dbc:	31c00315 	stw	r7,12(r6)
  187dc0:	31c00215 	stw	r7,8(r6)
  187dc4:	31000115 	stw	r4,4(r6)
  187dc8:	18800015 	stw	r2,0(r3)
  187dcc:	003fc806 	br	187cf0 <_free_r+0x104>
  187dd0:	4200004c 	andi	r8,r8,1
  187dd4:	3885883a 	add	r2,r7,r2
  187dd8:	4000071e 	bne	r8,zero,187df8 <_free_r+0x20c>
  187ddc:	81fffe17 	ldw	r7,-8(r16)
  187de0:	31cdc83a 	sub	r6,r6,r7
  187de4:	30c00317 	ldw	r3,12(r6)
  187de8:	31000217 	ldw	r4,8(r6)
  187dec:	11c5883a 	add	r2,r2,r7
  187df0:	20c00315 	stw	r3,12(r4)
  187df4:	19000215 	stw	r4,8(r3)
  187df8:	00c00674 	movhi	r3,25
  187dfc:	18ea8c04 	addi	r3,r3,-21968
  187e00:	18c00017 	ldw	r3,0(r3)
  187e04:	11000054 	ori	r4,r2,1
  187e08:	31000115 	stw	r4,4(r6)
  187e0c:	29800215 	stw	r6,8(r5)
  187e10:	10ffb736 	bltu	r2,r3,187cf0 <_free_r+0x104>
  187e14:	00800674 	movhi	r2,25
  187e18:	10b15d04 	addi	r2,r2,-14988
  187e1c:	11400017 	ldw	r5,0(r2)
  187e20:	8809883a 	mov	r4,r17
  187e24:	0187ab00 	call	187ab0 <_malloc_trim_r>
  187e28:	003fb106 	br	187cf0 <_free_r+0x104>
  187e2c:	01000044 	movi	r4,1
  187e30:	003f8606 	br	187c4c <_free_r+0x60>
  187e34:	01000504 	movi	r4,20
  187e38:	20c00b36 	bltu	r4,r3,187e68 <_free_r+0x27c>
  187e3c:	190016c4 	addi	r4,r3,91
  187e40:	210f883a 	add	r7,r4,r4
  187e44:	003f9806 	br	187ca8 <_free_r+0xbc>
  187e48:	2009d0ba 	srai	r4,r4,2
  187e4c:	00800044 	movi	r2,1
  187e50:	29c00117 	ldw	r7,4(r5)
  187e54:	1108983a 	sll	r4,r2,r4
  187e58:	1805883a 	mov	r2,r3
  187e5c:	21c8b03a 	or	r4,r4,r7
  187e60:	29000115 	stw	r4,4(r5)
  187e64:	003f9e06 	br	187ce0 <_free_r+0xf4>
  187e68:	01001504 	movi	r4,84
  187e6c:	20c00436 	bltu	r4,r3,187e80 <_free_r+0x294>
  187e70:	1008d33a 	srli	r4,r2,12
  187e74:	21001b84 	addi	r4,r4,110
  187e78:	210f883a 	add	r7,r4,r4
  187e7c:	003f8a06 	br	187ca8 <_free_r+0xbc>
  187e80:	01005504 	movi	r4,340
  187e84:	20c00436 	bltu	r4,r3,187e98 <_free_r+0x2ac>
  187e88:	1008d3fa 	srli	r4,r2,15
  187e8c:	21001dc4 	addi	r4,r4,119
  187e90:	210f883a 	add	r7,r4,r4
  187e94:	003f8406 	br	187ca8 <_free_r+0xbc>
  187e98:	01015504 	movi	r4,1364
  187e9c:	20c00436 	bltu	r4,r3,187eb0 <_free_r+0x2c4>
  187ea0:	1008d4ba 	srli	r4,r2,18
  187ea4:	21001f04 	addi	r4,r4,124
  187ea8:	210f883a 	add	r7,r4,r4
  187eac:	003f7e06 	br	187ca8 <_free_r+0xbc>
  187eb0:	01c03f04 	movi	r7,252
  187eb4:	01001f84 	movi	r4,126
  187eb8:	003f7b06 	br	187ca8 <_free_r+0xbc>

00187ebc <_fwalk>:
  187ebc:	defff904 	addi	sp,sp,-28
  187ec0:	dcc00315 	stw	r19,12(sp)
  187ec4:	24c0b804 	addi	r19,r4,736
  187ec8:	dd400515 	stw	r21,20(sp)
  187ecc:	dd000415 	stw	r20,16(sp)
  187ed0:	dfc00615 	stw	ra,24(sp)
  187ed4:	dc800215 	stw	r18,8(sp)
  187ed8:	dc400115 	stw	r17,4(sp)
  187edc:	dc000015 	stw	r16,0(sp)
  187ee0:	282b883a 	mov	r21,r5
  187ee4:	0029883a 	mov	r20,zero
  187ee8:	0187a700 	call	187a70 <__sfp_lock_acquire>
  187eec:	98001226 	beq	r19,zero,187f38 <_fwalk+0x7c>
  187ef0:	04bfffc4 	movi	r18,-1
  187ef4:	9c400117 	ldw	r17,4(r19)
  187ef8:	9c000217 	ldw	r16,8(r19)
  187efc:	8c7fffc4 	addi	r17,r17,-1
  187f00:	88000b16 	blt	r17,zero,187f30 <_fwalk+0x74>
  187f04:	84000304 	addi	r16,r16,12
  187f08:	80c0000f 	ldh	r3,0(r16)
  187f0c:	8c7fffc4 	addi	r17,r17,-1
  187f10:	813ffd04 	addi	r4,r16,-12
  187f14:	18000426 	beq	r3,zero,187f28 <_fwalk+0x6c>
  187f18:	80c0008f 	ldh	r3,2(r16)
  187f1c:	1c800226 	beq	r3,r18,187f28 <_fwalk+0x6c>
  187f20:	a83ee83a 	callr	r21
  187f24:	a0a8b03a 	or	r20,r20,r2
  187f28:	84001704 	addi	r16,r16,92
  187f2c:	8cbff61e 	bne	r17,r18,187f08 <_fwalk+0x4c>
  187f30:	9cc00017 	ldw	r19,0(r19)
  187f34:	983fef1e 	bne	r19,zero,187ef4 <_fwalk+0x38>
  187f38:	0187a740 	call	187a74 <__sfp_lock_release>
  187f3c:	a005883a 	mov	r2,r20
  187f40:	dfc00617 	ldw	ra,24(sp)
  187f44:	dd400517 	ldw	r21,20(sp)
  187f48:	dd000417 	ldw	r20,16(sp)
  187f4c:	dcc00317 	ldw	r19,12(sp)
  187f50:	dc800217 	ldw	r18,8(sp)
  187f54:	dc400117 	ldw	r17,4(sp)
  187f58:	dc000017 	ldw	r16,0(sp)
  187f5c:	dec00704 	addi	sp,sp,28
  187f60:	f800283a 	ret

00187f64 <_fwalk_reent>:
  187f64:	defff804 	addi	sp,sp,-32
  187f68:	dcc00315 	stw	r19,12(sp)
  187f6c:	24c0b804 	addi	r19,r4,736
  187f70:	dd800615 	stw	r22,24(sp)
  187f74:	dd400515 	stw	r21,20(sp)
  187f78:	dd000415 	stw	r20,16(sp)
  187f7c:	dfc00715 	stw	ra,28(sp)
  187f80:	dc800215 	stw	r18,8(sp)
  187f84:	dc400115 	stw	r17,4(sp)
  187f88:	dc000015 	stw	r16,0(sp)
  187f8c:	2029883a 	mov	r20,r4
  187f90:	282b883a 	mov	r21,r5
  187f94:	002d883a 	mov	r22,zero
  187f98:	0187a700 	call	187a70 <__sfp_lock_acquire>
  187f9c:	98001326 	beq	r19,zero,187fec <_fwalk_reent+0x88>
  187fa0:	04bfffc4 	movi	r18,-1
  187fa4:	9c400117 	ldw	r17,4(r19)
  187fa8:	9c000217 	ldw	r16,8(r19)
  187fac:	8c7fffc4 	addi	r17,r17,-1
  187fb0:	88000c16 	blt	r17,zero,187fe4 <_fwalk_reent+0x80>
  187fb4:	84000304 	addi	r16,r16,12
  187fb8:	80c0000f 	ldh	r3,0(r16)
  187fbc:	8c7fffc4 	addi	r17,r17,-1
  187fc0:	817ffd04 	addi	r5,r16,-12
  187fc4:	18000526 	beq	r3,zero,187fdc <_fwalk_reent+0x78>
  187fc8:	80c0008f 	ldh	r3,2(r16)
  187fcc:	a009883a 	mov	r4,r20
  187fd0:	1c800226 	beq	r3,r18,187fdc <_fwalk_reent+0x78>
  187fd4:	a83ee83a 	callr	r21
  187fd8:	b0acb03a 	or	r22,r22,r2
  187fdc:	84001704 	addi	r16,r16,92
  187fe0:	8cbff51e 	bne	r17,r18,187fb8 <_fwalk_reent+0x54>
  187fe4:	9cc00017 	ldw	r19,0(r19)
  187fe8:	983fee1e 	bne	r19,zero,187fa4 <_fwalk_reent+0x40>
  187fec:	0187a740 	call	187a74 <__sfp_lock_release>
  187ff0:	b005883a 	mov	r2,r22
  187ff4:	dfc00717 	ldw	ra,28(sp)
  187ff8:	dd800617 	ldw	r22,24(sp)
  187ffc:	dd400517 	ldw	r21,20(sp)
  188000:	dd000417 	ldw	r20,16(sp)
  188004:	dcc00317 	ldw	r19,12(sp)
  188008:	dc800217 	ldw	r18,8(sp)
  18800c:	dc400117 	ldw	r17,4(sp)
  188010:	dc000017 	ldw	r16,0(sp)
  188014:	dec00804 	addi	sp,sp,32
  188018:	f800283a 	ret

0018801c <__smakebuf_r>:
  18801c:	2880030b 	ldhu	r2,12(r5)
  188020:	deffed04 	addi	sp,sp,-76
  188024:	dc401015 	stw	r17,64(sp)
  188028:	10c0008c 	andi	r3,r2,2
  18802c:	18ffffcc 	andi	r3,r3,65535
  188030:	18e0001c 	xori	r3,r3,32768
  188034:	dc000f15 	stw	r16,60(sp)
  188038:	dfc01215 	stw	ra,72(sp)
  18803c:	dc801115 	stw	r18,68(sp)
  188040:	18e00004 	addi	r3,r3,-32768
  188044:	2821883a 	mov	r16,r5
  188048:	2023883a 	mov	r17,r4
  18804c:	1800381e 	bne	r3,zero,188130 <__smakebuf_r+0x114>
  188050:	2940038f 	ldh	r5,14(r5)
  188054:	28002d16 	blt	r5,zero,18810c <__smakebuf_r+0xf0>
  188058:	d80d883a 	mov	r6,sp
  18805c:	01886000 	call	188600 <_fstat_r>
  188060:	10002916 	blt	r2,zero,188108 <__smakebuf_r+0xec>
  188064:	d8800117 	ldw	r2,4(sp)
  188068:	00e00014 	movui	r3,32768
  18806c:	10bc000c 	andi	r2,r2,61440
  188070:	10c03c26 	beq	r2,r3,188164 <__smakebuf_r+0x148>
  188074:	80c0030b 	ldhu	r3,12(r16)
  188078:	18c20014 	ori	r3,r3,2048
  18807c:	80c0030d 	sth	r3,12(r16)
  188080:	00c80004 	movi	r3,8192
  188084:	10c00c1e 	bne	r2,r3,1880b8 <__smakebuf_r+0x9c>
  188088:	8140038f 	ldh	r5,14(r16)
  18808c:	8809883a 	mov	r4,r17
  188090:	01886680 	call	188668 <_isatty_r>
  188094:	10000826 	beq	r2,zero,1880b8 <__smakebuf_r+0x9c>
  188098:	80c0030b 	ldhu	r3,12(r16)
  18809c:	808010c4 	addi	r2,r16,67
  1880a0:	80800015 	stw	r2,0(r16)
  1880a4:	18c00054 	ori	r3,r3,1
  1880a8:	80800415 	stw	r2,16(r16)
  1880ac:	00800044 	movi	r2,1
  1880b0:	80c0030d 	sth	r3,12(r16)
  1880b4:	80800515 	stw	r2,20(r16)
  1880b8:	04810004 	movi	r18,1024
  1880bc:	8809883a 	mov	r4,r17
  1880c0:	900b883a 	mov	r5,r18
  1880c4:	0185bb40 	call	185bb4 <_malloc_r>
  1880c8:	10003026 	beq	r2,zero,18818c <__smakebuf_r+0x170>
  1880cc:	80c0030b 	ldhu	r3,12(r16)
  1880d0:	01000634 	movhi	r4,24
  1880d4:	211df504 	addi	r4,r4,30676
  1880d8:	89000f15 	stw	r4,60(r17)
  1880dc:	18c02014 	ori	r3,r3,128
  1880e0:	80c0030d 	sth	r3,12(r16)
  1880e4:	80800015 	stw	r2,0(r16)
  1880e8:	80800415 	stw	r2,16(r16)
  1880ec:	84800515 	stw	r18,20(r16)
  1880f0:	dfc01217 	ldw	ra,72(sp)
  1880f4:	dc801117 	ldw	r18,68(sp)
  1880f8:	dc401017 	ldw	r17,64(sp)
  1880fc:	dc000f17 	ldw	r16,60(sp)
  188100:	dec01304 	addi	sp,sp,76
  188104:	f800283a 	ret
  188108:	8080030b 	ldhu	r2,12(r16)
  18810c:	10c0200c 	andi	r3,r2,128
  188110:	18ffffcc 	andi	r3,r3,65535
  188114:	18e0001c 	xori	r3,r3,32768
  188118:	18e00004 	addi	r3,r3,-32768
  18811c:	18000f1e 	bne	r3,zero,18815c <__smakebuf_r+0x140>
  188120:	04810004 	movi	r18,1024
  188124:	10820014 	ori	r2,r2,2048
  188128:	8080030d 	sth	r2,12(r16)
  18812c:	003fe306 	br	1880bc <__smakebuf_r+0xa0>
  188130:	288010c4 	addi	r2,r5,67
  188134:	28800015 	stw	r2,0(r5)
  188138:	28800415 	stw	r2,16(r5)
  18813c:	00800044 	movi	r2,1
  188140:	28800515 	stw	r2,20(r5)
  188144:	dfc01217 	ldw	ra,72(sp)
  188148:	dc801117 	ldw	r18,68(sp)
  18814c:	dc401017 	ldw	r17,64(sp)
  188150:	dc000f17 	ldw	r16,60(sp)
  188154:	dec01304 	addi	sp,sp,76
  188158:	f800283a 	ret
  18815c:	04801004 	movi	r18,64
  188160:	003ff006 	br	188124 <__smakebuf_r+0x108>
  188164:	81000a17 	ldw	r4,40(r16)
  188168:	00c00674 	movhi	r3,25
  18816c:	18e0df04 	addi	r3,r3,-31876
  188170:	20ffc01e 	bne	r4,r3,188074 <__smakebuf_r+0x58>
  188174:	8080030b 	ldhu	r2,12(r16)
  188178:	00c10004 	movi	r3,1024
  18817c:	80c01315 	stw	r3,76(r16)
  188180:	10c4b03a 	or	r2,r2,r3
  188184:	8080030d 	sth	r2,12(r16)
  188188:	003fcb06 	br	1880b8 <__smakebuf_r+0x9c>
  18818c:	8080030b 	ldhu	r2,12(r16)
  188190:	10c0800c 	andi	r3,r2,512
  188194:	18ffffcc 	andi	r3,r3,65535
  188198:	18e0001c 	xori	r3,r3,32768
  18819c:	18e00004 	addi	r3,r3,-32768
  1881a0:	183fd31e 	bne	r3,zero,1880f0 <__smakebuf_r+0xd4>
  1881a4:	10800094 	ori	r2,r2,2
  1881a8:	80c010c4 	addi	r3,r16,67
  1881ac:	8080030d 	sth	r2,12(r16)
  1881b0:	00800044 	movi	r2,1
  1881b4:	80c00015 	stw	r3,0(r16)
  1881b8:	80c00415 	stw	r3,16(r16)
  1881bc:	80800515 	stw	r2,20(r16)
  1881c0:	003fcb06 	br	1880f0 <__smakebuf_r+0xd4>

001881c4 <memset>:
  1881c4:	00c000c4 	movi	r3,3
  1881c8:	2005883a 	mov	r2,r4
  1881cc:	29403fcc 	andi	r5,r5,255
  1881d0:	19802d2e 	bgeu	r3,r6,188288 <memset+0xc4>
  1881d4:	20c6703a 	and	r3,r4,r3
  1881d8:	18002e1e 	bne	r3,zero,188294 <memset+0xd0>
  1881dc:	2806923a 	slli	r3,r5,8
  1881e0:	010003c4 	movi	r4,15
  1881e4:	3011883a 	mov	r8,r6
  1881e8:	1946b03a 	or	r3,r3,r5
  1881ec:	180e943a 	slli	r7,r3,16
  1881f0:	38ceb03a 	or	r7,r7,r3
  1881f4:	1007883a 	mov	r3,r2
  1881f8:	21800f2e 	bgeu	r4,r6,188238 <memset+0x74>
  1881fc:	19c00015 	stw	r7,0(r3)
  188200:	19c00115 	stw	r7,4(r3)
  188204:	19c00215 	stw	r7,8(r3)
  188208:	19c00315 	stw	r7,12(r3)
  18820c:	423ffc04 	addi	r8,r8,-16
  188210:	18c00404 	addi	r3,r3,16
  188214:	223ff936 	bltu	r4,r8,1881fc <memset+0x38>
  188218:	30fffc04 	addi	r3,r6,-16
  18821c:	1806d13a 	srli	r3,r3,4
  188220:	318003cc 	andi	r6,r6,15
  188224:	010000c4 	movi	r4,3
  188228:	18c00044 	addi	r3,r3,1
  18822c:	1806913a 	slli	r3,r3,4
  188230:	10c7883a 	add	r3,r2,r3
  188234:	21800e2e 	bgeu	r4,r6,188270 <memset+0xac>
  188238:	1813883a 	mov	r9,r3
  18823c:	3011883a 	mov	r8,r6
  188240:	010000c4 	movi	r4,3
  188244:	49c00015 	stw	r7,0(r9)
  188248:	423fff04 	addi	r8,r8,-4
  18824c:	4a400104 	addi	r9,r9,4
  188250:	223ffc36 	bltu	r4,r8,188244 <memset+0x80>
  188254:	313fff04 	addi	r4,r6,-4
  188258:	2008d0ba 	srli	r4,r4,2
  18825c:	318000cc 	andi	r6,r6,3
  188260:	21000044 	addi	r4,r4,1
  188264:	2109883a 	add	r4,r4,r4
  188268:	2109883a 	add	r4,r4,r4
  18826c:	1907883a 	add	r3,r3,r4
  188270:	30000a26 	beq	r6,zero,18829c <memset+0xd8>
  188274:	198d883a 	add	r6,r3,r6
  188278:	19400005 	stb	r5,0(r3)
  18827c:	18c00044 	addi	r3,r3,1
  188280:	19bffd1e 	bne	r3,r6,188278 <memset+0xb4>
  188284:	f800283a 	ret
  188288:	2007883a 	mov	r3,r4
  18828c:	303ff91e 	bne	r6,zero,188274 <memset+0xb0>
  188290:	00000206 	br	18829c <memset+0xd8>
  188294:	2007883a 	mov	r3,r4
  188298:	003ff606 	br	188274 <memset+0xb0>
  18829c:	f800283a 	ret

001882a0 <__sread>:
  1882a0:	defffe04 	addi	sp,sp,-8
  1882a4:	dc000015 	stw	r16,0(sp)
  1882a8:	2821883a 	mov	r16,r5
  1882ac:	2940038f 	ldh	r5,14(r5)
  1882b0:	dfc00115 	stw	ra,4(sp)
  1882b4:	01887380 	call	188738 <_read_r>
  1882b8:	10000716 	blt	r2,zero,1882d8 <__sread+0x38>
  1882bc:	80c01417 	ldw	r3,80(r16)
  1882c0:	1887883a 	add	r3,r3,r2
  1882c4:	80c01415 	stw	r3,80(r16)
  1882c8:	dfc00117 	ldw	ra,4(sp)
  1882cc:	dc000017 	ldw	r16,0(sp)
  1882d0:	dec00204 	addi	sp,sp,8
  1882d4:	f800283a 	ret
  1882d8:	80c0030b 	ldhu	r3,12(r16)
  1882dc:	18fbffcc 	andi	r3,r3,61439
  1882e0:	80c0030d 	sth	r3,12(r16)
  1882e4:	dfc00117 	ldw	ra,4(sp)
  1882e8:	dc000017 	ldw	r16,0(sp)
  1882ec:	dec00204 	addi	sp,sp,8
  1882f0:	f800283a 	ret

001882f4 <__swrite>:
  1882f4:	2880030b 	ldhu	r2,12(r5)
  1882f8:	defffb04 	addi	sp,sp,-20
  1882fc:	dcc00315 	stw	r19,12(sp)
  188300:	10c0400c 	andi	r3,r2,256
  188304:	18ffffcc 	andi	r3,r3,65535
  188308:	18e0001c 	xori	r3,r3,32768
  18830c:	dc800215 	stw	r18,8(sp)
  188310:	dc400115 	stw	r17,4(sp)
  188314:	dc000015 	stw	r16,0(sp)
  188318:	dfc00415 	stw	ra,16(sp)
  18831c:	18e00004 	addi	r3,r3,-32768
  188320:	2821883a 	mov	r16,r5
  188324:	2027883a 	mov	r19,r4
  188328:	3025883a 	mov	r18,r6
  18832c:	3823883a 	mov	r17,r7
  188330:	18000526 	beq	r3,zero,188348 <__swrite+0x54>
  188334:	2940038f 	ldh	r5,14(r5)
  188338:	000d883a 	mov	r6,zero
  18833c:	01c00084 	movi	r7,2
  188340:	01886cc0 	call	1886cc <_lseek_r>
  188344:	8080030b 	ldhu	r2,12(r16)
  188348:	8140038f 	ldh	r5,14(r16)
  18834c:	10bbffcc 	andi	r2,r2,61439
  188350:	9809883a 	mov	r4,r19
  188354:	900d883a 	mov	r6,r18
  188358:	880f883a 	mov	r7,r17
  18835c:	8080030d 	sth	r2,12(r16)
  188360:	dfc00417 	ldw	ra,16(sp)
  188364:	dcc00317 	ldw	r19,12(sp)
  188368:	dc800217 	ldw	r18,8(sp)
  18836c:	dc400117 	ldw	r17,4(sp)
  188370:	dc000017 	ldw	r16,0(sp)
  188374:	dec00504 	addi	sp,sp,20
  188378:	01883e01 	jmpi	1883e0 <_write_r>

0018837c <__sseek>:
  18837c:	defffe04 	addi	sp,sp,-8
  188380:	dc000015 	stw	r16,0(sp)
  188384:	2821883a 	mov	r16,r5
  188388:	2940038f 	ldh	r5,14(r5)
  18838c:	dfc00115 	stw	ra,4(sp)
  188390:	01886cc0 	call	1886cc <_lseek_r>
  188394:	00ffffc4 	movi	r3,-1
  188398:	10c00826 	beq	r2,r3,1883bc <__sseek+0x40>
  18839c:	80c0030b 	ldhu	r3,12(r16)
  1883a0:	80801415 	stw	r2,80(r16)
  1883a4:	18c40014 	ori	r3,r3,4096
  1883a8:	80c0030d 	sth	r3,12(r16)
  1883ac:	dfc00117 	ldw	ra,4(sp)
  1883b0:	dc000017 	ldw	r16,0(sp)
  1883b4:	dec00204 	addi	sp,sp,8
  1883b8:	f800283a 	ret
  1883bc:	80c0030b 	ldhu	r3,12(r16)
  1883c0:	18fbffcc 	andi	r3,r3,61439
  1883c4:	80c0030d 	sth	r3,12(r16)
  1883c8:	dfc00117 	ldw	ra,4(sp)
  1883cc:	dc000017 	ldw	r16,0(sp)
  1883d0:	dec00204 	addi	sp,sp,8
  1883d4:	f800283a 	ret

001883d8 <__sclose>:
  1883d8:	2940038f 	ldh	r5,14(r5)
  1883dc:	018844c1 	jmpi	18844c <_close_r>

001883e0 <_write_r>:
  1883e0:	defffd04 	addi	sp,sp,-12
  1883e4:	dc400115 	stw	r17,4(sp)
  1883e8:	dc000015 	stw	r16,0(sp)
  1883ec:	2023883a 	mov	r17,r4
  1883f0:	04000674 	movhi	r16,25
  1883f4:	84315a04 	addi	r16,r16,-15000
  1883f8:	2809883a 	mov	r4,r5
  1883fc:	300b883a 	mov	r5,r6
  188400:	380d883a 	mov	r6,r7
  188404:	dfc00215 	stw	ra,8(sp)
  188408:	80000015 	stw	zero,0(r16)
  18840c:	0188d800 	call	188d80 <write>
  188410:	00ffffc4 	movi	r3,-1
  188414:	10c00526 	beq	r2,r3,18842c <_write_r+0x4c>
  188418:	dfc00217 	ldw	ra,8(sp)
  18841c:	dc400117 	ldw	r17,4(sp)
  188420:	dc000017 	ldw	r16,0(sp)
  188424:	dec00304 	addi	sp,sp,12
  188428:	f800283a 	ret
  18842c:	80c00017 	ldw	r3,0(r16)
  188430:	183ff926 	beq	r3,zero,188418 <_write_r+0x38>
  188434:	88c00015 	stw	r3,0(r17)
  188438:	dfc00217 	ldw	ra,8(sp)
  18843c:	dc400117 	ldw	r17,4(sp)
  188440:	dc000017 	ldw	r16,0(sp)
  188444:	dec00304 	addi	sp,sp,12
  188448:	f800283a 	ret

0018844c <_close_r>:
  18844c:	defffd04 	addi	sp,sp,-12
  188450:	dc400115 	stw	r17,4(sp)
  188454:	dc000015 	stw	r16,0(sp)
  188458:	2023883a 	mov	r17,r4
  18845c:	04000674 	movhi	r16,25
  188460:	84315a04 	addi	r16,r16,-15000
  188464:	2809883a 	mov	r4,r5
  188468:	dfc00215 	stw	ra,8(sp)
  18846c:	80000015 	stw	zero,0(r16)
  188470:	01846580 	call	184658 <close>
  188474:	00ffffc4 	movi	r3,-1
  188478:	10c00526 	beq	r2,r3,188490 <_close_r+0x44>
  18847c:	dfc00217 	ldw	ra,8(sp)
  188480:	dc400117 	ldw	r17,4(sp)
  188484:	dc000017 	ldw	r16,0(sp)
  188488:	dec00304 	addi	sp,sp,12
  18848c:	f800283a 	ret
  188490:	80c00017 	ldw	r3,0(r16)
  188494:	183ff926 	beq	r3,zero,18847c <_close_r+0x30>
  188498:	88c00015 	stw	r3,0(r17)
  18849c:	dfc00217 	ldw	ra,8(sp)
  1884a0:	dc400117 	ldw	r17,4(sp)
  1884a4:	dc000017 	ldw	r16,0(sp)
  1884a8:	dec00304 	addi	sp,sp,12
  1884ac:	f800283a 	ret

001884b0 <_fclose_r>:
  1884b0:	defffc04 	addi	sp,sp,-16
  1884b4:	dc400115 	stw	r17,4(sp)
  1884b8:	dc000015 	stw	r16,0(sp)
  1884bc:	dfc00315 	stw	ra,12(sp)
  1884c0:	dc800215 	stw	r18,8(sp)
  1884c4:	2821883a 	mov	r16,r5
  1884c8:	2023883a 	mov	r17,r4
  1884cc:	28003426 	beq	r5,zero,1885a0 <_fclose_r+0xf0>
  1884d0:	0187a700 	call	187a70 <__sfp_lock_acquire>
  1884d4:	88000226 	beq	r17,zero,1884e0 <_fclose_r+0x30>
  1884d8:	88800e17 	ldw	r2,56(r17)
  1884dc:	10003826 	beq	r2,zero,1885c0 <_fclose_r+0x110>
  1884e0:	8080030f 	ldh	r2,12(r16)
  1884e4:	10002526 	beq	r2,zero,18857c <_fclose_r+0xcc>
  1884e8:	8809883a 	mov	r4,r17
  1884ec:	800b883a 	mov	r5,r16
  1884f0:	01875ac0 	call	1875ac <_fflush_r>
  1884f4:	1025883a 	mov	r18,r2
  1884f8:	80800b17 	ldw	r2,44(r16)
  1884fc:	10000426 	beq	r2,zero,188510 <_fclose_r+0x60>
  188500:	81400717 	ldw	r5,28(r16)
  188504:	8809883a 	mov	r4,r17
  188508:	103ee83a 	callr	r2
  18850c:	10003516 	blt	r2,zero,1885e4 <_fclose_r+0x134>
  188510:	8080030b 	ldhu	r2,12(r16)
  188514:	1080200c 	andi	r2,r2,128
  188518:	10bfffcc 	andi	r2,r2,65535
  18851c:	10a0001c 	xori	r2,r2,32768
  188520:	10a00004 	addi	r2,r2,-32768
  188524:	10002b1e 	bne	r2,zero,1885d4 <_fclose_r+0x124>
  188528:	81400c17 	ldw	r5,48(r16)
  18852c:	28000526 	beq	r5,zero,188544 <_fclose_r+0x94>
  188530:	80801004 	addi	r2,r16,64
  188534:	28800226 	beq	r5,r2,188540 <_fclose_r+0x90>
  188538:	8809883a 	mov	r4,r17
  18853c:	0187bec0 	call	187bec <_free_r>
  188540:	80000c15 	stw	zero,48(r16)
  188544:	81401117 	ldw	r5,68(r16)
  188548:	28000326 	beq	r5,zero,188558 <_fclose_r+0xa8>
  18854c:	8809883a 	mov	r4,r17
  188550:	0187bec0 	call	187bec <_free_r>
  188554:	80001115 	stw	zero,68(r16)
  188558:	8000030d 	sth	zero,12(r16)
  18855c:	0187a740 	call	187a74 <__sfp_lock_release>
  188560:	9005883a 	mov	r2,r18
  188564:	dfc00317 	ldw	ra,12(sp)
  188568:	dc800217 	ldw	r18,8(sp)
  18856c:	dc400117 	ldw	r17,4(sp)
  188570:	dc000017 	ldw	r16,0(sp)
  188574:	dec00404 	addi	sp,sp,16
  188578:	f800283a 	ret
  18857c:	0187a740 	call	187a74 <__sfp_lock_release>
  188580:	0025883a 	mov	r18,zero
  188584:	9005883a 	mov	r2,r18
  188588:	dfc00317 	ldw	ra,12(sp)
  18858c:	dc800217 	ldw	r18,8(sp)
  188590:	dc400117 	ldw	r17,4(sp)
  188594:	dc000017 	ldw	r16,0(sp)
  188598:	dec00404 	addi	sp,sp,16
  18859c:	f800283a 	ret
  1885a0:	0025883a 	mov	r18,zero
  1885a4:	9005883a 	mov	r2,r18
  1885a8:	dfc00317 	ldw	ra,12(sp)
  1885ac:	dc800217 	ldw	r18,8(sp)
  1885b0:	dc400117 	ldw	r17,4(sp)
  1885b4:	dc000017 	ldw	r16,0(sp)
  1885b8:	dec00404 	addi	sp,sp,16
  1885bc:	f800283a 	ret
  1885c0:	8809883a 	mov	r4,r17
  1885c4:	01878680 	call	187868 <__sinit>
  1885c8:	8080030f 	ldh	r2,12(r16)
  1885cc:	103fc61e 	bne	r2,zero,1884e8 <_fclose_r+0x38>
  1885d0:	003fea06 	br	18857c <_fclose_r+0xcc>
  1885d4:	81400417 	ldw	r5,16(r16)
  1885d8:	8809883a 	mov	r4,r17
  1885dc:	0187bec0 	call	187bec <_free_r>
  1885e0:	003fd106 	br	188528 <_fclose_r+0x78>
  1885e4:	04bfffc4 	movi	r18,-1
  1885e8:	003fc906 	br	188510 <_fclose_r+0x60>

001885ec <fclose>:
  1885ec:	00800674 	movhi	r2,25
  1885f0:	10aa8a04 	addi	r2,r2,-21976
  1885f4:	200b883a 	mov	r5,r4
  1885f8:	11000017 	ldw	r4,0(r2)
  1885fc:	01884b01 	jmpi	1884b0 <_fclose_r>

00188600 <_fstat_r>:
  188600:	defffd04 	addi	sp,sp,-12
  188604:	dc400115 	stw	r17,4(sp)
  188608:	dc000015 	stw	r16,0(sp)
  18860c:	2023883a 	mov	r17,r4
  188610:	04000674 	movhi	r16,25
  188614:	84315a04 	addi	r16,r16,-15000
  188618:	2809883a 	mov	r4,r5
  18861c:	300b883a 	mov	r5,r6
  188620:	dfc00215 	stw	ra,8(sp)
  188624:	80000015 	stw	zero,0(r16)
  188628:	01888340 	call	188834 <fstat>
  18862c:	00ffffc4 	movi	r3,-1
  188630:	10c00526 	beq	r2,r3,188648 <_fstat_r+0x48>
  188634:	dfc00217 	ldw	ra,8(sp)
  188638:	dc400117 	ldw	r17,4(sp)
  18863c:	dc000017 	ldw	r16,0(sp)
  188640:	dec00304 	addi	sp,sp,12
  188644:	f800283a 	ret
  188648:	80c00017 	ldw	r3,0(r16)
  18864c:	183ff926 	beq	r3,zero,188634 <_fstat_r+0x34>
  188650:	88c00015 	stw	r3,0(r17)
  188654:	dfc00217 	ldw	ra,8(sp)
  188658:	dc400117 	ldw	r17,4(sp)
  18865c:	dc000017 	ldw	r16,0(sp)
  188660:	dec00304 	addi	sp,sp,12
  188664:	f800283a 	ret

00188668 <_isatty_r>:
  188668:	defffd04 	addi	sp,sp,-12
  18866c:	dc400115 	stw	r17,4(sp)
  188670:	dc000015 	stw	r16,0(sp)
  188674:	2023883a 	mov	r17,r4
  188678:	04000674 	movhi	r16,25
  18867c:	84315a04 	addi	r16,r16,-15000
  188680:	2809883a 	mov	r4,r5
  188684:	dfc00215 	stw	ra,8(sp)
  188688:	80000015 	stw	zero,0(r16)
  18868c:	01889340 	call	188934 <isatty>
  188690:	00ffffc4 	movi	r3,-1
  188694:	10c00526 	beq	r2,r3,1886ac <_isatty_r+0x44>
  188698:	dfc00217 	ldw	ra,8(sp)
  18869c:	dc400117 	ldw	r17,4(sp)
  1886a0:	dc000017 	ldw	r16,0(sp)
  1886a4:	dec00304 	addi	sp,sp,12
  1886a8:	f800283a 	ret
  1886ac:	80c00017 	ldw	r3,0(r16)
  1886b0:	183ff926 	beq	r3,zero,188698 <_isatty_r+0x30>
  1886b4:	88c00015 	stw	r3,0(r17)
  1886b8:	dfc00217 	ldw	ra,8(sp)
  1886bc:	dc400117 	ldw	r17,4(sp)
  1886c0:	dc000017 	ldw	r16,0(sp)
  1886c4:	dec00304 	addi	sp,sp,12
  1886c8:	f800283a 	ret

001886cc <_lseek_r>:
  1886cc:	defffd04 	addi	sp,sp,-12
  1886d0:	dc400115 	stw	r17,4(sp)
  1886d4:	dc000015 	stw	r16,0(sp)
  1886d8:	2023883a 	mov	r17,r4
  1886dc:	04000674 	movhi	r16,25
  1886e0:	84315a04 	addi	r16,r16,-15000
  1886e4:	2809883a 	mov	r4,r5
  1886e8:	300b883a 	mov	r5,r6
  1886ec:	380d883a 	mov	r6,r7
  1886f0:	dfc00215 	stw	ra,8(sp)
  1886f4:	80000015 	stw	zero,0(r16)
  1886f8:	0188a280 	call	188a28 <lseek>
  1886fc:	00ffffc4 	movi	r3,-1
  188700:	10c00526 	beq	r2,r3,188718 <_lseek_r+0x4c>
  188704:	dfc00217 	ldw	ra,8(sp)
  188708:	dc400117 	ldw	r17,4(sp)
  18870c:	dc000017 	ldw	r16,0(sp)
  188710:	dec00304 	addi	sp,sp,12
  188714:	f800283a 	ret
  188718:	80c00017 	ldw	r3,0(r16)
  18871c:	183ff926 	beq	r3,zero,188704 <_lseek_r+0x38>
  188720:	88c00015 	stw	r3,0(r17)
  188724:	dfc00217 	ldw	ra,8(sp)
  188728:	dc400117 	ldw	r17,4(sp)
  18872c:	dc000017 	ldw	r16,0(sp)
  188730:	dec00304 	addi	sp,sp,12
  188734:	f800283a 	ret

00188738 <_read_r>:
  188738:	defffd04 	addi	sp,sp,-12
  18873c:	dc400115 	stw	r17,4(sp)
  188740:	dc000015 	stw	r16,0(sp)
  188744:	2023883a 	mov	r17,r4
  188748:	04000674 	movhi	r16,25
  18874c:	84315a04 	addi	r16,r16,-15000
  188750:	2809883a 	mov	r4,r5
  188754:	300b883a 	mov	r5,r6
  188758:	380d883a 	mov	r6,r7
  18875c:	dfc00215 	stw	ra,8(sp)
  188760:	80000015 	stw	zero,0(r16)
  188764:	0188b8c0 	call	188b8c <read>
  188768:	00ffffc4 	movi	r3,-1
  18876c:	10c00526 	beq	r2,r3,188784 <_read_r+0x4c>
  188770:	dfc00217 	ldw	ra,8(sp)
  188774:	dc400117 	ldw	r17,4(sp)
  188778:	dc000017 	ldw	r16,0(sp)
  18877c:	dec00304 	addi	sp,sp,12
  188780:	f800283a 	ret
  188784:	80c00017 	ldw	r3,0(r16)
  188788:	183ff926 	beq	r3,zero,188770 <_read_r+0x38>
  18878c:	88c00015 	stw	r3,0(r17)
  188790:	dfc00217 	ldw	ra,8(sp)
  188794:	dc400117 	ldw	r17,4(sp)
  188798:	dc000017 	ldw	r16,0(sp)
  18879c:	dec00304 	addi	sp,sp,12
  1887a0:	f800283a 	ret

001887a4 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
  1887a4:	defffb04 	addi	sp,sp,-20
  1887a8:	dfc00415 	stw	ra,16(sp)
  1887ac:	df000315 	stw	fp,12(sp)
  1887b0:	df000304 	addi	fp,sp,12
  1887b4:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
  1887b8:	018532c0 	call	18532c <port_halt>
  1887bc:	e0bfff17 	ldw	r2,-4(fp)
  1887c0:	e0bffd15 	stw	r2,-12(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  int r2 = exit_code;
  1887c4:	e0bffd17 	ldw	r2,-12(fp)
  1887c8:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
  1887cc:	e0bffe17 	ldw	r2,-8(fp)
  1887d0:	10000226 	beq	r2,zero,1887dc <_exit+0x38>
    ALT_SIM_FAIL();
  1887d4:	002af070 	cmpltui	zero,zero,43969
  1887d8:	00000106 	br	1887e0 <_exit+0x3c>
  } else {
    ALT_SIM_PASS();
  1887dc:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
  1887e0:	003fff06 	br	1887e0 <_exit+0x3c>

001887e4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  1887e4:	defffe04 	addi	sp,sp,-8
  1887e8:	dfc00115 	stw	ra,4(sp)
  1887ec:	df000015 	stw	fp,0(sp)
  1887f0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  1887f4:	00800674 	movhi	r2,25
  1887f8:	10aa8504 	addi	r2,r2,-21996
  1887fc:	10800017 	ldw	r2,0(r2)
  188800:	10000526 	beq	r2,zero,188818 <alt_get_errno+0x34>
  188804:	00800674 	movhi	r2,25
  188808:	10aa8504 	addi	r2,r2,-21996
  18880c:	10800017 	ldw	r2,0(r2)
  188810:	103ee83a 	callr	r2
  188814:	00000206 	br	188820 <alt_get_errno+0x3c>
  188818:	00800674 	movhi	r2,25
  18881c:	10b15a04 	addi	r2,r2,-15000
}
  188820:	e037883a 	mov	sp,fp
  188824:	dfc00117 	ldw	ra,4(sp)
  188828:	df000017 	ldw	fp,0(sp)
  18882c:	dec00204 	addi	sp,sp,8
  188830:	f800283a 	ret

00188834 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
  188834:	defffb04 	addi	sp,sp,-20
  188838:	dfc00415 	stw	ra,16(sp)
  18883c:	df000315 	stw	fp,12(sp)
  188840:	df000304 	addi	fp,sp,12
  188844:	e13ffe15 	stw	r4,-8(fp)
  188848:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  18884c:	e0bffe17 	ldw	r2,-8(fp)
  188850:	10000716 	blt	r2,zero,188870 <fstat+0x3c>
  188854:	e13ffe17 	ldw	r4,-8(fp)
  188858:	01400304 	movi	r5,12
  18885c:	01805f00 	call	1805f0 <__mulsi3>
  188860:	00c00674 	movhi	r3,25
  188864:	18e81e04 	addi	r3,r3,-24456
  188868:	10c5883a 	add	r2,r2,r3
  18886c:	00000106 	br	188874 <fstat+0x40>
  188870:	0005883a 	mov	r2,zero
  188874:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
  188878:	e0bffd17 	ldw	r2,-12(fp)
  18887c:	10001026 	beq	r2,zero,1888c0 <fstat+0x8c>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
  188880:	e0bffd17 	ldw	r2,-12(fp)
  188884:	10800017 	ldw	r2,0(r2)
  188888:	10800817 	ldw	r2,32(r2)
  18888c:	10000726 	beq	r2,zero,1888ac <fstat+0x78>
    {
      return fd->dev->fstat(fd, st);
  188890:	e0bffd17 	ldw	r2,-12(fp)
  188894:	10800017 	ldw	r2,0(r2)
  188898:	10800817 	ldw	r2,32(r2)
  18889c:	e13ffd17 	ldw	r4,-12(fp)
  1888a0:	e17fff17 	ldw	r5,-4(fp)
  1888a4:	103ee83a 	callr	r2
  1888a8:	00000906 	br	1888d0 <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
  1888ac:	e0bfff17 	ldw	r2,-4(fp)
  1888b0:	00c80004 	movi	r3,8192
  1888b4:	10c00115 	stw	r3,4(r2)
      return 0;
  1888b8:	0005883a 	mov	r2,zero
  1888bc:	00000406 	br	1888d0 <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
  1888c0:	01887e40 	call	1887e4 <alt_get_errno>
  1888c4:	00c01444 	movi	r3,81
  1888c8:	10c00015 	stw	r3,0(r2)
    return -1;
  1888cc:	00bfffc4 	movi	r2,-1
  }
}
  1888d0:	e037883a 	mov	sp,fp
  1888d4:	dfc00117 	ldw	ra,4(sp)
  1888d8:	df000017 	ldw	fp,0(sp)
  1888dc:	dec00204 	addi	sp,sp,8
  1888e0:	f800283a 	ret

001888e4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  1888e4:	defffe04 	addi	sp,sp,-8
  1888e8:	dfc00115 	stw	ra,4(sp)
  1888ec:	df000015 	stw	fp,0(sp)
  1888f0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  1888f4:	00800674 	movhi	r2,25
  1888f8:	10aa8504 	addi	r2,r2,-21996
  1888fc:	10800017 	ldw	r2,0(r2)
  188900:	10000526 	beq	r2,zero,188918 <alt_get_errno+0x34>
  188904:	00800674 	movhi	r2,25
  188908:	10aa8504 	addi	r2,r2,-21996
  18890c:	10800017 	ldw	r2,0(r2)
  188910:	103ee83a 	callr	r2
  188914:	00000206 	br	188920 <alt_get_errno+0x3c>
  188918:	00800674 	movhi	r2,25
  18891c:	10b15a04 	addi	r2,r2,-15000
}
  188920:	e037883a 	mov	sp,fp
  188924:	dfc00117 	ldw	ra,4(sp)
  188928:	df000017 	ldw	fp,0(sp)
  18892c:	dec00204 	addi	sp,sp,8
  188930:	f800283a 	ret

00188934 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
  188934:	deffed04 	addi	sp,sp,-76
  188938:	dfc01215 	stw	ra,72(sp)
  18893c:	df001115 	stw	fp,68(sp)
  188940:	df001104 	addi	fp,sp,68
  188944:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  188948:	e0bfff17 	ldw	r2,-4(fp)
  18894c:	10000716 	blt	r2,zero,18896c <isatty+0x38>
  188950:	e13fff17 	ldw	r4,-4(fp)
  188954:	01400304 	movi	r5,12
  188958:	01805f00 	call	1805f0 <__mulsi3>
  18895c:	00c00674 	movhi	r3,25
  188960:	18e81e04 	addi	r3,r3,-24456
  188964:	10c5883a 	add	r2,r2,r3
  188968:	00000106 	br	188970 <isatty+0x3c>
  18896c:	0005883a 	mov	r2,zero
  188970:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
  188974:	e0bfef17 	ldw	r2,-68(fp)
  188978:	10000e26 	beq	r2,zero,1889b4 <isatty+0x80>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
  18897c:	e0bfef17 	ldw	r2,-68(fp)
  188980:	10800017 	ldw	r2,0(r2)
  188984:	10800817 	ldw	r2,32(r2)
  188988:	1000021e 	bne	r2,zero,188994 <isatty+0x60>
    {
      return 1;
  18898c:	00800044 	movi	r2,1
  188990:	00000c06 	br	1889c4 <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
  188994:	e0bff004 	addi	r2,fp,-64
  188998:	e13fff17 	ldw	r4,-4(fp)
  18899c:	100b883a 	mov	r5,r2
  1889a0:	01888340 	call	188834 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
  1889a4:	e0bff117 	ldw	r2,-60(fp)
  1889a8:	10880020 	cmpeqi	r2,r2,8192
  1889ac:	10803fcc 	andi	r2,r2,255
  1889b0:	00000406 	br	1889c4 <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
  1889b4:	01888e40 	call	1888e4 <alt_get_errno>
  1889b8:	00c01444 	movi	r3,81
  1889bc:	10c00015 	stw	r3,0(r2)
    return 0;
  1889c0:	0005883a 	mov	r2,zero
  }
}
  1889c4:	e037883a 	mov	sp,fp
  1889c8:	dfc00117 	ldw	ra,4(sp)
  1889cc:	df000017 	ldw	fp,0(sp)
  1889d0:	dec00204 	addi	sp,sp,8
  1889d4:	f800283a 	ret

001889d8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  1889d8:	defffe04 	addi	sp,sp,-8
  1889dc:	dfc00115 	stw	ra,4(sp)
  1889e0:	df000015 	stw	fp,0(sp)
  1889e4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  1889e8:	00800674 	movhi	r2,25
  1889ec:	10aa8504 	addi	r2,r2,-21996
  1889f0:	10800017 	ldw	r2,0(r2)
  1889f4:	10000526 	beq	r2,zero,188a0c <alt_get_errno+0x34>
  1889f8:	00800674 	movhi	r2,25
  1889fc:	10aa8504 	addi	r2,r2,-21996
  188a00:	10800017 	ldw	r2,0(r2)
  188a04:	103ee83a 	callr	r2
  188a08:	00000206 	br	188a14 <alt_get_errno+0x3c>
  188a0c:	00800674 	movhi	r2,25
  188a10:	10b15a04 	addi	r2,r2,-15000
}
  188a14:	e037883a 	mov	sp,fp
  188a18:	dfc00117 	ldw	ra,4(sp)
  188a1c:	df000017 	ldw	fp,0(sp)
  188a20:	dec00204 	addi	sp,sp,8
  188a24:	f800283a 	ret

00188a28 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
  188a28:	defff904 	addi	sp,sp,-28
  188a2c:	dfc00615 	stw	ra,24(sp)
  188a30:	df000515 	stw	fp,20(sp)
  188a34:	df000504 	addi	fp,sp,20
  188a38:	e13ffd15 	stw	r4,-12(fp)
  188a3c:	e17ffe15 	stw	r5,-8(fp)
  188a40:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
  188a44:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  188a48:	e0bffd17 	ldw	r2,-12(fp)
  188a4c:	10000716 	blt	r2,zero,188a6c <lseek+0x44>
  188a50:	e13ffd17 	ldw	r4,-12(fp)
  188a54:	01400304 	movi	r5,12
  188a58:	01805f00 	call	1805f0 <__mulsi3>
  188a5c:	00c00674 	movhi	r3,25
  188a60:	18e81e04 	addi	r3,r3,-24456
  188a64:	10c5883a 	add	r2,r2,r3
  188a68:	00000106 	br	188a70 <lseek+0x48>
  188a6c:	0005883a 	mov	r2,zero
  188a70:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
  188a74:	e0bffc17 	ldw	r2,-16(fp)
  188a78:	10001026 	beq	r2,zero,188abc <lseek+0x94>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
  188a7c:	e0bffc17 	ldw	r2,-16(fp)
  188a80:	10800017 	ldw	r2,0(r2)
  188a84:	10800717 	ldw	r2,28(r2)
  188a88:	10000926 	beq	r2,zero,188ab0 <lseek+0x88>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
  188a8c:	e0bffc17 	ldw	r2,-16(fp)
  188a90:	10800017 	ldw	r2,0(r2)
  188a94:	10800717 	ldw	r2,28(r2)
  188a98:	e13ffc17 	ldw	r4,-16(fp)
  188a9c:	e17ffe17 	ldw	r5,-8(fp)
  188aa0:	e1bfff17 	ldw	r6,-4(fp)
  188aa4:	103ee83a 	callr	r2
  188aa8:	e0bffb15 	stw	r2,-20(fp)
  188aac:	00000506 	br	188ac4 <lseek+0x9c>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
  188ab0:	00bfde84 	movi	r2,-134
  188ab4:	e0bffb15 	stw	r2,-20(fp)
  188ab8:	00000206 	br	188ac4 <lseek+0x9c>
    }
  }
  else  
  {
    rc = -EBADFD;
  188abc:	00bfebc4 	movi	r2,-81
  188ac0:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
  188ac4:	e0bffb17 	ldw	r2,-20(fp)
  188ac8:	1000060e 	bge	r2,zero,188ae4 <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
  188acc:	01889d80 	call	1889d8 <alt_get_errno>
  188ad0:	e0fffb17 	ldw	r3,-20(fp)
  188ad4:	00c7c83a 	sub	r3,zero,r3
  188ad8:	10c00015 	stw	r3,0(r2)
    rc = -1;
  188adc:	00bfffc4 	movi	r2,-1
  188ae0:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
  188ae4:	e0bffb17 	ldw	r2,-20(fp)
}
  188ae8:	e037883a 	mov	sp,fp
  188aec:	dfc00117 	ldw	ra,4(sp)
  188af0:	df000017 	ldw	fp,0(sp)
  188af4:	dec00204 	addi	sp,sp,8
  188af8:	f800283a 	ret

00188afc <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
  188afc:	defffe04 	addi	sp,sp,-8
  188b00:	df000115 	stw	fp,4(sp)
  188b04:	df000104 	addi	fp,sp,4
  188b08:	e13fff15 	stw	r4,-4(fp)
}
  188b0c:	e037883a 	mov	sp,fp
  188b10:	df000017 	ldw	fp,0(sp)
  188b14:	dec00104 	addi	sp,sp,4
  188b18:	f800283a 	ret

00188b1c <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
  188b1c:	defffe04 	addi	sp,sp,-8
  188b20:	df000115 	stw	fp,4(sp)
  188b24:	df000104 	addi	fp,sp,4
  188b28:	e13fff15 	stw	r4,-4(fp)
}
  188b2c:	e037883a 	mov	sp,fp
  188b30:	df000017 	ldw	fp,0(sp)
  188b34:	dec00104 	addi	sp,sp,4
  188b38:	f800283a 	ret

00188b3c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  188b3c:	defffe04 	addi	sp,sp,-8
  188b40:	dfc00115 	stw	ra,4(sp)
  188b44:	df000015 	stw	fp,0(sp)
  188b48:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  188b4c:	00800674 	movhi	r2,25
  188b50:	10aa8504 	addi	r2,r2,-21996
  188b54:	10800017 	ldw	r2,0(r2)
  188b58:	10000526 	beq	r2,zero,188b70 <alt_get_errno+0x34>
  188b5c:	00800674 	movhi	r2,25
  188b60:	10aa8504 	addi	r2,r2,-21996
  188b64:	10800017 	ldw	r2,0(r2)
  188b68:	103ee83a 	callr	r2
  188b6c:	00000206 	br	188b78 <alt_get_errno+0x3c>
  188b70:	00800674 	movhi	r2,25
  188b74:	10b15a04 	addi	r2,r2,-15000
}
  188b78:	e037883a 	mov	sp,fp
  188b7c:	dfc00117 	ldw	ra,4(sp)
  188b80:	df000017 	ldw	fp,0(sp)
  188b84:	dec00204 	addi	sp,sp,8
  188b88:	f800283a 	ret

00188b8c <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
  188b8c:	defff904 	addi	sp,sp,-28
  188b90:	dfc00615 	stw	ra,24(sp)
  188b94:	df000515 	stw	fp,20(sp)
  188b98:	df000504 	addi	fp,sp,20
  188b9c:	e13ffd15 	stw	r4,-12(fp)
  188ba0:	e17ffe15 	stw	r5,-8(fp)
  188ba4:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  188ba8:	e0bffd17 	ldw	r2,-12(fp)
  188bac:	10000716 	blt	r2,zero,188bcc <read+0x40>
  188bb0:	e13ffd17 	ldw	r4,-12(fp)
  188bb4:	01400304 	movi	r5,12
  188bb8:	01805f00 	call	1805f0 <__mulsi3>
  188bbc:	00c00674 	movhi	r3,25
  188bc0:	18e81e04 	addi	r3,r3,-24456
  188bc4:	10c5883a 	add	r2,r2,r3
  188bc8:	00000106 	br	188bd0 <read+0x44>
  188bcc:	0005883a 	mov	r2,zero
  188bd0:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
  188bd4:	e0bffb17 	ldw	r2,-20(fp)
  188bd8:	10002026 	beq	r2,zero,188c5c <read+0xd0>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
  188bdc:	e0bffb17 	ldw	r2,-20(fp)
  188be0:	10800217 	ldw	r2,8(r2)
  188be4:	108000cc 	andi	r2,r2,3
  188be8:	10800060 	cmpeqi	r2,r2,1
  188bec:	1000171e 	bne	r2,zero,188c4c <read+0xc0>
        (fd->dev->read))
  188bf0:	e0bffb17 	ldw	r2,-20(fp)
  188bf4:	10800017 	ldw	r2,0(r2)
  188bf8:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
  188bfc:	10001326 	beq	r2,zero,188c4c <read+0xc0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
  188c00:	e0bffb17 	ldw	r2,-20(fp)
  188c04:	10800017 	ldw	r2,0(r2)
  188c08:	10c00517 	ldw	r3,20(r2)
  188c0c:	e0bfff17 	ldw	r2,-4(fp)
  188c10:	e13ffb17 	ldw	r4,-20(fp)
  188c14:	e17ffe17 	ldw	r5,-8(fp)
  188c18:	100d883a 	mov	r6,r2
  188c1c:	183ee83a 	callr	r3
  188c20:	e0bffc15 	stw	r2,-16(fp)
  188c24:	e0bffc17 	ldw	r2,-16(fp)
  188c28:	1000060e 	bge	r2,zero,188c44 <read+0xb8>
        {
          ALT_ERRNO = -rval;
  188c2c:	0188b3c0 	call	188b3c <alt_get_errno>
  188c30:	e0fffc17 	ldw	r3,-16(fp)
  188c34:	00c7c83a 	sub	r3,zero,r3
  188c38:	10c00015 	stw	r3,0(r2)
          return -1;
  188c3c:	00bfffc4 	movi	r2,-1
  188c40:	00000a06 	br	188c6c <read+0xe0>
        }
        return rval;
  188c44:	e0bffc17 	ldw	r2,-16(fp)
  188c48:	00000806 	br	188c6c <read+0xe0>
      }
      else
      {
        ALT_ERRNO = EACCES;
  188c4c:	0188b3c0 	call	188b3c <alt_get_errno>
  188c50:	00c00344 	movi	r3,13
  188c54:	10c00015 	stw	r3,0(r2)
  188c58:	00000306 	br	188c68 <read+0xdc>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
  188c5c:	0188b3c0 	call	188b3c <alt_get_errno>
  188c60:	00c01444 	movi	r3,81
  188c64:	10c00015 	stw	r3,0(r2)
  }
  return -1;
  188c68:	00bfffc4 	movi	r2,-1
}
  188c6c:	e037883a 	mov	sp,fp
  188c70:	dfc00117 	ldw	ra,4(sp)
  188c74:	df000017 	ldw	fp,0(sp)
  188c78:	dec00204 	addi	sp,sp,8
  188c7c:	f800283a 	ret

00188c80 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
  188c80:	defff904 	addi	sp,sp,-28
  188c84:	df000615 	stw	fp,24(sp)
  188c88:	df000604 	addi	fp,sp,24
  188c8c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  188c90:	0005303a 	rdctl	r2,status
  188c94:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  188c98:	e0fffc17 	ldw	r3,-16(fp)
  188c9c:	00bfff84 	movi	r2,-2
  188ca0:	1884703a 	and	r2,r3,r2
  188ca4:	1001703a 	wrctl	status,r2
  
  return context;
  188ca8:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
  188cac:	e0bffa15 	stw	r2,-24(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
  188cb0:	d0a00d17 	ldw	r2,-32716(gp)
  188cb4:	10c000c4 	addi	r3,r2,3
  188cb8:	00bfff04 	movi	r2,-4
  188cbc:	1884703a 	and	r2,r3,r2
  188cc0:	d0a00d15 	stw	r2,-32716(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
  188cc4:	d0e00d17 	ldw	r3,-32716(gp)
  188cc8:	e0bfff17 	ldw	r2,-4(fp)
  188ccc:	1885883a 	add	r2,r3,r2
  188cd0:	00c00834 	movhi	r3,32
  188cd4:	18c00004 	addi	r3,r3,0
  188cd8:	1880062e 	bgeu	r3,r2,188cf4 <sbrk+0x74>
  188cdc:	e0bffa17 	ldw	r2,-24(fp)
  188ce0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  188ce4:	e0bffd17 	ldw	r2,-12(fp)
  188ce8:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  188cec:	00bfffc4 	movi	r2,-1
  188cf0:	00000b06 	br	188d20 <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
  188cf4:	d0a00d17 	ldw	r2,-32716(gp)
  188cf8:	e0bffb15 	stw	r2,-20(fp)
  heap_end += incr; 
  188cfc:	d0e00d17 	ldw	r3,-32716(gp)
  188d00:	e0bfff17 	ldw	r2,-4(fp)
  188d04:	1885883a 	add	r2,r3,r2
  188d08:	d0a00d15 	stw	r2,-32716(gp)
  188d0c:	e0bffa17 	ldw	r2,-24(fp)
  188d10:	e0bffe15 	stw	r2,-8(fp)
  188d14:	e0bffe17 	ldw	r2,-8(fp)
  188d18:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
  188d1c:	e0bffb17 	ldw	r2,-20(fp)
} 
  188d20:	e037883a 	mov	sp,fp
  188d24:	df000017 	ldw	fp,0(sp)
  188d28:	dec00104 	addi	sp,sp,4
  188d2c:	f800283a 	ret

00188d30 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  188d30:	defffe04 	addi	sp,sp,-8
  188d34:	dfc00115 	stw	ra,4(sp)
  188d38:	df000015 	stw	fp,0(sp)
  188d3c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  188d40:	00800674 	movhi	r2,25
  188d44:	10aa8504 	addi	r2,r2,-21996
  188d48:	10800017 	ldw	r2,0(r2)
  188d4c:	10000526 	beq	r2,zero,188d64 <alt_get_errno+0x34>
  188d50:	00800674 	movhi	r2,25
  188d54:	10aa8504 	addi	r2,r2,-21996
  188d58:	10800017 	ldw	r2,0(r2)
  188d5c:	103ee83a 	callr	r2
  188d60:	00000206 	br	188d6c <alt_get_errno+0x3c>
  188d64:	00800674 	movhi	r2,25
  188d68:	10b15a04 	addi	r2,r2,-15000
}
  188d6c:	e037883a 	mov	sp,fp
  188d70:	dfc00117 	ldw	ra,4(sp)
  188d74:	df000017 	ldw	fp,0(sp)
  188d78:	dec00204 	addi	sp,sp,8
  188d7c:	f800283a 	ret

00188d80 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
  188d80:	defff904 	addi	sp,sp,-28
  188d84:	dfc00615 	stw	ra,24(sp)
  188d88:	df000515 	stw	fp,20(sp)
  188d8c:	df000504 	addi	fp,sp,20
  188d90:	e13ffd15 	stw	r4,-12(fp)
  188d94:	e17ffe15 	stw	r5,-8(fp)
  188d98:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  188d9c:	e0bffd17 	ldw	r2,-12(fp)
  188da0:	10000716 	blt	r2,zero,188dc0 <write+0x40>
  188da4:	e13ffd17 	ldw	r4,-12(fp)
  188da8:	01400304 	movi	r5,12
  188dac:	01805f00 	call	1805f0 <__mulsi3>
  188db0:	00c00674 	movhi	r3,25
  188db4:	18e81e04 	addi	r3,r3,-24456
  188db8:	10c5883a 	add	r2,r2,r3
  188dbc:	00000106 	br	188dc4 <write+0x44>
  188dc0:	0005883a 	mov	r2,zero
  188dc4:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
  188dc8:	e0bffb17 	ldw	r2,-20(fp)
  188dcc:	10001f26 	beq	r2,zero,188e4c <write+0xcc>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
  188dd0:	e0bffb17 	ldw	r2,-20(fp)
  188dd4:	10800217 	ldw	r2,8(r2)
  188dd8:	108000cc 	andi	r2,r2,3
  188ddc:	10001726 	beq	r2,zero,188e3c <write+0xbc>
  188de0:	e0bffb17 	ldw	r2,-20(fp)
  188de4:	10800017 	ldw	r2,0(r2)
  188de8:	10800617 	ldw	r2,24(r2)
  188dec:	10001326 	beq	r2,zero,188e3c <write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
  188df0:	e0bffb17 	ldw	r2,-20(fp)
  188df4:	10800017 	ldw	r2,0(r2)
  188df8:	10c00617 	ldw	r3,24(r2)
  188dfc:	e0bfff17 	ldw	r2,-4(fp)
  188e00:	e13ffb17 	ldw	r4,-20(fp)
  188e04:	e17ffe17 	ldw	r5,-8(fp)
  188e08:	100d883a 	mov	r6,r2
  188e0c:	183ee83a 	callr	r3
  188e10:	e0bffc15 	stw	r2,-16(fp)
  188e14:	e0bffc17 	ldw	r2,-16(fp)
  188e18:	1000060e 	bge	r2,zero,188e34 <write+0xb4>
      {
        ALT_ERRNO = -rval;
  188e1c:	0188d300 	call	188d30 <alt_get_errno>
  188e20:	e0fffc17 	ldw	r3,-16(fp)
  188e24:	00c7c83a 	sub	r3,zero,r3
  188e28:	10c00015 	stw	r3,0(r2)
        return -1;
  188e2c:	00bfffc4 	movi	r2,-1
  188e30:	00000a06 	br	188e5c <write+0xdc>
      }
      return rval;
  188e34:	e0bffc17 	ldw	r2,-16(fp)
  188e38:	00000806 	br	188e5c <write+0xdc>
    }
    else
    {
      ALT_ERRNO = EACCES;
  188e3c:	0188d300 	call	188d30 <alt_get_errno>
  188e40:	00c00344 	movi	r3,13
  188e44:	10c00015 	stw	r3,0(r2)
  188e48:	00000306 	br	188e58 <write+0xd8>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
  188e4c:	0188d300 	call	188d30 <alt_get_errno>
  188e50:	00c01444 	movi	r3,81
  188e54:	10c00015 	stw	r3,0(r2)
  }
  return -1;
  188e58:	00bfffc4 	movi	r2,-1
}
  188e5c:	e037883a 	mov	sp,fp
  188e60:	dfc00117 	ldw	ra,4(sp)
  188e64:	df000017 	ldw	fp,0(sp)
  188e68:	dec00204 	addi	sp,sp,8
  188e6c:	f800283a 	ret
